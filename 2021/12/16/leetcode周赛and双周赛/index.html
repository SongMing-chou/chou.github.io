<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>LC周赛&amp;&amp;双周赛记录 | Chou</title><meta name="keywords" content="Leetcode"><meta name="author" content="chou"><meta name="copyright" content="chou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="人菜瘾又大！！！AC和AK的感觉真的会上瘾，记录全部参加的周赛，记录的意义在于记录本身。最新的会放在前面。">
<meta property="og:type" content="article">
<meta property="og:title" content="LC周赛&amp;&amp;双周赛记录">
<meta property="og:url" content="http://example.com/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/index.html">
<meta property="og:site_name" content="Chou">
<meta property="og:description" content="人菜瘾又大！！！AC和AK的感觉真的会上瘾，记录全部参加的周赛，记录的意义在于记录本身。最新的会放在前面。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/55.png">
<meta property="article:published_time" content="2021-12-16T07:37:02.000Z">
<meta property="article:modified_time" content="2021-12-26T08:14:56.759Z">
<meta property="article:author" content="chou">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/55.png"><link rel="shortcut icon" href="/img/112.png"><link rel="canonical" href="http://example.com/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LC周赛&&双周赛记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-12-26 16:14:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/112.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/55.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Chou</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LC周赛&amp;&amp;双周赛记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-12-16T07:37:02.000Z" title="Created 2021-12-16 15:37:02">2021-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-12-26T08:14:56.759Z" title="Updated 2021-12-26 16:14:56">2021-12-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LC周赛&amp;&amp;双周赛记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>人菜瘾又大！！！AC和AK的感觉真的会上瘾，记录全部参加的周赛，记录的意义在于记录本身。<br>最新的会放在前面。</p>
<span id="more"></span>
<h2 id="加油！！！-目前AK几次，起飞，大部分三题。。。"><a href="#加油！！！-目前AK几次，起飞，大部分三题。。。" class="headerlink" title="加油！！！ 目前AK几次，起飞，大部分三题。。。"></a>加油！！！ <del>目前AK几次，起飞</del>，大部分三题。。。</h2><p>目前knight。<del>转码人也想拿Guardian</del>。 刚开始的太拉<del>没学也要迫不及待挨打</del>的场次就不记录了，自己偷偷记本子上了 <del>(主要是丢人)</del>。<br>leetcode主页<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/l_sir/">小丸子</a>    </p>
<p>2021再见！！2020<del>以后双周赛就不参加了，翻车掉分还睡不着</del></p>
<h2 id="《M的数据结构与算法笔记》"><a href="#《M的数据结构与算法笔记》" class="headerlink" title="《M的数据结构与算法笔记》"></a>《M的数据结构与算法笔记》</h2><h2 id="273场周赛-2021-12-26"><a href="#273场周赛-2021-12-26" class="headerlink" title="273场周赛 2021-12-26"></a>273场周赛 2021-12-26</h2><h3 id="第一题-easy"><a href="#第一题-easy" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="反转两次的数字"><a href="#反转两次的数字" class="headerlink" title="反转两次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/">反转两次的数字</a></h4><p>反转 一个整数意味着倒置它的所有位。  </p>
<ul>
<li>例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。<br>给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。<br>不含前导0，就看后面有没有了；  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isSameAfterReversals(int num) &#123;
        if(num &lt;&#x3D;9)return true;
        if(num%10 &#x3D;&#x3D; 0 )return false;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第二题-Medium"><a href="#第二题-Medium" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="执行所有后缀指令"><a href="#执行所有后缀指令" class="headerlink" title=" 执行所有后缀指令"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/"> 执行所有后缀指令</a></h4>现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。<br>另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：’L’（向左移动），’R’（向右移动），’U’（向上移动）和 ‘D’（向下移动）。<br>机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：<br>下一条指令将会导致机器人移动到网格外。<br>没有指令可以执行。<br>返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的 指令数目 。<br>直接模拟。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; startPos, string s) &#123;
        int m &#x3D; s.size();
        vector&lt;int&gt; res;
        for(int i &#x3D; 0;i &lt; m;i++) &#123;
            vector&lt;int&gt; temp &#x3D; startPos;
            int j &#x3D; i;
            for(;j &lt; m;j++) &#123;
                if(s[j] &#x3D;&#x3D; &#39;R&#39;) &#123;
                    temp[1]++;
                &#125;else if(s[j] &#x3D;&#x3D;&#39;L&#39;)temp[1]--;
                else if(s[j] &#x3D;&#x3D; &#39;U&#39;)temp[0]--;
                else if(s[j] &#x3D;&#x3D;&#39;D&#39;)temp[0]++;
                if(temp[0]&lt;0||temp[0]&gt;n -1||temp[1]&lt;0||temp[1]&gt;n - 1)break;
            &#125;
            res.push_back(j - i);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="第三题-Medium"><a href="#第三题-Medium" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="相同元素的间隔之和"><a href="#相同元素的间隔之和" class="headerlink" title="相同元素的间隔之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">相同元素的间隔之和</a></h4><p>给你一个下标从 0 开始、由 n 个整数组成的数组 arr 。<br>arr 中两个元素的 间隔 定义为它们下标之间的 绝对差 。更正式地，arr[i] 和 arr[j] 之间的间隔是 |i - j| 。<br>返回一个长度为 n 的数组 intervals ，其中 intervals[i] 是 arr[i] 和 arr 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。<br>注意：|x| 是 x 的绝对值。<br>直接哈希是不行的，只能哈希表排序之后前缀和。比赛的时候写得很乱，pair没必要，可以改下，省一波空间。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;long long&gt; getDistances(vector&lt;int&gt;&amp; arr) &#123;
        unordered_map&lt;int,vector&lt;pair&lt;int,long long&gt; &gt;&gt; map;
        vector&lt;long long&gt; res(arr.size());
        for(int i &#x3D; 0;i &lt; arr.size();i++) &#123;
            map[arr[i]].push_back(&#123;i,i&#125;);
        &#125;
        for(const auto item:map) &#123;
            vector&lt; pair&lt;int,long long&gt; &gt; kk(item.second.begin(),item.second.end());
            sort(kk.begin(),kk.end());
            int s &#x3D; kk[0].first;
            long long right &#x3D; 0,left &#x3D; 0;
            for(int i &#x3D; 0;i &lt; kk.size();i++) &#123;
                right+&#x3D;kk[i].first - s;
                if(i!&#x3D;0)
                kk[i].second+&#x3D;kk[i - 1].second;
            &#125;
            int l &#x3D; kk.size();
            res[kk[0].first] &#x3D; right;
            for(int i &#x3D; 1;i &lt; kk.size();i++) &#123;
                right -&#x3D;(long long) (kk[i].first - kk[i - 1].first)*(l - i);
                left  +&#x3D;(long long)(kk[i].first - kk[i - 1].first)*i;
                long long ok &#x3D; left+ right ;
                res[kk[i].first] &#x3D; ok;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard"><a href="#第四题-Hard" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="还原原数组"><a href="#还原原数组" class="headerlink" title="还原原数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-the-original-array/">还原原数组</a></h4><p>Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ：  </p>
<ul>
<li>对每个满足 0 &lt;= i &lt; n 的下标 i ，lower[i] = arr[i] - k  </li>
<li>对每个满足 0 &lt;= i &lt; n 的下标 i ，higher[i] = arr[i] + k<br>不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。<br>给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。<br>注意：生成的测试用例保证存在 至少一个 有效数组 arr 。  </li>
</ul>
<p>示例 1：<br>输入：nums = [2,10,6,4,8,12]<br>输出：[3,7,11]<br>解释：<br>如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。<br>组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。<br>另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。  </p>
<p>示例 2：<br>输入：nums = [1,1,3,3]<br>输出：[2,2]<br>解释：<br>如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。<br>组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。<br>注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。<br>这种方案是无效的，k 必须是一个正整数。  </p>
<p>示例 3：<br>输入：nums = [5,435]<br>输出：[220]<br>解释：<br>唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。<br>最小的肯定在lower中，直接枚举k，在check一下就行。比赛时拷贝map空间复杂度略大，可以双指针check</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; recoverArray(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(),nums.end());
        unordered_set&lt;int&gt; set;
        unordered_map&lt;int,int&gt; map;
        for(int i &#x3D; 0;i &lt; nums.size();i++) &#123;
            if(nums[i] - nums[0]!&#x3D; 0)
            set.insert(nums[i] - nums[0]);
            map[nums[i]]++;
        &#125;
        vector&lt;int&gt;k(set.begin(),set.end());
        sort(k.begin(),k.end());
        for(int i &#x3D; 0;i &lt; k.size();i++) &#123;
            if(k[i]%2!&#x3D;0)continue;&#x2F;&#x2F;如果不符合直接不用看了，k肯定是偶数
            unordered_map&lt;int,int&gt; temp &#x3D; map;
            vector&lt;int&gt; res ;
            for(int j &#x3D; 0;j &lt; nums.size();j++) &#123;
                if(temp[nums[j]] &gt; 0) &#123;
                    if(temp.find(nums[j] +k[i])!&#x3D;temp.end())&#123;
                        temp[nums[j]]--;
                        temp[nums[j] + k[i]]--;
                        res.push_back(nums[j]);
                    &#125;else &#123;
                        break;
                    &#125;
                &#125;
            &#125;
            if(res.size() &#x3D;&#x3D; nums.size()&#x2F;2) &#123;
                for(int o &#x3D; 0;o &lt; res.size();o++)res[o]+&#x3D;k[i]&#x2F;2;
                return res;
            &#125;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>the end!  </p>
<h2 id="68场双周赛-2021-12-25"><a href="#68场双周赛-2021-12-25" class="headerlink" title="68场双周赛 2021-12-25"></a>68场双周赛 2021-12-25</h2><h3 id="第一题-easy-1"><a href="#第一题-easy-1" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="句子中最多单词数"><a href="#句子中最多单词数" class="headerlink" title="句子中最多单词数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-words-found-in-sentences/">句子中最多单词数</a></h4><p>一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。<br>给你一个字符串数组 sentences ，其中 sentences[i] 表示单个 句子 。<br>请你返回单个句子里 单词的最多数目。<br>统计空格数+1即可<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int mostWordsFound(vector&lt;string&gt;&amp; s) &#123;
       int res &#x3D; 0;
        for(int i &#x3D; 0;i &lt; s.size();i++) &#123;
            int temp &#x3D; 1;
            for(int j &#x3D; 0;j&lt; s[i].size();j++) &#123;
                if(s[i][j] &#x3D;&#x3D; &#39; &#39;)temp++;
            &#125;
            res &#x3D; max(res,temp);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-1"><a href="#第二题-Medium-1" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="从给定原材料中找到所有可以做出的菜"><a href="#从给定原材料中找到所有可以做出的菜" class="headerlink" title=" 从给定原材料中找到所有可以做出的菜"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/"> 从给定原材料中找到所有可以做出的菜</a></h4><p>你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ，如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。<br>同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。<br>请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。<br>注意两道菜在它们的原材料中可能互相包含。<br>拓扑排序，但是数据量不大直接暴力；</p>
<ul>
<li>n == recipes.length == ingredients.length</li>
<li>1 &lt;= n &lt;= 100</li>
<li>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</li>
<li>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</li>
<li>recipes[i], ingredients[i][j] 和 supplies[k] 只包含小写英文字母。</li>
<li>所有 recipes 和 supplies 中的值互不相同。</li>
<li>ingredients[i] 中的字符串互不相同。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; findAllRecipes(vector&lt;string&gt;&amp; r, vector&lt;vector&lt;string&gt;&gt;&amp; in, vector&lt;string&gt;&amp; su) &#123;
        unordered_set&lt;string&gt;set;
        vector&lt;string&gt; res;
        unordered_set&lt;string&gt;yes;
        for(int i &#x3D; 0;i &lt; su.size();i++) &#123;
            set.insert(su[i]);
        &#125;
        int size &#x3D; -1,k &#x3D; 0;
        while(yes.size()!&#x3D;size)&#123;
            size &#x3D; yes.size();
        for(int i &#x3D;  0;i &lt; in.size();i++) &#123;
            int ok &#x3D; 1;
            if(yes.find(r[i]) !&#x3D; yes.end())continue;
            for(int j &#x3D; 0;j &lt; in[i].size();j++) &#123;
                if(set.find(in[i][j]) &#x3D;&#x3D; set.end() ) &#123;
                    ok &#x3D; 0;
                    break;
                &#125;
            &#125;
            if(ok ) &#123;
                yes.insert(r[i]);
                set.insert(r[i]);
                res.push_back(r[i]);
            &#125;
             
        &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="第三题-Medium-1"><a href="#第三题-Medium-1" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="判断一个括号字符串是否有效"><a href="#判断一个括号字符串是否有效" class="headerlink" title="判断一个括号字符串是否有效"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/">判断一个括号字符串是否有效</a></h4><p>一个括号字符串是只由 ‘(‘ 和 ‘)’ 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：  </p>
<ul>
<li>字符串为 ().  </li>
<li>它可以表示为 AB（A 与 B 连接），其中A 和 B 都是有效括号字符串。  </li>
<li>它可以表示为 (A) ，其中 A 是一个有效括号字符串。<br>给你一个括号字符串 s 和一个字符串 locked ，两者长度都为 n 。locked 是一个二进制字符串，只包含 ‘0’ 和 ‘1’ 。对于 locked 中 每一个 下标 i ：  </li>
<li>如果 locked[i] 是 ‘1’ ，你 不能 改变 s[i] 。  </li>
<li>如果 locked[i] 是 ‘0’ ，你 可以 将 s[i] 变为 ‘(‘ 或者 ‘)’ 。<br>如果你可以将 s 变为有效括号字符串，请你返回 true ，否则返回 false 。<br>翻车了。。。。没写出来。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canBeValid(string s, string lock) &#123;
        if (s.size() % 2) return false;
        int l &#x3D; 0, h &#x3D; 0;
        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;
            if (lock[i] &#x3D;&#x3D; &#39;0&#39;) &#123;
                l--, h++;
            &#125; else &#123;
                if (s[i] &#x3D;&#x3D; &#39;(&#39;) l++, h++;
                else l--, h--;
            &#125;

            l &#x3D; max(l, 0);
            if (l &gt; h) return false;
        &#125;
        return !l;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第四题-Hard-1"><a href="#第四题-Hard-1" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="一个区间内所有数乘积的缩写"><a href="#一个区间内所有数乘积的缩写" class="headerlink" title="一个区间内所有数乘积的缩写"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/">一个区间内所有数乘积的缩写</a></h4><p>给你两个正整数 left 和 right ，满足 left &lt;= right 。请你计算 闭区间 [left, right] 中所有整数的 乘积 。<br>由于乘积可能非常大，你需要将它按照以下步骤 缩写 ：<br>统计乘积中 后缀 0 的数目，将这个数目记为 C 。<br>比方说，1000 中有 3 个后缀 0 ，546 中没有后缀 0 。<br>将乘积中剩余数字记为 d 。如果 d &gt; 10 ，那么将乘积表示为 \<pre\>…\<suf\> 的形式，其中 \<pre\> 表示乘积最 开始 的 5 个数位，\<suf\> 表示删除后缀 0 之后 结尾的 5 个数位。如果 d &lt;= 10 ，我们不对它做修改。<br>比方说，我们将 1234567654321 表示为 12345…54321 ，但是 1234567 仍然表示为 1234567 。<br>最后，将乘积表示为 字符串 “\<pre\>…\<suf\>eC” 。<br>比方说，12345678987600000 被表示为 “12345…89876e5” 。<br>请你返回一个字符串，表示 闭区间 [left, right] 中所有整数 乘积 的 缩写 。<br>你以为我会吗？这场双周赛真的难。。。。，翻车的不止我一个。。  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>the end!  </p>
<h2 id="272场周赛-2021-12-19"><a href="#272场周赛-2021-12-19" class="headerlink" title="272场周赛 2021-12-19"></a>272场周赛 2021-12-19</h2><h3 id="第一题-easy-2"><a href="#第一题-easy-2" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="找出数组中第一个回文字符串"><a href="#找出数组中第一个回文字符串" class="headerlink" title="找出数组中第一个回文字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-palindromic-string-in-the-array/">找出数组中第一个回文字符串</a></h4><p>给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 “” 。<br>回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串<br>直接找就行<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string firstPalindrome(vector&lt;string&gt;&amp; s) &#123;
        for(int i &#x3D; 0;i &lt; s.size();i++) &#123;
            string tt &#x3D; s[i];
            reverse(tt.begin(),tt.end());
            if(tt &#x3D;&#x3D; s[i])return tt;
        &#125;
        return &quot;&quot;;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-2"><a href="#第二题-Medium-2" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="向字符串添加空格"><a href="#向字符串添加空格" class="headerlink" title="向字符串添加空格"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/adding-spaces-to-a-string/">向字符串添加空格</a></h4><p>给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。<br>数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。<br>例如，s = “EnjoyYourCoffee” 且 spaces = [5, 9] ，那么我们需要在 ‘Y’ 和 ‘C’ 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 “Enjoy Your Coffee” 。<br>请你添加空格，并返回修改后的字符串。<br>spaces 中的所有值 严格递增  </p>
<p>调整长度，后续遍历就行，注意spaces也要更改。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string addSpaces(string s, vector&lt;int&gt;&amp; spaces) &#123;
        int n &#x3D; spaces.size();
        int j &#x3D; s.size() - 1,k &#x3D; n - 1;
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            s.push_back(&#39; &#39;);
        &#125;
        for(int i &#x3D; 0;i &lt; spaces.size();i++)spaces[i]+&#x3D;i;
        for(int i &#x3D; s.size() - 1;i &gt;&#x3D; 0;i--) &#123;
            if(k&gt;&#x3D;0&amp;&amp;i &#x3D;&#x3D; spaces[k]) &#123;
                s[i] &#x3D; &#39; &#39;;
                k--;
            &#125;
            else &#123;
                s[i] &#x3D; s[j];
                j--;
            &#125;
        &#125;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-2"><a href="#第三题-Medium-2" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="股票平滑下降的"><a href="#股票平滑下降的" class="headerlink" title="股票平滑下降的"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/watering-plants-ii/">股票平滑下降的</a></h4><p>给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。<br>一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。<br>请你返回 平滑下降阶段 的数目。  </p>
<p>示例 1：<br>输入：prices = [3,2,1,4]<br>输出：7<br>解释：总共有 7 个平滑下降阶段：<br>[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]<br>注意，仅一天按照定义也是平滑下降阶段。<br>示例 2：<br>输入：prices = [8,6,7,7]<br>输出：4<br>解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]<br>由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。<br>示例 3：<br>输入：prices = [1]<br>输出：1<br>解释：总共有 1 个平滑下降阶段：[1]   </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long getDescentPeriods(vector&lt;int&gt;&amp; p) &#123;
        int n &#x3D; p.size();
        p.push_back(p.back()+2);
        long long res &#x3D; n;
        long long temp &#x3D; 0;
        for(int i &#x3D; 1;i &lt; n+1;i++) &#123;
            if(p[i] - p[i - 1] &#x3D;&#x3D; -1) &#123;
                temp++;
            &#125; else &#123;
                &#x2F;&#x2F; printf(&quot;%d %d\n&quot;,temp,i);
                res +&#x3D; (temp*(temp+1))&#x2F;2;
                temp &#x3D; 0;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第四题-Hard-2"><a href="#第四题-Hard-2" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="使数组K递增的最少操作次数"><a href="#使数组K递增的最少操作次数" class="headerlink" title="使数组K递增的最少操作次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/">使数组K递增的最少操作次数</a></h4><p>给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。<br>如果对于每个满足 k &lt;= i &lt;= n-1 的下标 i ，都有 arr[i-k] &lt;= arr[i] ，那么我们称 arr 是 K 递增 的。<br>比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为：<br>arr[0] &lt;= arr[2] (4 &lt;= 5)<br>arr[1] &lt;= arr[3] (1 &lt;= 2)<br>arr[2] &lt;= arr[4] (5 &lt;= 6)<br>arr[3] &lt;= arr[5] (2 &lt;= 2)<br>但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] &gt; arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] &gt; arr[3] ）。<br>每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。<br>请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。   </p>
<p>最长递增子序列模板题，二分就行，一遍二分就行<del>当时找模板的时候慌了</del>。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int kIncreasing(vector&lt;int&gt;&amp; arr, int k) &#123;
        int l &#x3D; 0,r &#x3D; arr.size(),res &#x3D; 0;
        while(l &lt; r) &#123;
            int mid &#x3D; l+(r - l)&#x2F;2;
            if(check(mid,arr,k)) &#123;
                res &#x3D; mid;
                r &#x3D; mid;
            &#125;else &#123;
                l &#x3D; mid+1;
            &#125;
        &#125;
        return res;
    &#125; 
     bool check(int mid ,vector&lt;int&gt;&amp; nums,int k) &#123;
        int  n &#x3D; (int)nums.size();
        if (n &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        int res &#x3D; 0;
        for(int j &#x3D; 0;j &lt; k;j++)&#123;
            int len &#x3D; 1;
            vector&lt;int&gt; temp(n&#x2F;k+2, 0);
            temp[len] &#x3D; nums[j];
        for (int i &#x3D; j+k; i &lt; n; i+&#x3D;k) &#123;
            if (nums[i] &gt;&#x3D; temp[len]) &#123;
                temp[++len] &#x3D; nums[i];
            &#125; else &#123;
                int left &#x3D; 1, right &#x3D; len, pos &#x3D; 0; 
                while (left &lt;&#x3D; right) &#123;
                    int mid &#x3D; (left + right) &gt;&gt; 1;
                    if (temp[mid] &lt;&#x3D; nums[i]) &#123;
                        pos &#x3D; mid;
                        left &#x3D; mid + 1;
                    &#125; else if(temp[mid] &gt; nums[i])&#123;
                        right &#x3D; mid - 1;
                    &#125;
                &#125;
                temp[pos + 1] &#x3D; nums[i];
            &#125;
        &#125;
            res +&#x3D; len ;
     &#125;
        return n - res &lt;&#x3D; mid; 
    &#125;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!  </p>
<h2 id="271场周赛-2021-12-12"><a href="#271场周赛-2021-12-12" class="headerlink" title="271场周赛   2021-12-12"></a>271场周赛   2021-12-12</h2><h3 id="第一题-easy-3"><a href="#第一题-easy-3" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="环和杆"><a href="#环和杆" class="headerlink" title="环和杆"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rings-and-rods/">环和杆</a></h4><p>总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。<br>给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：<br>第 i 对中的 第一个 字符表示第 i 个环的 颜色（’R’、’G’、’B’）。<br>第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（’0’ 到 ‘9’）。<br>例如，”R3G2B1” 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。<br>找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。</p>
<p>哈希表加位运算。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int countPoints(string rings) &#123;
        unordered_map&lt;int,int&gt; map;
        for(int i &#x3D; 1;i &lt; rings.size();i+&#x3D;2) &#123;
            int k &#x3D; 0;
            if(rings[i - 1] &#x3D;&#x3D; &#39;R&#39;)k &#x3D; 1;
            else if(rings[i - 1] &#x3D;&#x3D; &#39;G&#39;)k &#x3D;2;
            else k &#x3D; 4;
            map[rings[i]]&#x3D; (map[rings[i]]|k);
        &#125;
        int res &#x3D; 0;
        for(auto i &#x3D; map.begin();i!&#x3D;map.end();i++)&#123;
            if(i-&gt;second &#x3D;&#x3D; 7)res++;
        &#125;
        return res;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-3"><a href="#第二题-Medium-3" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="子数组范围和"><a href="#子数组范围和" class="headerlink" title="子数组范围和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/">子数组范围和</a></h4><p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。<br>返回 nums 中 所有 子数组范围的 和 。<br>子数组是数组中一个连续 非空 的元素序列。</p>
<p>直接暴力，记录开始位置，长度增长，维护一个最大一个最小值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long subArrayRanges(vector&lt;int&gt;&amp; nums) &#123;
        long long res &#x3D; 0;
        int n &#x3D; nums.size();
        &#x2F;&#x2F;起点
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            int mmin &#x3D; nums[i],mmax &#x3D; nums[i];
            for(int j &#x3D; i+1;j &lt; n;j++) &#123;
                mmin &#x3D; min(mmin,nums[j]),mmax &#x3D; max(mmax,nums[j]);
                res +&#x3D; mmax - mmin;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第三题-Medium-3"><a href="#第三题-Medium-3" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="给植物浇水II"><a href="#给植物浇水II" class="headerlink" title="给植物浇水II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/watering-plants-ii/">给植物浇水II</a></h4><p>Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。<br>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：<br> Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。<br>如果没有足够的水 完全 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。<br>不管植物需要多少水，浇水所耗费的时间都是一样的。<br>不能 提前重新灌满水罐。<br>每株植物都可以由 Alice 或者 Bob 来浇水。<br>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。<br>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。</p>
<p>模拟就行。。简单题。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    int res &#x3D; 0;
public:
    int minimumRefill(vector&lt;int&gt;&amp; s, int A, int B) &#123;
        int i &#x3D; 0,j &#x3D; s.size() - 1;
        int cura &#x3D; A,curb &#x3D; B;
        while(i&lt;j) &#123;
            if(s[i] &gt; cura) &#123;
                cura &#x3D; A - s[i];
                res++;
            &#125;else &#123;
                cura &#x3D; cura  - s[i];
            &#125;
            if(s[j] &gt; curb) &#123;
                curb &#x3D; B - s[j];
                res++;
            &#125;else&#123;
                curb &#x3D; curb - s[j];
            &#125;
            i++;j--;
        &#125;
        if(i&#x3D;&#x3D;j) &#123;
            if(s[i]&gt;max(cura,curb))res++;
            i++;j--;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard-3"><a href="#第四题-Hard-3" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="摘水果"><a href="#摘水果" class="headerlink" title="摘水果"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/">摘水果</a></h4><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。<br>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。<br>返回你可以摘到水果的 最大总数 </p>
<p>有个路径走两次，有一个路径走一次，模拟就行。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) &#123;
        vector&lt;long long&gt;f(200001);
        int j &#x3D; 0;
        unordered_map&lt;int,int&gt; map;
        for(int i &#x3D; 0;i &lt; fruits.size();i++) &#123;
            map[fruits[i][0]] &#x3D; fruits[i][1];
        &#125;
        for(int  i &#x3D;  0;i&lt;  200001;i++) &#123;
            if(j &lt; fruits.size()&amp;&amp;fruits[j][0] &#x3D;&#x3D; i) &#123;
                f[i]+&#x3D;fruits[j][1];
                if(i!&#x3D;0)&#123;
                    f[i]+&#x3D;f[i - 1];
                &#125;
                j++;
            &#125;else if(i!&#x3D;0)&#123;
                f[i] &#x3D; f[i - 1];
            &#125;
        &#125;
        int res &#x3D; 0;
        for(int i &#x3D; 0;i &lt;&#x3D; startPos&amp;&amp;i&lt;&#x3D;k&#x2F;2;i++) &#123;
            int left &#x3D; k - 2*(i)+startPos&lt;200000? k - 2*(i)+startPos:200000;
            int aa &#x3D; f[left] - f[startPos - i];
            if(map.find(startPos - i) !&#x3D; map.end()) &#123;
                aa+&#x3D;map[startPos - i];
            &#125;
            res &#x3D; max(res,aa);
        &#125;
        for(int i &#x3D; 0;i &lt;&#x3D; startPos&amp;&amp;i&lt;&#x3D;k;i++) &#123;
            int left &#x3D; (k - i)&#x2F;2+startPos&lt;200000?(k - i)&#x2F;2+startPos:200000;
            int aa &#x3D; f[left] - f[startPos - i];
            if(map.find(startPos - i) !&#x3D; map.end()) &#123;
                aa+&#x3D;map[startPos - i];
            &#125;
            res &#x3D; max(res,aa);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="66场双周赛-2021-11-27"><a href="#66场双周赛-2021-11-27" class="headerlink" title="66场双周赛 2021-11-27"></a>66场双周赛 2021-11-27</h2><h3 id="第一题-easy-4"><a href="#第一题-easy-4" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="统计出现过一次的公共字符串"><a href="#统计出现过一次的公共字符串" class="headerlink" title="统计出现过一次的公共字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-common-words-with-one-occurrence/">统计出现过一次的公共字符串</a></h4><p>给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int countWords(vector&lt;string&gt;&amp; s, vector&lt;string&gt;&amp; ss) &#123;
        unordered_map&lt;string ,int&gt; map;
        unordered_map&lt;string ,int&gt; map2;
        for(int i &#x3D; 0;i &lt; s.size();i++ )&#123;
            map[s[i]]++;
        &#125;
        for(int i &#x3D; 0;i &lt; ss.size();i++ )&#123;
            map2[ss[i]]++;
        &#125;
        int res &#x3D; 0;
        for(auto i&#x3D; map.begin();i!&#x3D;map.end();i++) &#123;
            if(i-&gt;second!&#x3D;1) &#123;
                continue;
            &#125;
            if(map2[i-&gt;first]&#x3D;&#x3D;1)res++;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-4"><a href="#第二题-Medium-4" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="从房屋收集需要的最少水桶数"><a href="#从房屋收集需要的最少水桶数" class="headerlink" title="从房屋收集需要的最少水桶数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/">从房屋收集需要的最少水桶数</a></h4><p>给你一个下标从 0 开始的字符串 street 。street 中每个字符要么是表示房屋的 ‘H’ ，要么是表示空位的 ‘.’ 。<br>你可以在 空位 放置水桶，从相邻的房屋收集雨水。位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。<br>在确保 每个 房屋旁边都 至少 有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。<br>示例 1：<br>输入：street = “H..H”<br>输出：2<br>解释：<br>我们可以在下标为 1 和 2 处放水桶。<br>“H..H” -&gt; “HBBH”（’B’ 表示放置水桶）。<br>下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。<br>所以每个房屋旁边都至少有一个水桶收集雨水。</p>
<p>示例 2：<br>输入：street = “.H.H.”<br>输出：1<br>解释：<br>我们可以在下标为 2 处放置一个水桶。<br>“.H.H.” -&gt; “.HBH.”（’B’ 表示放置水桶）。<br>下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。<br>所以每个房屋旁边都至少有一个水桶收集雨水。</p>
<p>示例 3：<br>输入：street = “.HHH.”<br>输出：-1<br>解释：<br>没有空位可以放置水桶收集下标为 2 处的雨水。<br>所以没有办法收集所有房屋的雨水。</p>
<p>示例 4：<br>输入：street = “H”<br>输出：-1<br>解释：<br>没有空位放置水桶。<br>所以没有办法收集所有房屋的雨水。</p>
<p>示例 5：<br>输入：street = “.”<br>输出：0<br>解释：<br>没有房屋需要收集雨水。<br>所以需要 0 个水桶。</p>
<p>先放一个桶可以接两个房屋的，然后再放其他的，比赛时代码很蠢。。。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumBuckets(string s) &#123;
        int res &#x3D; 0;
        for(int i &#x3D; 1;i&lt;s.size();i++) &#123;
            if(s[i - 1] &#x3D;&#x3D; &#39;H&#39;&amp;&amp;s[i+1]&#x3D;&#x3D;&#39;H&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;.&#39;)&#123;
                res++;
                s[i - 1] &#x3D; &#39;o&#39;;
                s[i+1]  &#x3D; &#39;o&#39;;
            &#125;
        &#125;
        for(int i &#x3D; 0;i &lt; s.size();i++) &#123;
            if(s[i] &#x3D;&#x3D;&#39;H&#39;) &#123;
                if(i - 1&gt;&#x3D;0 &amp;&amp; s[i - 1] &#x3D;&#x3D;&#39;.&#39;) &#123;
                    res++;
                    s[i] &#x3D; &#39;o&#39;;
                &#125;
                if(i+1&lt;s.size()&amp;&amp;s[i+1]&#x3D;&#x3D;&#39;.&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;H&#39;)&#123;
                    res++;
                    s[i]&#x3D;&#39;o&#39;;
                &#125;
            &#125;
        &#125;
        for(int i &#x3D; 0;i &lt; s.size();i++) &#123;
            if(s[i]&#x3D;&#x3D;&#39;H&#39;)return -1;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-4"><a href="#第三题-Medium-4" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="网格图中机器人回家的最小代价"><a href="#网格图中机器人回家的最小代价" class="headerlink" title="网格图中机器人回家的最小代价"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/">网格图中机器人回家的最小代价</a></h4><p>给你一个 m x n 的网格图，其中 (0, 0) 是最左上角的格子，(m - 1, n - 1) 是最右下角的格子。给你一个整数数组 startPos ，startPos = [startrow, startcol] 表示 初始 有一个 机器人 在格子 (startrow, startcol) 处。同时给你一个整数数组 homePos ，homePos = [homerow, homecol] 表示机器人的 家 在格子 (homerow, homecol) 处。</p>
<p>机器人需要回家。每一步它可以往四个方向移动：上，下，左，右，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从 0 开始的额整数数组：长度为 m 的数组 rowCosts  和长度为 n 的数组 colCosts 。</p>
<p>如果机器人往 上 或者往 下 移动到第 r 行 的格子，那么代价为 rowCosts[r] 。<br>如果机器人往 左 或者往 右 移动到第 c 列 的格子，那么代价为 colCosts[c] 。<br>请你返回机器人回家需要的 最小总代价<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minCost(vector&lt;int&gt;&amp; s, vector&lt;int&gt;&amp; h, vector&lt;int&gt;&amp; r, vector&lt;int&gt;&amp; c) &#123;
        long long res &#x3D; 0;
        vector&lt;int&gt; rr(r.size(),0),cc(c.size(),0);
        for(int i &#x3D; 0;i &lt; r.size();i++) &#123;
            if(i &#x3D;&#x3D; 0) &#123;
                rr[i] &#x3D; r[i];
            &#125;else&#123;
                rr[i] &#x3D; r[i] + rr[i - 1];
            &#125;
        &#125;
        for(int i &#x3D; 0;i &lt; c.size();i++) &#123;
            if(i &#x3D;&#x3D; 0) &#123;
                cc[i] &#x3D; c[i];
            &#125;else&#123;
                cc[i] &#x3D; c[i] + cc[i - 1];
            &#125;
        &#125;
        res &#x3D; abs(rr[s[0]] - rr[h[0]]) + abs(cc[s[1]] - cc[h[1]]);
        if(h[0] &lt; s[0])&#123;
            res+&#x3D;r[h[0]] - r[s[0]];
        &#125;
        if(h[1]&lt;s[1]) &#123;
            res+&#x3D;c[h[1]] - c[s[1]];
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard-4"><a href="#第四题-Hard-4" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="统计农场中肥沃金字塔的数目"><a href="#统计农场中肥沃金字塔的数目" class="headerlink" title="统计农场中肥沃金字塔的数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/">统计农场中肥沃金字塔的数目</a></h4><p>有一个 矩形网格 状的农场，划分为 m 行 n 列的单元格。每个格子要么是 肥沃的 （用 1 表示），要么是 贫瘠 的（用 0 表示）。网格图以外的所有与格子都视为贫瘠的。<br>农场中的 金字塔 区域定义如下：<br>区域内格子数目 大于 1 且所有格子都是 肥沃的 。<br>金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r &lt;= i &lt;= r + h - 1 且 c - (i - r) &lt;= j &lt;= c + (i - r) 。<br>一个 倒金字塔 类似定义如下：<br>区域内格子数目 大于 1 且所有格子都是 肥沃的 。<br>倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r - h + 1 &lt;= i &lt;= r 且 c - (r - i) &lt;= j &lt;= c + (r - i) 。<br>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。<br><img src="/img/22.jpg" alt=""><br>动态规划，记录金字塔的顶端，金字塔顶端的下面三个块可以组成金字塔的话，这个顶端一定可以组成一个比下面底层更高的塔+和底层三个(最少那个)一样多一样高的塔。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    int res &#x3D; 0;
public:
    int countPyramids(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int n &#x3D; grid.size(),m &#x3D; grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; temp(n,vector&lt;int&gt;(m,0));
        vector&lt;vector&lt;int&gt;&gt; temp2(n,vector&lt;int&gt;(m,0));
        &#x2F;&#x2F;正着
        for(int i &#x3D; n - 2;i&gt;&#x3D;0;i--) &#123;
            for(int j &#x3D; 1;j &lt; m - 1;j++) &#123;
                if(grid[i][j] &#x3D;&#x3D; 1&amp;&amp;grid[i + 1][j] &#x3D;&#x3D; 1&amp;&amp;grid[i + 1][j - 1] &#x3D;&#x3D; 1&amp;&amp;grid[i + 1][j + 1] &#x3D;&#x3D; 1) &#123;
                    temp[i][j] &#x3D; min(temp[i + 1][j],min(temp[i + 1][j - 1],temp[i + 1][j+ 1]))+1;
                &#125;
            &#125;
        &#125;
        &#x2F;&#x2F;倒着
        for(int i &#x3D; 1;i&lt;n;i++) &#123;
            for(int j &#x3D; 1;j &lt; m - 1;j++) &#123;
                if(grid[i][j] &#x3D;&#x3D; 1&amp;&amp;grid[i  - 1][j] &#x3D;&#x3D; 1&amp;&amp;grid[i - 1][j - 1] &#x3D;&#x3D; 1&amp;&amp;grid[i - 1][j + 1] &#x3D;&#x3D; 1) &#123;
                    temp2[i][j] &#x3D; min(temp2[i - 1][j],min(temp2[i - 1][j - 1],temp2[i - 1][j+ 1]))+1;
                &#125;
            &#125;
        &#125;
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            for(int j &#x3D; 0;j &lt; m;j++) &#123;
                res+&#x3D;temp[i][j]+temp2[i][j];
            &#125;
        &#125;
        return res;

    &#125;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="268场周赛-2021-11-21"><a href="#268场周赛-2021-11-21" class="headerlink" title="268场周赛 2021-11-21"></a>268场周赛 2021-11-21</h2><h3 id="第一题-easy-5"><a href="#第一题-easy-5" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="两栋颜色不同且距离最远的房子"><a href="#两栋颜色不同且距离最远的房子" class="headerlink" title="两栋颜色不同且距离最远的房子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-furthest-houses-with-different-colors/">两栋颜色不同且距离最远的房子</a></h4><p>街上有 n 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 0 开始且长度为 n 的整数数组 colors ，其中 colors[i] 表示第  i 栋房子的颜色。<br>返回 两栋 颜色 不同 房子之间的 最大 距离。<br>第 i 栋房子和第 j 栋房子之间的距离是 abs(i - j) ，其中 abs(x) 是 x 的绝对值。</p>
<p>暴力，哈希表记录每种颜色最左的下标就行。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxDistance(vector&lt;int&gt;&amp; c) &#123;
     unordered_map&lt;int,int&gt; map;
        int res &#x3D; 0;
        for(int i &#x3D; 0;i &lt; c.size();i++) &#123;
            for(auto j&#x3D;map.begin();j!&#x3D;map.end();j++) &#123;
                if(j-&gt;first!&#x3D;c[i]) &#123;
                    res &#x3D; max(res,i-j-&gt;second);
                &#125;
            &#125;
            if(map.find(c[i]) &#x3D;&#x3D; map.end())&#123;
                map[c[i]] &#x3D; i;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-5"><a href="#第二题-Medium-5" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="给植物浇水"><a href="#给植物浇水" class="headerlink" title="给植物浇水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/watering-plants/">给植物浇水</a></h4><p>你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。<br>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p>
<ul>
<li>按从左到右的顺序给植物浇水。</li>
<li>在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li>
<li>你 不能 提前重新灌满水罐。<br>最初，你在河边（也就是，x = -1），在 x 轴上每移动 一个单位 都需要 一步 。<br>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。</li>
</ul>
<p>输入：plants = [2,2,3,3], capacity = 5<br>输出：14<br>解释：从河边开始，此时水罐是装满的：</p>
<ul>
<li>走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。</li>
<li>走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。</li>
<li>由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。</li>
<li>走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。</li>
<li>由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。</li>
<li>走到植物 3 (4 步) ，浇水。<br>需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。</li>
</ul>
<p>输入：plants = [1,1,1,4,2,3], capacity = 4<br>输出：30<br>解释：从河边开始，此时水罐是装满的：</p>
<ul>
<li>走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。</li>
<li>走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。</li>
<li>走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。</li>
<li>走到植物 5 (6 步) ，浇水。<br>需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 </li>
</ul>
<p>输入：plants = [7,7,7,7,7,7,7], capacity = 8<br>输出：49<br>解释：每次浇水都需要重新灌满水罐。<br>需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int wateringPlants(vector&lt;int&gt;&amp; p, int c) &#123;
        int res &#x3D; 0,cur &#x3D; c,f &#x3D; 0;
        for(int i &#x3D; 0;i &lt; p.size();i++) &#123;
            if(cur &gt;&#x3D; p[i]) &#123;
                cur -&#x3D;p[i];
                res++;
            &#125;else&#123;
                res+&#x3D;2*(i)+1;
                cur &#x3D; c - p[i];
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第三题-Medium-5"><a href="#第三题-Medium-5" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="区间内查询数字的频率"><a href="#区间内查询数字的频率" class="headerlink" title="区间内查询数字的频率"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-frequency-queries/">区间内查询数字的频率</a></h4><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。<br>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。<br>请你实现 RangeFreqQuery 类：</p>
<ul>
<li>RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。</li>
<li>int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。<br>一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</li>
</ul>
<p>昨天做了一个题 叫快照数组的，和这个原理差不多，记录每个数字出现的下表，存在unordered_map<int,vector<int>&gt; map;中，两次二分查找，这两个下标的距离就是个数。复杂度(logn);<br>前缀和的方式会超时，构造前缀和的时候复杂度已经（n*n),还有的就是二分的时候要引用，传值在拷贝vector<int>开销很大，也会超时。</p>
<p>输入：<br>[“RangeFreqQuery”, “query”, “query”]<br>[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]<br>输出：<br>[null, 1, 2]<br>解释：<br>RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);<br>rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。<br>rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class RangeFreqQuery &#123;
    unordered_map&lt;int,vector&lt;int&gt;&gt;map;
public:
    RangeFreqQuery(vector&lt;int&gt;&amp; arr) &#123;
        for(int i &#x3D; 0;i &lt; arr.size();i++) &#123;
            map[arr[i]].push_back(i);
        &#125;
    &#125;
    int query(int left, int right, int value) &#123;
        if(map.find(value) &#x3D;&#x3D; map.end())return 0;
        int l &#x3D; find_min(left,map[value]),r &#x3D; find_max(right,map[value]);
        return r - l;
    &#125;
    int find_min(int ll,vector&lt;int&gt; &amp;arr) &#123;
        int l &#x3D; 0,r &#x3D; arr.size() - 1,res &#x3D; r;
        while(l &lt;&#x3D; r) &#123;
            int mid &#x3D; l+(r - l)&#x2F;2;
            if(arr[mid]&gt;&#x3D;ll) &#123;
                res &#x3D; min(res,mid);
                r &#x3D; mid-1;
            &#125;else&#123;
                l &#x3D; mid + 1;
            &#125;
        &#125;
        return l;
    &#125;
    int find_max(int ll,vector&lt;int&gt; &amp;arr) &#123;
        int l &#x3D; 0,r &#x3D; arr.size() - 1,res &#x3D; 0;
        while(l &lt;&#x3D; r) &#123;
            int mid &#x3D; l+(r - l)&#x2F;2;
            if(arr[mid]&lt;&#x3D; ll) &#123;
                res &#x3D; max(res,mid);
                l &#x3D; mid+1;
            &#125;else&#123;
                r &#x3D; mid - 1;
            &#125;
        &#125;
        return l;
    &#125;
&#125;;

&#x2F;**
 * Your RangeFreqQuery object will be instantiated and called as such:
 * RangeFreqQuery* obj &#x3D; new RangeFreqQuery(arr);
 * int param_1 &#x3D; obj-&gt;query(left,right,value);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第四题-Hard-5"><a href="#第四题-Hard-5" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="K镜像数字的和"><a href="#K镜像数字的和" class="headerlink" title="K镜像数字的和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-k-mirror-numbers/">K镜像数字的和</a></h4><p>一个 k 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 0 的 正 整数。</p>
<ul>
<li>比方说，9 是一个 2 镜像数字。9 在十进制下为 9 ，二进制下为 1001 ，两者从前往后读和从后往前读都一样。</li>
<li>相反地，4 不是一个 2 镜像数字。4 在二进制下为 100 ，从前往后和从后往前读不相同。<br>给你进制 k 和一个数字 n ，请你返回 k 镜像数字中 最小 的 n 个数 之和 。</li>
</ul>
<p>输入：k = 2, n = 5<br>输出：25<br>解释：<br>最小的 5 个 2 镜像数字和它们的二进制表示如下：<br>  十进制       二进制<br>    1          1<br>    3          11<br>    5          101<br>    7          111<br>    9          1001<br>它们的和为 1 + 3 + 5 + 7 + 9 = 25 。</p>
<p>输入：k = 3, n = 7<br>输出：499<br>解释：<br>7 个最小的 3 镜像数字和它们的三进制表示如下：<br>  十进制       三进制<br>    1          1<br>    2          2<br>    4          11<br>    8          22<br>    121        11111<br>    151        12121<br>    212        21212<br>它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。</p>
<p>抄了关注的一个c++大佬的代码，贴一下。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long kMirror(int k, int n) &#123;
        auto check &#x3D; [](long long num, int k) -&gt; bool &#123;
            string s;
            while (num !&#x3D; 0) &#123;
                s.push_back(&#39;0&#39; + num % k);
                num &#x2F;&#x3D; k;
            &#125;
            for (int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; ++i, --j) &#123;
                if (s[i] !&#x3D; s[j]) &#123;
                    return false;
                &#125;
            &#125;
            return true;
        &#125;;
        auto reverse &#x3D; [](int num) -&gt; int &#123;
            int ret &#x3D; 0;
            while (num !&#x3D; 0) &#123;
                ret &#x3D; ret * 10 + num % 10;
                num &#x2F;&#x3D; 10;
            &#125;
            return ret;
        &#125;;
        long long ret &#x3D; 0;
        for (int i &#x3D; 1; i &lt; 10 &amp;&amp; n &gt; 0; ++i) &#123;
            if (check(i, k)) &#123;
                ret +&#x3D; i;
                n--;
            &#125;
        &#125;
        for (int i &#x3D; 0; n &gt; 0; ++i) &#123;
            int l &#x3D; pow(10, i);
            int r &#x3D; pow(10, i + 1);
            for (int j &#x3D; l; j &lt; r &amp;&amp; n &gt; 0; ++j) &#123;
                long long num &#x3D; 1LL * r * j + reverse(j);
                if (check(num, k)) &#123;
                    ret +&#x3D; num;
                    n--;
                &#125;
            &#125;
            for (int j &#x3D; l; j &lt; r &amp;&amp; n &gt; 0; ++j) &#123;
                for (int t &#x3D; 0; t &lt; 10 &amp;&amp; n &gt; 0; ++t) &#123;
                    long long num &#x3D; 1LL * r * j * 10 + 1LL * r * t + reverse(j);
                    if (check(num, k)) &#123;
                        ret +&#x3D; num;
                        n--;
                    &#125;
                &#125;
            &#125;
        &#125;
        return ret;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="267场周赛-2021-11-14"><a href="#267场周赛-2021-11-14" class="headerlink" title="267场周赛 2021-11-14"></a>267场周赛 2021-11-14</h2><h3 id="第一题-easy-6"><a href="#第一题-easy-6" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="买票需要的时间"><a href="#买票需要的时间" class="headerlink" title="买票需要的时间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/time-needed-to-buy-tickets/">买票需要的时间</a></h4><p>有 n 个人前来排队买票，其中第 0 人站在队伍 最前方 ，第 (n - 1) 人站在队伍 最后方 。<br>给你一个下标从 0 开始的整数数组 tickets ，数组长度为 n ，其中第 i 人想要购买的票数为 tickets[i] 。<br>每个人买票都需要用掉 恰好 1 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。<br>返回位于位置 k（下标从 0 开始）的人完成买票需要的时间（以秒为单位）。</p>
<p>直接计算，在位置k前的人要排min(tickets[i],tickets[k]),后面的人需要排min(tickets[i],tickets[k] - 1)<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int timeRequiredToBuy(vector&lt;int&gt;&amp; t, int k) &#123;
        int aa &#x3D; t[k];
        int res &#x3D;0;
        for(int i &#x3D; 0;i &lt; t.size();i++) &#123;
            if(i &gt; k) &#123;
                res+&#x3D;min(aa - 1,t[i]);
            &#125;else&#123;
                res+&#x3D;min(aa,t[i]);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-6"><a href="#第二题-Medium-6" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="反转偶数链表长度的节点"><a href="#反转偶数链表长度的节点" class="headerlink" title="反转偶数链表长度的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups/">反转偶数链表长度的节点</a></h4><p>给你一个链表的头节点 head 。<br>链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列（1, 2, 3, 4, …）。一个组的 长度 就是组中分配到的节点数目。换句话说：</p>
<ul>
<li>节点 1 分配给第一组</li>
<li>节点 2 和 3 分配给第二组</li>
<li>节点 4、5 和 6 分配给第三组，以此类推<br>注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。<br>反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 head </li>
</ul>
<p>直接存到vector中，这样不会出错。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseEvenLengthGroups(ListNode* head) &#123;
        vector&lt;vector&lt;ListNode*&gt;&gt;temp;
        int k &#x3D; 1;
        while(head!&#x3D;nullptr) &#123;
            vector&lt;ListNode*&gt;kk;
            int ll &#x3D; k;
            while(ll&gt;0&amp;&amp;head!&#x3D;nullptr) &#123;
                kk.push_back(head);
                head&#x3D;head-&gt;next;
                ll--;
            &#125;
            temp.push_back(kk);
            k++;
        &#125;
        ListNode*res &#x3D; new ListNode(0);
        ListNode*last &#x3D; res;
        for(int i &#x3D; 0;i &lt; temp.size();i++) &#123;
            if(temp[i].size()%2&#x3D;&#x3D;0) &#123;
                reverse(temp[i].begin(),temp[i].end());
            &#125;
            for(int j &#x3D; 0;j&lt; temp[i].size();j++) &#123;
                last -&gt;next &#x3D; temp[i][j];
                last &#x3D; temp[i][j];
            &#125;
        &#125;
        last-&gt;next &#x3D; nullptr;
        return res-&gt;next;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-6"><a href="#第三题-Medium-6" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="解码斜向换位密码"><a href="#解码斜向换位密码" class="headerlink" title="解码斜向换位密码"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-the-slanted-ciphertext/">解码斜向换位密码</a></h4><p>字符串 originalText 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 encodedText 。<br>originalText 先按从左上到右下的方式放置到矩阵中。<br>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 originalText 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ‘ ‘ 进行填充。矩阵的列数需满足：用 originalText 填充之后，最右侧列 不为空 。</p>
<p>先分层，然后在计算宽度，最后把末尾空格去掉。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string decodeCiphertext(string e, int rows) &#123;
        int m &#x3D; e.size()&#x2F;rows;
        vector&lt;vector&lt;char&gt;&gt; temp(rows,vector&lt;char&gt;(m));
        for(int i &#x3D; 0;i &lt; e.size();i++) &#123;
            temp[i&#x2F;m][i - i&#x2F;m*m] &#x3D; e[i];
        &#125;
        string res ;
        int flag &#x3D; 0;
        for(int j &#x3D; 0;j &lt;temp.size();j++)&#123;
            temp[j].push_back(&#39; &#39;);
        for(int i &#x3D;temp[0].size()-1;i&gt;&#x3D;0;i--) &#123;
            if(temp[j][i]!&#x3D;&#39; &#39;)&#123;
                flag &#x3D;max(flag,i) ;
                break;
            &#125;
        &#125;
        &#125;
        for(int i &#x3D; 0;i &lt;&#x3D; flag;i++) &#123;
                for(int j &#x3D; 0;j &lt; rows;j++) &#123;
                    if(j+i&lt;temp[0].size())
                    res.push_back(temp[j][j+i]);
                &#125;
        &#125;
        for(int i &#x3D; res.size() - 1;i&gt;&#x3D;0;i--) &#123;
            if(res[i] &#x3D;&#x3D; &#39; &#39;)res.pop_back();
            else break;
        &#125;
        return res;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第四题-Hard-6"><a href="#第四题-Hard-6" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="处理含限制条件的好友请求"><a href="#处理含限制条件的好友请求" class="headerlink" title="处理含限制条件的好友请求"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/process-restricted-friend-requests/">处理含限制条件的好友请求</a></h4><p>给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。<br>给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。<br>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。<br>如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。<br>返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。<br>注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p>
<p>当时在想各种优化各种map，其实就是一个并查集，然后暴力判断合并的人和这个小团体的黑名单的人所在集是否相同就行了。<br>没做出来，午觉醒来补写出来了。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class UF &#123;
public:
    vector&lt;int&gt; f;
    UF(int n) &#123;
        f.resize(n);
        for(int i&#x3D;0;i&lt;n;i++) &#123;
            f[i] &#x3D; i;
        &#125;
    &#125;
    int F(int x) &#123;
        return x &#x3D;&#x3D; f[x] ? x: f[x] &#x3D; F(f[x]);
    &#125;
    void inline U (int x ,int y) &#123;
        f[F(x)] &#x3D; F(y);
    &#125;
&#125;;

class Solution &#123;
public:
    vector&lt;bool&gt; friendRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;vector&lt;int&gt;&gt;&amp; req) &#123;
        unordered_map&lt;int,unordered_set&lt;int&gt;&gt; map;
        UF a(n);
        for(int i &#x3D; 0;i &lt; res.size();i++) &#123;
            map[res[i][0]].insert(res[i][1]);
            map[res[i][1]].insert(res[i][0]);
        &#125;
        vector&lt;bool&gt;ans;
        for(int i &#x3D; 0;i &lt; req.size();i++) &#123;
            bool flag &#x3D; true;
            vector&lt;int&gt;u00;
            int u0 &#x3D; a.F(req[i][0]),u1 &#x3D; a.F(req[i][1]);
        
            for(int j &#x3D; 0;j &lt; a.f.size();j++) &#123;
                if(a.F(j) &#x3D;&#x3D; u0) &#123;
                    u00.push_back(j);
                &#125;
            &#125;
        
            for(int j &#x3D; 0;j &lt; u00.size();j++) &#123;
                for(auto kk:map[u00[j]]) &#123;
                    if(a.F(kk) &#x3D;&#x3D; u1) &#123;
                        flag &#x3D; false;
                    &#125;
                &#125;
            &#125;
            if(flag)&#123;
                a.U(req[i][0],req[i][1]);
            &#125;
            ans.push_back(flag);
        &#125;
        return ans;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="265场周赛-2021-10-31"><a href="#265场周赛-2021-10-31" class="headerlink" title="265场周赛 2021-10-31"></a>265场周赛 2021-10-31</h2><h3 id="第一题-easy-7"><a href="#第一题-easy-7" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="值相等的最小索引"><a href="#值相等的最小索引" class="headerlink" title="值相等的最小索引"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-index-with-equal-value/">值相等的最小索引</a></h4><p>给你一个下标从 0 开始的整数数组 nums ，返回 nums 中满足 i mod 10 == nums[i] 的最小下标 i ；如果不存在这样的下标，返回 -1 。<br>x mod y 表示 x 除以 y 的 余数 。</p>
<p>直接写，第一次看错题<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int smallestEqual(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            if(i%10 &#x3D;&#x3D; nums[i])return i;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-7"><a href="#第二题-Medium-7" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="找出临界点之间的最小和最大距离"><a href="#找出临界点之间的最小和最大距离" class="headerlink" title="找出临界点之间的最小和最大距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/">找出临界点之间的最小和最大距离</a></h4><p>链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。<br>如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个  局部极大值点 。<br>如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个  局部极小值点 。<br>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。<br>给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。</p>
<p>我以为是不同极值点之间的距离，然后就被wa了，原来是不区分的。。。。<br>先用数组存起来，然后记录+排序<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; nodesBetweenCriticalPoints(ListNode* head) &#123;
        vector&lt;int&gt; temp;
        while(head!&#x3D;nullptr) &#123;
            temp.push_back(head-&gt;val);
            head &#x3D; head-&gt;next;
        &#125;
        vector&lt;int&gt; maxx;
        for(int i &#x3D; 1;i &lt; temp.size() - 1;i++) &#123;
            if(temp[i]&gt;temp[i - 1]&amp;&amp;temp[i]&gt;temp[i+1]) &#123;
                maxx.push_back(i);
            &#125;else if(temp[i]&lt;temp[i - 1]&amp;&amp;temp[i]&lt;temp[i+1]) &#123;
                maxx.push_back(i);
            &#125;
        &#125;
        vector&lt;int&gt; ans&#x3D;&#123;INT_MAX,-1&#125;;
        sort(maxx.begin(),maxx.end());
        if(maxx.size() &lt; 2)return &#123;-1,-1&#125;;
        for(int i &#x3D; 0;i &lt; maxx.size() - 1;i++) &#123;
            ans[0] &#x3D; min(maxx[i + 1] - maxx[i],ans[0]);
        &#125;
        ans[1] &#x3D; maxx.back() - maxx[0];
        return ans;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-7"><a href="#第三题-Medium-7" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="转化数字的最小运算数"><a href="#转化数字的最小运算数" class="headerlink" title="转化数字的最小运算数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></h4><p>给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。<br>整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算：<br>如果 0 &lt;= x &lt;= 1000 ，那么，对于数组中的任一下标 i（0 &lt;= i &lt; nums.length），可以将 x 设为下述任一值：</p>
<ul>
<li>x + nums[i]</li>
<li>x - nums[i]</li>
<li>x ^ nums[i]（按位异或 XOR）<br>注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 &lt;= x &lt;= 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。<br>返回将 x = start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。</li>
</ul>
<p>bfs就可以，但是要剪枝，不然妥妥超时。</p>
<ul>
<li>剪枝1.用set保存，出现过相同的值就不用放进queue了。</li>
<li>剪枝2.先检查是否是0=&lt;x&lt;=1000再放进queue。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumOperations(vector&lt;int&gt;&amp; nums, int start, int goal) &#123;
        int n &#x3D; nums.size();
        queue&lt;int&gt; q;
        q.push(start);
        unordered_set&lt;int&gt; set;
        set.insert(start);
        int k &#x3D; 0;
        while(!q.empty()) &#123;
            int ss &#x3D; q.size();
            while(ss--) &#123;
                int tt &#x3D; q.front();
                q.pop();
                if(tt &#x3D;&#x3D; goal)return k;
                else if(tt&lt;0||tt&gt;1000)continue;
                for(int i &#x3D; 0;i &lt; n;i++) &#123;
                    int a &#x3D; tt +nums[i];
                    int b &#x3D; tt - nums[i];
                    int c &#x3D; tt^nums[i];
                    if(a &#x3D;&#x3D; goal||b&#x3D;&#x3D;goal||c &#x3D;&#x3D; goal)return k+1;
                    if(set.find(a)&#x3D;&#x3D;set.end()&amp;&amp;a&gt;&#x3D;0&amp;&amp;a&lt;&#x3D;1000) &#123;
                        set.insert(a);
                        q.push(a);
                    &#125;
                    if(set.find(b)&#x3D;&#x3D;set.end()&amp;&amp;b&gt;&#x3D;0&amp;&amp;b&lt;&#x3D;1000) &#123;
                        set.insert(b);
                        q.push(b);
                    &#125;
                    if(set.find(c) &#x3D;&#x3D; set.end()&amp;&amp;c&gt;&#x3D;0&amp;&amp;c&lt;&#x3D;1000) &#123;
                        set.insert(c);
                        q.push(c);
                    &#125;
                &#125; 
            &#125;
             k++;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第四题-Hard-7"><a href="#第四题-Hard-7" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="同源字符串检测"><a href="#同源字符串检测" class="headerlink" title="同源字符串检测"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/">同源字符串检测</a></h4><p>原字符串由小写字母组成，可以按下述步骤编码：<br>任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。<br>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。<br>重新 顺次连接 序列，得到编码后的字符串。<br>例如，编码 “abcdefghijklmnop” 的一种方法可以描述为：<br>将原字符串分割得到一个序列：[“ab”, “cdefghijklmn”, “o”, “p”] 。<br>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 [“ab”, “12”, “1”, “p”] 。<br>重新顺次连接序列中的元素，得到编码后的字符串：”ab121p” 。<br>给你两个编码后的字符串 s1 和 s2 ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 s1 和 s2 原字符串，返回 true ；否则，返回 false。<br>注意：生成的测试用例满足 s1 和 s2 中连续数字数不超过 3 。</p>
<p>输入：s1 = “internationalization”, s2 = “i18n”<br>输出：true<br>解释：”internationalization” 可以作为原字符串</p>
<ul>
<li>“internationalization”<br>-&gt; 分割：      [“internationalization”]<br>-&gt; 不替换任何元素<br>-&gt; 连接：      “internationalization”，得到 s1</li>
<li>“internationalization”<br>-&gt; 分割：      [“i”, “nternationalizatio”, “n”]<br>-&gt; 替换：      [“i”, “18”,                 “n”]<br>-&gt; 连接：      “i18n”，得到 s2</li>
</ul>
<p>输入：s1 = “l123e”, s2 = “44”<br>输出：true<br>解释：”leetcode” 可以作为原字符串</p>
<ul>
<li>“leetcode”<br>-&gt; 分割：       [“l”, “e”, “et”, “cod”, “e”]<br>-&gt; 替换：       [“l”, “1”, “2”,  “3”,   “e”]<br>-&gt; 连接：       “l123e”，得到 s1</li>
<li>“leetcode”<br>-&gt; 分割：       [“leet”, “code”]<br>-&gt; 替换：       [“4”,    “4”]<br>-&gt; 连接：       “44”，得到 s2</li>
</ul>
<p>输入：s1 = “112s”, s2 = “g841”<br>输出：true<br>解释：”gaaaaaaaaaaaas” 可以作为原字符串</p>
<ul>
<li>“gaaaaaaaaaaaas”<br>-&gt; 分割：       [“g”, “aaaaaaaaaaaa”, “s”]<br>-&gt; 替换：       [“1”, “12”,           “s”]<br>-&gt; 连接：       “112s”，得到 s1</li>
<li>“gaaaaaaaaaaaas”<br>-&gt; 分割：       [“g”, “aaaaaaaa”, “aaaa”, “s”]<br>-&gt; 替换：       [“g”, “8”,        “4”,    “1”]<br>-&gt; 连接         “g841”，得到 s2</li>
</ul>
<p>输入：s1 = “ab”, s2 = “a2”<br>输出：false<br>解释：不存在这样的原字符串</p>
<ul>
<li>编码为 s1 的字符串由两个字母组成</li>
<li>编码为 s2 的字符串由三个字母组成</li>
</ul>
<p>我直接上来一套bfs，检测将数字分割得到不同长度的串，再比较在相同位置的已给出的字母是否相同。写了很多过110/211就超时了。<br>贴下代码：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    bool flag &#x3D; false;
    vector&lt;vector&lt;int&gt;&gt; a;
    vector&lt;vector&lt;int&gt;&gt; b;

public:
    bool possiblyEquals(string s1, string s2) &#123;
        int k &#x3D;0,kk &#x3D; 0;
        string ss1 &#x3D; s1,ss2 &#x3D; s2;
        for(int i &#x3D; 0;i &lt; s1.size();i++) &#123;
            if(s1[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s1[i] &lt;&#x3D; &#39;z&#39;)&#123;
                ss1[i] &#x3D; &#39; &#39;;
                k++;
            &#125;
        
        &#125;
        for(int i &#x3D; 0;i &lt; s2.size();i++) &#123;
            if(s2[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s2[i] &lt;&#x3D; &#39;z&#39;)&#123;
                ss2[i] &#x3D; &#39; &#39;;
                kk++;
            &#125;
        &#125;
        vector&lt;string&gt; dt1 &#x3D; getString(ss1),dt2 &#x3D; getString(ss2);
        vector&lt;int&gt;kkk,mm;
        check(s1,dt1,0,0,0,kkk,a);
        check(s2,dt2,0,0,0,mm,b);
        for(int i &#x3D; 0;i &lt; a.size();i++) &#123;
            for(int j &#x3D; 0;j &lt; b.size();j++) &#123;
                if(a[i].back() &#x3D;&#x3D; b[j].back()) &#123;
                   flag |&#x3D; helper(a[i],b[j],s1,s2);
                &#125;
            &#125;
        &#125;
        return flag;
        
    &#125;
    bool helper(vector&lt;int&gt;&amp;aa,vector&lt;int&gt;&amp;bb,string&amp; s1,string&amp; s2) &#123;
        int xx &#x3D; 0,yy &#x3D; 0;
        for(int i &#x3D; 0,j &#x3D; 0;i&lt; s1.size()&amp;&amp;j&lt;s2.size();) &#123;
            while(i&lt; s1.size()&amp;&amp;j&lt;s2.size()&amp;&amp;!(s1[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;s1[i]&lt;&#x3D;&#39;z&#39;))&#123;
                i++;
            &#125;
            while(i&lt; s1.size()&amp;&amp;j&lt;s2.size()&amp;&amp;!(s2[j]&gt;&#x3D;&#39;a&#39;&amp;&amp;s2[j]&lt;&#x3D;&#39;z&#39;))&#123;
                j++;
            &#125;
            if(i&lt; s1.size()&amp;&amp;j&lt;s2.size()&amp;&amp;xx&lt;aa.size() - 1&amp;&amp;yy&lt;bb.size() - 1&amp;&amp;aa[xx]&#x3D;&#x3D;bb[yy]&amp;&amp;s1[i]!&#x3D;s2[j])&#123;
                return false;
            &#125;
            i++;
            j++;
            xx++;
            yy++;
        &#125;
        return true;
    &#125;
    void check(string &amp;s1,vector&lt;string&gt;&amp;dt1,int cur,int level,int j,vector&lt;int&gt; kk,vector&lt;vector&lt;int&gt;&gt;&amp;oo) &#123;
        if(level &#x3D;&#x3D; s1.size()) &#123;
            kk.push_back(cur);
            oo.push_back(kk);
            return ;
        &#125;
        if(s1[level]&gt;&#x3D;&#39;a&#39;&amp;&amp;s1[level]&lt;&#x3D;&#39;z&#39;) &#123;
            cur++;
            kk.push_back(cur);
            check(s1,dt1,cur,level+1,j,kk,oo);
        &#125;else&#123;
            vector&lt;int&gt; ll &#x3D; get(dt1[j]);
            for(int k &#x3D; 0;k&lt;ll.size();k++) &#123;
                check(s1,dt1,cur+ll[k],level+dt1[j].size(),j+1,kk,oo);
            &#125;
        &#125;
    &#125;
    vector&lt;int&gt;get(string&amp; s) &#123;
        if(s.size()&#x3D;&#x3D; 0)return&#123;&#125;;
        if(s.size() &#x3D;&#x3D; 1)return &#123;s[0]-&#39;0&#39;&#125;;
        if(s.size() &#x3D;&#x3D; 2)&#123;
            return &#123;s[0] - &#39;0&#39; +s[1] - &#39;0&#39;,(s[0] - &#39;0&#39;)*10+s[1]-&#39;0&#39;&#125;;
        &#125;
        int a &#x3D; s[0] - &#39;0&#39;+ s[1] - &#39;0&#39;+ s[2] - &#39;0&#39;;
        int b &#x3D; s[0] - &#39;0&#39;+ ((s[1] - &#39;0&#39;)*10+ s[2] - &#39;0&#39;);
        int c &#x3D; (s[0] - &#39;0&#39;)*10+ s[1] - &#39;0&#39;+ s[2] - &#39;0&#39;;
        int d &#x3D; (s[0] - &#39;0&#39;)*100+ (s[1] - &#39;0&#39;)*10+ s[2] - &#39;0&#39;;
        return &#123;a,b,c,d&#125;;
    &#125;
    vector&lt;string&gt; getString(string&amp; word) &#123;
        vector&lt;string&gt; res;
        string result;
        stringstream input(word);
        while (input &gt;&gt; result) &#123;
            res.push_back(result);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="264场周赛-2021-10-24"><a href="#264场周赛-2021-10-24" class="headerlink" title="264场周赛 2021-10-24"></a>264场周赛 2021-10-24</h2><h3 id="第一题-easy-8"><a href="#第一题-easy-8" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="句子中的有效单词"><a href="#句子中的有效单词" class="headerlink" title="句子中的有效单词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/">句子中的有效单词</a></h4><p>句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。<br>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：<br>仅由小写字母、连字符和/或标点（不含数字）。<br>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。<br>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。<br>写了最久的第一题。。。。直接模拟。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int countValidWords(string s) &#123;
        vector&lt;string&gt; temp &#x3D; getString(s);
        int res &#x3D; 0;
        for(int i &#x3D; 0;i &lt; temp.size();i++) &#123;
            if(temp[i][0] &#x3D;&#x3D;&#39;-&#39;||temp[i].back()&#x3D;&#x3D;&#39;-&#39;)continue;
            int f &#x3D; 0,m &#x3D; 0;
            for(int j &#x3D; 0;j &lt; temp[i].size();j++) &#123;
                if(temp[i][j] &#x3D;&#x3D; &#39;-&#39;) &#123;
                    if(!((temp[i][j - 1]&gt;&#x3D;&#39;a&#39;&amp;&amp;temp[i][j - 1]&lt;&#x3D;&#39;z&#39;&amp;&amp;temp[i][j+1]&lt;&#x3D;&#39;z&#39;&amp;&amp;temp[i][j+1]&gt;&#x3D;&#39;a&#39;))&#123;
                        f&#x3D;2;
                        continue;
                    &#125;
                    f++;
                &#125;
                if(temp[i][j] &#x3D;&#x3D; &#39;.&#39;||temp[i][j] &#x3D;&#x3D; &#39;,&#39;||temp[i][j] &#x3D;&#x3D; &#39;!&#39;)&#123;
                    if(j !&#x3D; temp[i].size() - 1)&#123;
                        m&#x3D;2;
                        continue;
                    &#125;
                    m++;
                &#125;
                if(temp[i][j]&gt;&#x3D;&#39;0&#39;&amp;&amp;temp[i][j]&lt;&#x3D;&#39;9&#39;) &#123;
                    f &#x3D; 2;
                    m&#x3D;2;
                &#125;
            &#125;
            if(f&lt;&#x3D;1&amp;&amp;m&lt;&#x3D;1)res++;
        &#125;
        return res;
    &#125;
    vector&lt;string&gt; getString(string word) &#123;
        vector&lt;string&gt; res;
        string result;
        stringstream input(word);
        while (input &gt;&gt; result) &#123;
            res.push_back(result);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-8"><a href="#第二题-Medium-8" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="下一个更大的数值平衡数"><a href="#下一个更大的数值平衡数" class="headerlink" title="下一个更大的数值平衡数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-numerically-balanced-number/">下一个更大的数值平衡数</a></h4><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。<br>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。<br>输入：n = 1000<br>输出：1333<br>解释：<br>1333 是一个数值平衡数，因为：</p>
<ul>
<li>数字 1 出现 1 次。</li>
<li>数字 3 出现 3 次。<br>这也是严格大于 1000 的最小数值平衡数。<br>注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。</li>
</ul>
<p>输入：n = 3000<br>输出：3133<br>解释：<br>3133 是一个数值平衡数，因为：</p>
<ul>
<li>数字 1 出现 1 次。</li>
<li>数字 3 出现 3 次。<br>这也是严格大于 3000 的最小数值平衡数。</li>
</ul>
<p>当时就是少了第一个大于666666返回1224444结果超时。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int nextBeautifulNumber(int n) &#123;
        if(n&gt;&#x3D;666666)return 1224444;
        for(long long i &#x3D; n+1;i&lt;&#x3D;100000000;i++) &#123;
            if(helper(i)) &#123;
                return i;
            &#125;
        &#125;
        return n;
    &#125;
    bool helper(long long &amp; i)&#123;
        long long ii &#x3D; i;
        unordered_map&lt;long long,long long&gt;map;
        while(ii&gt;0)&#123;
            int temp &#x3D; ii%10;
            if(temp &#x3D;&#x3D; 0)return false;
            ii &#x3D; ii&#x2F;10;
            map[temp]++;
        &#125;
        for(auto i&#x3D;map.begin();i!&#x3D;map.end();i++) &#123;
            if(i-&gt;first !&#x3D; i-&gt;second)return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>还有能直接打表。。。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int nextBeautifulNumber(int n) &#123;
        vector&lt;int&gt; num&#123;1,22,122,212,221,333,1333,3133,3313,3331,4444,14444,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,41444,44144,44414,44441,
                55555,122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,155555,212333,213233,213323,213332,221333,223133,223313,223331,224444,231233,231323,231332,
                232133,232313,232331,233123,233132,233213,233231,233312,233321,242444,244244,244424,244442,312233,312323,312332,313223,313232,313322,321233,321323,
                321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,332231,332312,332321,333122,333212,333221,422444,
                424244,424424,424442,442244,442424,442442,444224,444242,444422,515555,551555,555155,555515,555551,666666,1224444&#125;;
        int p &#x3D; num.size();
        for (int i &#x3D; 0; i &lt; p; ++i) &#123;
            if (n &lt; num[i]) &#123;
                return num[i];
            &#125;
        &#125;
        return 0;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-8"><a href="#第三题-Medium-8" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="统计最高分数的节点数目"><a href="#统计最高分数的节点数目" class="headerlink" title="统计最高分数的节点数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">统计最高分数的节点数目</a></h4><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。<br>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。<br>请你返回有最高得分节点的数目<br>我是直接建树再bfs就行了。树的值就是他左节点+右节点+1的节点个数，删除当前节点所得的值就是temp = left<em>right</em>(n - left - right - 1)(在外边的left和right最小为1，里边最小为0);看代码比较好理解。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    struct node&#123;
        node*left;
        node*right;
        int val;
        node(int vall):val(vall),left(nullptr),right(nullptr)&#123;&#125;;
    &#125;;
    int res &#x3D; 1;
    long long max_ &#x3D; 0;
    int n &#x3D; 0;
    vector&lt;node*&gt; tree;
public:
    int countHighestScoreNodes(vector&lt;int&gt;&amp; p) &#123;
        n &#x3D; p.size();
        for(int i &#x3D; 0;i &lt; p.size();i++) &#123;
            node* temp &#x3D;new node(1);
            tree.push_back(temp);
        &#125;
        for(int i &#x3D; 1;i &lt; p.size();i++)&#123;
            if(tree[p[i]]-&gt;left&#x3D;&#x3D;nullptr)&#123;
                tree[p[i]]-&gt;left &#x3D; tree[i];
            &#125;else&#123;
                tree[p[i]]-&gt;right &#x3D; tree[i];
            &#125;
        &#125;
        bfs(tree[0]);
        helper(tree[0]);
        return res;
    &#125;
    int bfs(node*&amp;root) &#123;
        if(root &#x3D;&#x3D; nullptr)return 0;
        root-&gt;val +&#x3D; bfs(root-&gt;left)+bfs(root-&gt;right);
        return root-&gt;val;
    &#125;

    void helper(node*root) &#123;
        if(root &#x3D;&#x3D; nullptr)return;
        long long left &#x3D; 1,right &#x3D; 1,nn &#x3D; 1;
        if(root-&gt;left!&#x3D;nullptr)left &#x3D; root-&gt;left-&gt;val,nn +&#x3D;left;
        if(root-&gt;right!&#x3D;nullptr)right &#x3D; root-&gt;right-&gt;val,nn +&#x3D;right;
        if(n - nn&gt;0)nn &#x3D; n - nn;
        else nn &#x3D; 1;
        long long temp &#x3D; left*right*nn;
        if(temp &#x3D;&#x3D; max_)res++;
        else if(temp&gt;max_)max_ &#x3D; temp,res &#x3D; 1;
        helper(root-&gt;left);
        helper(root-&gt;right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard-8"><a href="#第四题-Hard-8" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="并行课程"><a href="#并行课程" class="headerlink" title="并行课程"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/parallel-courses-iii/">并行课程</a></h4><p>给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。<br>请你根据以下规则算出完成所有课程所需要的 最少 月份数：<br>如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。<br>你可以 同时 上 任意门课程 。<br>请你返回完成所有课程所需要的 最少 月份数。<br>注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。<br>没写出后面写的。。挺简单的我吐了，多源bfs也能过，更新最大cost[i]就行了。数据大的话用拓扑排序，不然可能超时。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relations, vector&lt;int&gt;&amp; time) &#123;
        unordered_map&lt;int,vector&lt;int&gt;&gt; map;
        int res &#x3D; 0;
        vector&lt;int&gt; flag(n + 1);
        vector&lt;int&gt; cost(n + 1);
        for(int i &#x3D; 0;i &lt; relations.size();i++) &#123;
            map[relations[i][0]].push_back(relations[i][1]);
            flag[relations[i][1]]++;
        &#125;
        queue&lt;int&gt; q;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123;
            if(flag[i] &#x3D;&#x3D; 0)&#123;
                q.push(i);
            &#125;
            cost[i] &#x3D; time[i - 1];
        &#125;
        while(!q.empty()) &#123;
            int top &#x3D; q.front();
            q.pop();
            for(const auto &amp;i:map[top]) &#123;
                int c &#x3D; cost[top] + time[i - 1];
                if(c &gt; cost[i]) &#123;
                    cost[i] &#x3D; c;
                    q.push(i);
                &#125;
            &#125;
        &#125;
        for(auto i :cost) &#123;
            res &#x3D; max(res,i);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="263场周赛-2021-10-17"><a href="#263场周赛-2021-10-17" class="headerlink" title="263场周赛 2021-10-17"></a>263场周赛 2021-10-17</h2><h3 id="第一题-easy-9"><a href="#第一题-easy-9" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="检查句子中的数字是否递增"><a href="#检查句子中的数字是否递增" class="headerlink" title="检查句子中的数字是否递增"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-if-numbers-are-ascending-in-a-sentence/">检查句子中的数字是否递增</a></h4><p>句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。<br>示例，”a puppy has 2 eyes 4 legs” 是一个由 7 个 token 组成的句子：”2” 和 “4” 是数字，其他像 “puppy” 这样的 tokens 属于单词。<br>给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。<br>如果满足题目要求，返回 true ，否则，返回 false 。</p>
<p>输入：s = “1 box has 3 blue 4 red 6 green and 12 yellow marbles”<br>输出：true<br>解释：句子中的数字是：1, 3, 4, 6, 12 。<br>这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。</p>
<p>输入：s = “sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s”<br>输出：false<br>解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。</p>
<p>蠢比写法。。。。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool areNumbersAscending(string s) &#123;
        vector&lt;string&gt; str &#x3D; getString(s);
        int n &#x3D; str.size();
        long long num &#x3D; 0;
        for(int i &#x3D; 0;i &lt; str[0].size();i++) &#123;
            num &#x3D; num*10+str[0][i] - &#39;0&#39;;
        &#125;
        for(int i &#x3D; 1;i &lt; n;i++) &#123;
            long long temp &#x3D; 0;
            for(int j &#x3D; 0;j &lt; str[i].size();j++) &#123;
                temp &#x3D;temp*10+str[i][j]-&#39;0&#39;;
            &#125;
            if(num &gt;&#x3D; temp)return false;
            num &#x3D; temp;
        &#125;
        return true;
    &#125;
    vector&lt;string&gt; getString(string word) &#123;
        vector&lt;string&gt; res;
        string result;
        stringstream input(word);
        while (input &gt;&gt; result) &#123;
            if(result[0] &gt;&#x3D;&#39;0&#39;&amp;&amp;result[0]&lt;&#x3D;&#39;9&#39;)
                res.push_back(result);
            else continue;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-9"><a href="#第二题-Medium-9" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="简易银行系统"><a href="#简易银行系统" class="headerlink" title="简易银行系统"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/simple-bank-system/">简易银行系统</a></h4><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 n 个账户，编号从 1 到 n 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 balance 中，其中第 (i + 1) 个账户的初始余额是 balance[i] 。<br>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：<br>指定的账户数量在 1 和 n 之间，且<br>取款或者转账需要的钱的总数 小于或者等于 账户余额。<br>实现 Bank 类：<br>Bank(long[] balance) 使用下标从 0 开始的整数数组 balance 初始化该对象。<br>boolean transfer(int account1, int account2, long money) 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。<br>boolean deposit(int account, long money) 向编号为 account 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 false 。<br>boolean withdraw(int account, long money) 从编号为 account 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。<br>送分题，但是因为long long 和非法输入wa了两次我去。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Bank &#123;
    int n;
    unordered_map&lt;int,long long&gt; map;
public:
    Bank(vector&lt;long long&gt;&amp; b) &#123;
        n &#x3D; b.size();
        for(int i &#x3D; 0;i &lt; b.size();i++) &#123;
            map[i+1] &#x3D; b[i];
        &#125;
    &#125;

    bool transfer(int a1, int a2, long long m) &#123;
        if(a1&lt;1||a1&gt;n||a2&lt;1||a2&gt;n)return false;
        if(map[a1] &lt; m)return false;
        map[a1] -&#x3D; m;
        map[a2] +&#x3D; m;
        return true;

    &#125;

    bool deposit(int a, long long m) &#123;
        if(a&lt;1||a&gt;n)return false;
        map[a] +&#x3D;m;
        return true;

    &#125;

    bool withdraw(int a, long long m) &#123;
        if(a&lt;1||a&gt;n)return false;
        if(map[a] &lt; m)return false;
        map[a]-&#x3D;m;
        return true;

    &#125;
&#125;;

&#x2F;**
 * Your Bank object will be instantiated and called as such:
 * Bank* obj &#x3D; new Bank(balance);
 * bool param_1 &#x3D; obj-&gt;transfer(account1,account2,money);
 * bool param_2 &#x3D; obj-&gt;deposit(account,money);
 * bool param_3 &#x3D; obj-&gt;withdraw(account,money);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-9"><a href="#第三题-Medium-9" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="统计按位或能得到的最大值的子集数目"><a href="#统计按位或能得到的最大值的子集数目" class="headerlink" title="统计按位或能得到的最大值的子集数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">统计按位或能得到的最大值的子集数目</a></h4><p>给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。<br>如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。<br>对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR … OR a[a.length - 1]（下标从 0 开始）。<br>输入：nums = [3,2,1,5]<br>输出：6<br>解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</p>
<ul>
<li>[3,5]</li>
<li>[3,1,5]</li>
<li>[3,2,5]</li>
<li>[3,2,1,5]</li>
<li>[2,5]</li>
<li>[2,1,5]<br>提示：<br>1 &lt;= nums.length &lt;= 16<br>1 &lt;= nums[i] &lt;= 10^5<br>直接bfs，但是有个细节，跳过的从i开始不是从当前level+1开始bfs<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    int res &#x3D; 0;
    int tar &#x3D; 0;
    vector&lt;int&gt; temp;
public:
    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            tar &#x3D; tar|nums[i];
        &#125;
        temp &#x3D; nums;
        bfs(0,0);
        return res;
    &#125;
    void bfs(int cur,int level) &#123;
        if(cur &#x3D;&#x3D; tar)res++;
        for(int i &#x3D; level;i &lt; temp.size();i++) &#123;
            int kk &#x3D; cur|temp[i];
            bfs(kk,i + 1);

        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第四题-Hard-9"><a href="#第四题-Hard-9" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="到达目的地的第二短时间"><a href="#到达目的地的第二短时间" class="headerlink" title="到达目的地的第二短时间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/">到达目的地的第二短时间</a></h4>城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。<br>每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。<br>第二小的值 是 严格大于 最小值的所有值中最小的值。<br>例如，[2, 3, 4] 中第二小的值是 3 ，而 [2, 2, 4] 中第二小的值是 4 。<br>给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。<br>注意：<br>你可以 任意次 穿过任意顶点，包括 1 和 n 。<br>你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。</li>
</ul>
<p>两次bfs,第一次找出最短路径经过k个节点，第二次检查是否有能在k + 1到达，如能k + 1个节点就是第二短时间，否则必是 K + 2节点的时间，时间关系没A出来，最后放弃了，<br>贴一下没过的代码。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    unordered_map&lt;int,vector&lt;int&gt; &gt; map;
public:
    int secondMinimum(int n, vector&lt;vector&lt;int&gt;&gt;&amp; e, int t, int c) &#123;
        int m &#x3D; e.size();
        for(int i &#x3D; 0;i &lt; m;i++) &#123;
            map[e[i][0]].push_back(e[i][1]);
            map[e[i][1]].push_back(e[i][0]);
        &#125;
        queue&lt;int&gt; q;
        q.push(1);
        int k &#x3D; 0;
        vector&lt;int&gt; visit(n + 1);
        visit[1] &#x3D; 1;
        int flag &#x3D; 0;
        while(!q.empty()) &#123;
            int size &#x3D; q.size();
            while(size--) &#123;
                auto i &#x3D; q.front();
                q.pop();
                for(const auto &amp;x:map[i]) &#123;
                    if(visit[x]&#x3D;&#x3D;0) &#123;
                        q.push(x);
                        visit[x] &#x3D; 1;
                    &#125;
                &#125;
            &#125;
            k++;
        &#125;
        queue&lt;int&gt; q1;
        q1.push(1);
        int kk &#x3D; k + 1;
        int flag1 &#x3D; 0,flag2 &#x3D; 0;
        while(!q1.empty()&amp;&amp;kk&gt;0) &#123;
            int size &#x3D; q1.size();
            while(size--) &#123;
                auto i &#x3D; q1.front();
                q1.pop();
                if(i &#x3D;&#x3D; n)&#123;
                    if(kk &#x3D;&#x3D; 2)flag2++;
                    else flag1++;
                &#125;
                for(const auto &amp;x:map[i]) &#123;
                    q1.push(x);
                &#125;
            &#125;
            kk--;
        &#125;
        int res &#x3D; 0;
        int wait  &#x3D; 0;
        if(c%t &#x3D;&#x3D; 0)&#123;
            wait &#x3D; c;
        &#125;
        else
        wait&#x3D; c - (t-c%t);
        int times &#x3D; c&#x2F;t;
        if(c%t!&#x3D;0)times++;
        if(flag2 &gt; 0)&#123;
            res &#x3D; (k)*t+k&#x2F;times*wait;
        &#125;else&#123;
            res &#x3D; (k + 1)*t+k&#x2F;times*wait;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="63场双周赛-2021-10-16"><a href="#63场双周赛-2021-10-16" class="headerlink" title="63场双周赛 2021-10-16"></a>63场双周赛 2021-10-16</h2><h3 id="第一题-easy-10"><a href="#第一题-easy-10" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="使每位学生都有座位的最小移动次数"><a href="#使每位学生都有座位的最小移动次数" class="headerlink" title="使每位学生都有座位的最小移动次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-moves-to-seat-everyone/">使每位学生都有座位的最小移动次数</a></h4><p>一个房间里有 n 个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 seats[i] 是第 i 个座位的位置。同时给你一个长度为 n 的数组 students ，其中 students[j] 是第 j 位学生的位置。</p>
<p>你可以执行以下操作任意次：</p>
<p>增加或者减少第 i 位学生的位置，每次变化量为 1 （也就是将第 i 位学生从位置 x 移动到 x + 1 或者 x - 1）<br>请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。</p>
<p>请注意，初始时有可能有多个座位或者多位学生在 同一 位置。</p>
<p>排序贪心<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minMovesToSeat(vector&lt;int&gt;&amp; seats, vector&lt;int&gt;&amp; students) &#123;
        int n &#x3D; seats.size();
        sort(seats.begin(),seats.end());
        sort(students.begin(),students.end());
        int sum &#x3D; 0;
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            sum +&#x3D;abs(seats[i] - students[i]);
        &#125;
        return sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-10"><a href="#第二题-Medium-10" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="如果相邻两个颜色相同则删除当前颜色"><a href="#如果相邻两个颜色相同则删除当前颜色" class="headerlink" title="如果相邻两个颜色相同则删除当前颜色"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/">如果相邻两个颜色相同则删除当前颜色</a></h4><p>总共有 n 个颜色片段排成一列，每个颜色片段要么是 ‘A’ 要么是 ‘B’ 。给你一个长度为 n 的字符串 colors ，其中 colors[i] 表示第 i 个颜色片段的颜色。</p>
<p>Alice 和 Bob 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。Alice 先手 。</p>
<p>如果一个颜色片段为 ‘A’ 且 相邻两个颜色 都是颜色 ‘A’ ，那么 Alice 可以删除该颜色片段。Alice 不可以 删除任何颜色 ‘B’ 片段。<br>如果一个颜色片段为 ‘B’ 且 相邻两个颜色 都是颜色 ‘B’ ，那么 Bob 可以删除该颜色片段。Bob 不可以 删除任何颜色 ‘A’ 片段。<br>Alice 和 Bob 不能 从字符串两端删除颜色片段。<br>如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。<br>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。</p>
<p>Alice 不可以 删除任何颜色 ‘B’ 片段。Bob 不可以 删除任何颜色 ‘A’ 片段。直接计数就行<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool winnerOfGame(string c) &#123;
        int n &#x3D; c.size();
        int a &#x3D; 0,b &#x3D; 0;
        for(int i &#x3D; 1;i &lt; n - 1;i++) &#123;
            if(c[i - 1] &#x3D;&#x3D; &#39;A&#39;&amp;&amp;c[i] &#x3D;&#x3D; &#39;A&#39;&amp;&amp;c[i+1] &#x3D;&#x3D; &#39;A&#39;)&#123;
                a++;
            &#125;
            if(c[i - 1] &#x3D;&#x3D; &#39;B&#39;&amp;&amp;c[i] &#x3D;&#x3D; &#39;B&#39;&amp;&amp;c[i+1] &#x3D;&#x3D; &#39;B&#39;)&#123;
                b++;
            &#125;
        &#125;
        return a&gt;b;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-10"><a href="#第三题-Medium-10" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="网络空闲时刻"><a href="#网络空闲时刻" class="headerlink" title="网络空闲时刻"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/">网络空闲时刻</a></h4><p>给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。</p>
<p>题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>
<p>编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。</p>
<p>在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>
<p>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。<br>否则，该数据服务器 不会重发 信息。<br>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</p>
<p>请返回计算机网络变为 空闲 状态的 最早秒数 。<br>算出每个数据服务器发了多少次*P[i]+来回传的耗时 -(来回耗时%p[i]),取最大就行。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int networkBecomesIdle(vector&lt;vector&lt;int&gt;&gt;&amp; e, vector&lt;int&gt;&amp; p) &#123;
        unordered_map&lt;int,vector&lt;int&gt; &gt; map;
        int n &#x3D; e.size(),m &#x3D; p.size();
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            map[e[i][0]].push_back(e[i][1]);
            map[e[i][1]].push_back(e[i][0]);
        &#125;
        vector&lt;int&gt; visist(m);
        vector&lt;int&gt; cost(m,INT_MAX);
        cost[0] &#x3D; 0;
        queue&lt;int&gt; q;
        q.push(0);
        while(!q.empty()) &#123;
            auto ii &#x3D; q.front();
            q.pop();
            for(auto &amp; i:map[ii]) &#123;
                if(1+ cost[ii] &lt; cost[i]) &#123;
                    cost[i] &#x3D;1 + cost[ii];
                    q.push(i);
                &#125;
            &#125;
        &#125;
        int res &#x3D; 0;
        for(int i &#x3D; 0;i &lt; m;i++) &#123;
            int temp &#x3D; 0;
            if(cost[i] * 2 &gt; p[i])&#123;
                int time &#x3D;2*cost[i]&#x2F;p[i];
                if(2*cost[i]%p[i] &#x3D;&#x3D; 0)
                    temp &#x3D; time*p[i] +2*cost[i]  - p[i];
                else temp &#x3D; (time + 1) *p[i]+2*cost[i] +  - p[i];
            &#125;else &#123;
                temp &#x3D; cost[i]*2 ;
            &#125;
            res &#x3D; max(res,temp);
        &#125;
        return res + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard-10"><a href="#第四题-Hard-10" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="两个有序数的第k小乘积"><a href="#两个有序数的第k小乘积" class="headerlink" title="两个有序数的第k小乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/">两个有序数的第k小乘积</a></h4><p>给你两个 从小到大排好序 且下标从 0 开始的整数数组 nums1 和 nums2 以及一个整数 k ，请你返回第 k （从 1 开始编号）小的 nums1[i] * nums2[j] 的乘积，其中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length 。</p>
<p>不会。。。数据有负数有正数。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">impl Solution &#123;
    pub fn kth_smallest_product(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;, k: i64) -&gt; i64 &#123;

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
<h2 id="62场双周赛-2021-10-02"><a href="#62场双周赛-2021-10-02" class="headerlink" title="62场双周赛 2021-10-02"></a>62场双周赛 2021-10-02</h2><h3 id="第一题-easy-11"><a href="#第一题-easy-11" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="将一维数组变成二维数组"><a href="#将一维数组变成二维数组" class="headerlink" title="将一维数组变成二维数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/">将一维数组变成二维数组</a></h4><p>直接模拟<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; construct2DArray(vector&lt;int&gt;&amp; o, int m, int k) &#123;
        int n &#x3D; o.size();
        if(n%m!&#x3D;0)return &#123;&#125;;
        if(n!&#x3D;k*m)return &#123;&#125;;
        vector&lt;vector&lt;int&gt;&gt; res(m,vector&lt;int&gt;(k));
        for(int i &#x3D;0;i &lt; n;i++) &#123;
            res[i&#x2F;k][i - (i&#x2F;k)*k] &#x3D; o[i];
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-11"><a href="#第二题-Medium-11" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="连接后等于目标字符串的字符串对"><a href="#连接后等于目标字符串的字符串对" class="headerlink" title="连接后等于目标字符串的字符串对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/">连接后等于目标字符串的字符串对</a></h4><p>这题是只要求字符串对，当时以为是若干个串起来的字符等于目标串的个数，后来发现是求两个字符串合起来的，直接暴力就好；<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">class Solution <span class="token punctuation">&#123;</span>
public:
    int numOfPairs<span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>&amp;</span> nums, string target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        int n <span class="token operator">=</span> nums.size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        int res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        for<span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            for<span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>j++<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                if<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> + nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token operator">&amp;&amp;</span>i<span class="token operator">!=</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    res++<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token builtin class-name">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-11"><a href="#第三题-Medium-11" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="考试的最大困扰度"><a href="#考试的最大困扰度" class="headerlink" title="考试的最大困扰度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">考试的最大困扰度</a></h4><p>这题一看就是滑动窗口，先用pair记录前缀和，然后滑动窗口取min(F,T)的个数就好。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxConsecutiveAnswers(string a, int k) &#123;
        int n &#x3D; a.size();
        vector&lt;pair&lt;int,int&gt;&gt; temp(n+1);
        for(int i &#x3D; 0;i &lt; n;i++) &#123;
            if(a[i]&#x3D;&#x3D;&#39;F&#39;)&#123;
                temp[i+1]&#x3D;&#123;temp[i].first + 1,temp[i].second&#125;;
            &#125;else&#123;
                temp[i+1]&#x3D;&#123;temp[i].first,temp[i].second + 1&#125;;
            &#125;
        &#125;
        int res &#x3D; 0;
        for(int i &#x3D; 0,j &#x3D; 0;i &lt;&#x3D; n&amp;&amp;j&lt;&#x3D;n;j++) &#123;
            while(min(temp[j].first - temp[i].first,temp[j].second-temp[i].second) &gt; k) &#123;
                i++;
            &#125;
            res &#x3D; max(res,j - i);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard-11"><a href="#第四题-Hard-11" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="分割数组的最多方案数"><a href="#分割数组的最多方案数" class="headerlink" title="分割数组的最多方案数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/">分割数组的最多方案数</a></h4><p>双哈希+前缀和<br>1.这题先求不替换的时候的组数；<br>2.先用一个哈希表1记录全部前缀和。<br>3.遍历数组，将索引i之前的前缀和加入哈希表2，并将哈希表1在索引i之前的前缀和删去，询将s[i]变成K之后哈希表1前缀和是(SUM-(k-s[i]))/2 - (k-s[i]) 的个数与哈希表2中(SUM-(k-s[i]))/2的个数。<br>注意要是在s[n]分割时要减一，或者数组不整除的时候不能分割。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int waysToPartition(vector&lt;int&gt;&amp; nums, int k) &#123;
        int n &#x3D; nums.size();
        long long sum &#x3D; nums[0];
        int res &#x3D; 0;
        vector&lt;long long&gt; temp(n);
        temp[0] &#x3D; nums[0];
        for(int i &#x3D; 1;i &lt; n;i++)&#123;
            temp[i]&#x3D;temp[i - 1]+nums[i];
            sum+&#x3D;nums[i];
        &#125;
        for(int i &#x3D; 0;i &lt; n - 1;i++) &#123;
            if(temp.back() - temp[i] &#x3D;&#x3D; temp[i])&#123;
                res++;
            &#125;
        &#125;
        unordered_map&lt;int,int&gt; map;
        unordered_map&lt;int,int&gt; map2;
        for(int i  &#x3D; 0;i &lt; n;i++) &#123;
            map[temp[i]]++;
        &#125;
        &#x2F;&#x2F; cout&lt;&lt;map[temp[19]]&lt;&lt;endl;
        for(int i &#x3D; 0;i &lt; n ;i++) &#123;
            int aa &#x3D; k - nums[i];
            if((sum+aa)%2!&#x3D;0)&#123;
                map[temp[i]]--;
                map2[temp[i]]++;
                continue;
            &#125;
            int tar &#x3D; (sum + aa)&#x2F;2;
            if(temp.back()&#x3D;&#x3D;tar-aa)&#123;
                res &#x3D; max(res,map[tar-aa]+map2[tar] - 1);
            &#125;
            else&#123;
                res &#x3D; max(res,map[tar-aa]+map2[tar]);

            &#125;
            &#x2F;&#x2F; cout&lt;&lt;map[tar-aa]&lt;&lt;&quot; &quot;&lt;&lt;map2[tar]&lt;&lt;endl;
            map[temp[i]]--;
            map2[temp[i]]++;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>END!</p>
<h2 id="252场周赛-2021-08-02"><a href="#252场周赛-2021-08-02" class="headerlink" title="252场周赛 2021-08-02"></a>252场周赛 2021-08-02</h2><h3 id="第一题-easy-12"><a href="#第一题-easy-12" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="三除数"><a href="#三除数" class="headerlink" title="三除数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/three-divisors/">三除数</a></h4><p>给你一个整数n，如果n恰好有三个正除数，返回true,</p>
<p>没什么好说的，暴力查找也能过<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isThree(int n) &#123;
        int k&#x3D;1;
        unordered_set&lt;int&gt; set;
        while(k&lt;&#x3D;n)&#123;
            int temp&#x3D;0;
            n%k&#x3D;&#x3D;0?temp&#x3D;n&#x2F;k:temp&#x3D;-1;
            if(temp!&#x3D;-1)&#123;
                set.insert(temp);
            &#125;
            if(set.size()&gt;3)return false;
            k++;
        &#125;
        return set.size()&#x3D;&#x3D;3;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>优化一下之后<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    public:
    bool isThree(int n) &#123;
        int i&#x3D;2;
        for(;i*i&lt;n;i++)&#123;
            if(n%i&#x3D;&#x3D;0)return false;
        &#125;
        return i*i&#x3D;&#x3D;n;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-12"><a href="#第二题-Medium-12" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="你可以工作的最大周数"><a href="#你可以工作的最大周数" class="headerlink" title="你可以工作的最大周数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/">你可以工作的最大周数</a></h4><p>给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。<br>你可以按下面两个规则参与项目中的工作：<br>    1.每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。<br>    2.在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。<br>    一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。<br>返回在不违反上面规则的情况下你 最多 能工作多少周。<br> .  其实就是不能连续两周做同一个任务，在leetcode上做过一个相似的题<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distant-barcodes/">距离相等的条形码</a>，同样是隔位插入的思想，只要剩下两种以上的工作，总能隔位插入（选取剩余最多和第二多的工作进行隔位插入），此时最大周数就是总任务数sum，当最多的任务nums[i]&gt;sum-nums[i]时，最后就会剩下一种任务，无法进行隔位插入，完成最大周数就是2*(sum-nums[i])+1。<br>基于以上的想法，可以写出:<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long numberOfWeeks(vector&lt;int&gt;&amp; milestones) &#123;
        sort(milestones.begin(),milestones.end());
        long temp&#x3D;milestones.back();
        int my_temp&#x3D;temp;
        long long sum&#x3D;temp;
        for(int i&#x3D;0;i&lt;milestones.size()-1;i++)&#123;
            sum&#x3D;sum+milestones[i];
            temp&#x3D;temp-milestones[i];
        &#125;
        return temp&gt;0?2*(sum-my_temp)+1:sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当初没想那么多，直接排序，其实不用排序就行了<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long numberOfWeeks(vector&lt;int&gt;&amp; milestones) &#123;
        int my_max&#x3D;0;
        long long sum&#x3D;0;
        for(int i&#x3D;0;i&lt;milestones.size();i++)&#123;
            sum&#x3D;sum+milestones[i];
            my_max&#x3D;max(my_max,milestones[i]);
        &#125;
        return my_max &gt; sum -my_max ? (sum - my_max) * 2 + 1 : sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-12"><a href="#第三题-Medium-12" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="收集足够苹果的最小花园周长"><a href="#收集足够苹果的最小花园周长" class="headerlink" title="收集足够苹果的最小花园周长"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples/">收集足够苹果的最小花园周长</a></h4><p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。<br>你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。<br>给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。</p>
<p>|x| 的值定义为：<br>如果 x &gt;= 0 ，那么值为 x<br>如果 x &lt; 0 ，那么值为 -x</p>
<p>当时以为只要原地点在花园就行了，但其实他的花园总是正方形的。这样题目就简单很多。<br><img src="/medias/252.3.jpg" alt="你的花园~"><br>其实就是找规律，每次变大花园增加的苹果都与顶点有关(最外边一圈），我这里定义point为右上角的坐标x，将花园分成4份，只分析第一步部分。<br><img src="/medias/252.3.1.jpg" alt=""><br>得出有以下特点：<br>1.平行与x轴为x个x苹果(纵坐标)，平行于y轴为x-1个x苹果，增加个数为2x^2-x,(x,x)不计入其中。<br>2.剩下递增部分 平行于y轴为从1递增到x，平行于x轴为从1等增到x,注有累加公式2(x+1)x/2=x^2+x<br>所以你的花园的递推公式就是temp+=12point^2。<br>分析出来之后就可以写代码了。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long minimumPerimeter(long long neededApples) &#123;
        long long temp&#x3D;0;
        long long point&#x3D;0;
        while(temp&lt;neededApples)&#123;
            point++;
            # temp&#x3D;temp+4*(point*(2*point)+point*point);
            temp+&#x3D;12*point*point;
        &#125;
            return 8*point;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第四题-Hard-12"><a href="#第四题-Hard-12" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="统计特殊子序列的数目"><a href="#统计特殊子序列的数目" class="headerlink" title="统计特殊子序列的数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-number-of-special-subsequences/">统计特殊子序列的数目</a></h4><p>特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。</p>
<p>比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。<br>相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。<br>给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。</p>
<p>一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。<br>思路动态规划：<br>题目只有三种数字0,1,2。我们改变一下思路：分别求0、1、2序列的个数，并且我们规定有效的序列1在序列0之后，有效的序列2在序列1之后，这样序列2个数即为所求。<br>于是有状态转移方程：<br>对于nums[i]==0<br>    则将序列0个数更新为dp[i][0]=2dp[i-1][0]+1;//将上一个0的索引替换成当前的+直接把0加入序列0后面。<br>对于nums[i]==1<br>    则将序列1个数更新为dp[i][1]=2dp[i-1][1]+dp[i-1][0]//将上一个1的索引替换成当期+自己当做独立的序列加在序列0后面<br>对于nums[i]==2<br>    则将序列2个数更新为dp[i][2]=2dp[i-1][2]+dp[i-1][1]//将上一个2的索引替换成当前+自己当做独立的序列加在序列1后面<br>有了思路就可以写代码了，因为每次只更新一个状态，另外两个状态不变，故只需要定义三个变量存储f0=dp[i-1][0],f1=dp[i-1][1],f2=dp[i-1][2];<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
     #define mod &#x3D; 1000000007
public:
    int countSpecialSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        int f0 &#x3D; 0, f1 &#x3D; 0, f2 &#x3D; 0;
        for (int num: nums) &#123;
            if (num &#x3D;&#x3D; 0) &#123;
                f0 &#x3D; (f0 * 2 + 1) % mod;
            &#125;
            else if (num &#x3D;&#x3D; 1) &#123;
                f1 &#x3D; (f1 * 2 % mod + f0) % mod;
            &#125;
            else &#123;
                f2 &#x3D; (f2 * 2 % mod + f1) % mod;
            &#125;
        &#125;
        return f2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end！</p>
<h2 id="57场双周赛-2021-07-24"><a href="#57场双周赛-2021-07-24" class="headerlink" title="57场双周赛 2021-07-24"></a>57场双周赛 2021-07-24</h2><h3 id="第一题-easy-13"><a href="#第一题-easy-13" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="检查是否所有字符出现次数相同"><a href="#检查是否所有字符出现次数相同" class="headerlink" title="检查是否所有字符出现次数相同"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-if-all-characters-have-equal-number-of-occurrences/">检查是否所有字符出现次数相同</a></h4><p>给你一个字符串s，如果s是一个好字符串，请返回true，否则请返回false。如果s中出现过的所有字符的出现次数相同，那么我们称字符串s是好字符串。s只包含小写英文字符。<br>没什么好说的，直接哈希一遍<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool areOccurrencesEqual(string s) &#123;
        unordered_map&lt;char,int&gt; map;
        for(auto x:s)&#123;
            map[x]++;
        &#125;
        int temp&#x3D;map.begin()-&gt;second;
        for(auto x&#x3D;map.begin();x!&#x3D;map.end();x++)&#123;
            if(temp!&#x3D;x-&gt;second)return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当然你也可以不用哈希，定义一个26大小的vector，比较的时候把非零的跳过就行,这样会比哈希表快一些<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool areOccurrencesEqual(string s) &#123;
        vector&lt;int&gt; res(26);
        for(auto x:s)&#123;
            res[x-&#39;a&#39;]++;
        &#125;
        int num&#x3D;0;
        for(auto x:res)&#123;
            if(x)&#123;
                if(!num)num&#x3D;x;
                else if(x!&#x3D;num)return false;
            num&#x3D;x;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第二题-Medium-13"><a href="#第二题-Medium-13" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="最小未被占据椅子的编号"><a href="#最小未被占据椅子的编号" class="headerlink" title="最小未被占据椅子的编号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-number-of-the-smallest-unoccupied-chair/">最小未被占据椅子的编号</a></h4><p>有 n 个朋友在举办一个派对，这些朋友从 0 到 n - 1 编号。派对里有 无数 张椅子，编号为 0 到 infinity 。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。<br>比方说，当一个朋友到达时，如果椅子 0 ，1 和 5 被占据了，那么他会占据 2 号椅子。<br>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。<br>给你一个下标从 0 开始的二维整数数组 times ，其中 times[i] = [arrivali, leavingi] 表示第i个朋友到达和离开的时刻，同时给你一个整数targetFriend。所有到达时间互不相同 。<br>请你返回编号为targetFriend的朋友占据的椅子编号。<br>注意条件就行。题目要求优先占据编号小的椅子。故可以维护一个优先队列，用来存放空着的椅子编号。这题很像leetcode上的<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">吃苹果的最大数目</a>但是要注意的是，吃苹果的这里是每天增加天数的，但是这里朋友离去并不是每一分钟都会有，也不是每分钟都会有朋友过来。所以需要额外维护一个优先队列，用来存储朋友离去的时间。有了思路之后可以写出代码：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
     #define P vector&lt;int&gt;
    int smallestChair(vector&lt;vector&lt;int&gt;&gt;&amp; times, int targetFriend) &#123;
        vector&lt;int&gt; temp&#x3D;times[targetFriend];
        sort(times.begin(),times.end(),[](auto x,auto y)&#123;return x[0]&lt;y[0];&#125;);   &#x2F;&#x2F;先排序，朋友相继过来
        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; save;     #存储朋友离去的时间
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; my_save;    #储存最空出来的最小位置
        for(int i&#x3D;0;i&lt;times.size();i++)&#123;#初始化凳子
            my_save.push(i);
        &#125;
        int j&#x3D;0;
        for(int i&#x3D;0;i&lt;100000;i++)&#123;#初始化时间
            while(!save.empty()&amp;&amp;save.top()[0]&#x3D;&#x3D;i)&#123;#如果有朋友离去，将凳子入队，朋友出队
                my_save.push(save.top()[2]);
                save.pop();
            &#125;

            if(j&lt;times.size()&amp;&amp;i&#x3D;&#x3D;times[j][0])&#123;#如果还有朋友没到，朋友到了分配凳子，并入队
                if(times[j]&#x3D;&#x3D;temp)return my_save.top();#分配序号最小的凳子
                save.push(&#123;times[j][1],times[j][0],my_save.top()&#125;);#离去的时间、进来的时间、占据的凳子入队
                my_save.pop();#凳子分配完成，出队
                j++;#朋友减一
            &#125;
        &#125;
      return 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="第三题-Medium-13"><a href="#第三题-Medium-13" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="描述绘画的结果"><a href="#描述绘画的结果" class="headerlink" title="描述绘画的结果"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/describe-the-painting/">描述绘画的结果</a></h4><h3 id="第四题-Hard-13"><a href="#第四题-Hard-13" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="队列中可以看到的人数"><a href="#队列中可以看到的人数" class="headerlink" title="队列中可以看到的人数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-visible-people-in-a-queue/">队列中可以看到的人数</a></h4><p>有 n 个人排成一个队列，从左到右 编号为 0 到 n - 1 。给你以一个整数数组 heights ，每个整数 互不相同，heights[i] 表示第 i 个人的高度。</p>
<p>一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 i &lt; j 且 min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], …, heights[j-1]) 。<br>请你返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人在他右侧队列中能 看到 的 人数 。<br><img src="/medias/57.1.jpg" alt=""><br>很简单的单调栈，其实是送分题，第一次竞赛做出Hard~<br>思路：其实题目讲的有点不清，就是两个人相邻(指右边相邻)，是肯定能看到的，向左遍历，维护一个递减栈，每次将比nums[i]小的弹出来，弹出来的个数就是向右看到的人的个数<br>因为向左遍历的时候，弹出的都是比自己小的，能看到的条件约束，比栈顶小的，nums[i]是看不到的，应该将在nums[i-1]进栈(上一次)将其弹出，而比栈顶大的，nums[i]才有机会看到。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; canSeePersonsCount(vector&lt;int&gt;&amp; heights) &#123;
        stack&lt;int&gt; right;
        vector&lt;int&gt; my_r(heights.size(),1);#这里初始化都能看到一个人，即右边相邻的人
        my_r[heights.size()-1]&#x3D;0;#最后一个人看不到人
        right.push(heights.size()-1);#入栈
        for(int i&#x3D;heights.size()-2;i&gt;&#x3D;0;i--)&#123;
            int temp&#x3D;heights[i];
            while(!right.empty())&#123;
                int top&#x3D;heights[right.top()];
                if(top&lt;&#x3D;temp)&#123;#比自己小就出栈，说明能看到他
                    right.pop();
                    my_r[i]++;#记录弹出多少
                    if(right.empty())&#123;
                        my_r[i]--;#如果将栈弹空说明全都能看见，但是初始化默认能看到一个人，所以要去掉。
                        right.push(i);
                        break;
                    &#125;
                &#125;else&#123;
                    right.push(i);
                    break;
                &#125;
            &#125;
        &#125;
        return my_r;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当时自己写的时候，代码逻辑可读性不是很清晰，贴一个清晰的~，不同的是他的是初始化成0，如果能弹空弹出个数就是能看到的个数，不能弹空弹则需要加一。<br>本质上是一样的，我写的是默认能弹空，如果弹空就会多加一次，可能思路没这么清晰。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; canSeePersonsCount(vector&lt;int&gt;&amp; heights) &#123;
        int n &#x3D; heights.size();
        vector&lt;int&gt; ret(n);
        stack&lt;int&gt; s;
        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i) &#123;
            while (!s.empty() &amp;&amp; heights[i] &gt;&#x3D; s.top()) &#123;
                s.pop();
                ret[i]++;
            &#125;
            if (!s.empty()) &#123;
                ret[i]++;
            &#125;
            s.push(heights[i]);
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>the end!</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">chou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/">http://example.com/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="/img/55.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/Tinyserver.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">TinyWebServer项目</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/112.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chou</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%EF%BC%81%EF%BC%81%EF%BC%81-%E7%9B%AE%E5%89%8DAK%E5%87%A0%E6%AC%A1%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%8C%E5%A4%A7%E9%83%A8%E5%88%86%E4%B8%89%E9%A2%98%E3%80%82%E3%80%82%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">加油！！！ 目前AK几次，起飞，大部分三题。。。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%8AM%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B"><span class="toc-number">2.</span> <span class="toc-text">《M的数据结构与算法笔记》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#273%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-12-26"><span class="toc-number">3.</span> <span class="toc-text">273场周赛 2021-12-26</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy"><span class="toc-number">3.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E4%B8%A4%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">反转两次的数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium"><span class="toc-number">3.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E5%90%8E%E7%BC%80%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 执行所有后缀指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium"><span class="toc-number">3.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E9%97%B4%E9%9A%94%E4%B9%8B%E5%92%8C"><span class="toc-number">3.3.1.</span> <span class="toc-text">相同元素的间隔之和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard"><span class="toc-number">3.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%98%E5%8E%9F%E5%8E%9F%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">还原原数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-2021-12-25"><span class="toc-number">4.</span> <span class="toc-text">68场双周赛 2021-12-25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-1"><span class="toc-number">4.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%AD%90%E4%B8%AD%E6%9C%80%E5%A4%9A%E5%8D%95%E8%AF%8D%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">句子中最多单词数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-1"><span class="toc-number">4.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%BB%99%E5%AE%9A%E5%8E%9F%E6%9D%90%E6%96%99%E4%B8%AD%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%87%BA%E7%9A%84%E8%8F%9C"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 从给定原材料中找到所有可以做出的菜</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-1"><span class="toc-number">4.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-number">4.3.1.</span> <span class="toc-text">判断一个括号字符串是否有效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-1"><span class="toc-number">4.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8C%BA%E9%97%B4%E5%86%85%E6%89%80%E6%9C%89%E6%95%B0%E4%B9%98%E7%A7%AF%E7%9A%84%E7%BC%A9%E5%86%99"><span class="toc-number">4.4.1.</span> <span class="toc-text">一个区间内所有数乘积的缩写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#272%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-12-19"><span class="toc-number">5.</span> <span class="toc-text">272场周赛 2021-12-19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-2"><span class="toc-number">5.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.1.</span> <span class="toc-text">找出数组中第一个回文字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-2"><span class="toc-number">5.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC"><span class="toc-number">5.2.1.</span> <span class="toc-text">向字符串添加空格</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-2"><span class="toc-number">5.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E5%B9%B3%E6%BB%91%E4%B8%8B%E9%99%8D%E7%9A%84"><span class="toc-number">5.3.1.</span> <span class="toc-text">股票平滑下降的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-2"><span class="toc-number">5.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84K%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">使数组K递增的最少操作次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#271%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-12-12"><span class="toc-number">6.</span> <span class="toc-text">271场周赛   2021-12-12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-3"><span class="toc-number">6.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%92%8C%E6%9D%86"><span class="toc-number">6.1.1.</span> <span class="toc-text">环和杆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-3"><span class="toc-number">6.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="toc-number">6.2.1.</span> <span class="toc-text">子数组范围和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-3"><span class="toc-number">6.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II"><span class="toc-number">6.3.1.</span> <span class="toc-text">给植物浇水II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-3"><span class="toc-number">6.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E6%B0%B4%E6%9E%9C"><span class="toc-number">6.4.1.</span> <span class="toc-text">摘水果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-2021-11-27"><span class="toc-number">7.</span> <span class="toc-text">66场双周赛 2021-11-27</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-4"><span class="toc-number">7.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BA%E7%8E%B0%E8%BF%87%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.1.1.</span> <span class="toc-text">统计出现过一次的公共字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-4"><span class="toc-number">7.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%88%BF%E5%B1%8B%E6%94%B6%E9%9B%86%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E6%A1%B6%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">从房屋收集需要的最少水桶数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-4"><span class="toc-number">7.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9B%9E%E5%AE%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7"><span class="toc-number">7.3.1.</span> <span class="toc-text">网格图中机器人回家的最小代价</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-4"><span class="toc-number">7.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%86%9C%E5%9C%BA%E4%B8%AD%E8%82%A5%E6%B2%83%E9%87%91%E5%AD%97%E5%A1%94%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">7.4.1.</span> <span class="toc-text">统计农场中肥沃金字塔的数目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#268%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-11-21"><span class="toc-number">8.</span> <span class="toc-text">268场周赛 2021-11-21</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-5"><span class="toc-number">8.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%A0%8B%E9%A2%9C%E8%89%B2%E4%B8%8D%E5%90%8C%E4%B8%94%E8%B7%9D%E7%A6%BB%E6%9C%80%E8%BF%9C%E7%9A%84%E6%88%BF%E5%AD%90"><span class="toc-number">8.1.1.</span> <span class="toc-text">两栋颜色不同且距离最远的房子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-5"><span class="toc-number">8.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4"><span class="toc-number">8.2.1.</span> <span class="toc-text">给植物浇水</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-5"><span class="toc-number">8.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E7%9A%84%E9%A2%91%E7%8E%87"><span class="toc-number">8.3.1.</span> <span class="toc-text">区间内查询数字的频率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-5"><span class="toc-number">8.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#K%E9%95%9C%E5%83%8F%E6%95%B0%E5%AD%97%E7%9A%84%E5%92%8C"><span class="toc-number">8.4.1.</span> <span class="toc-text">K镜像数字的和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#267%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-11-14"><span class="toc-number">9.</span> <span class="toc-text">267场周赛 2021-11-14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-6"><span class="toc-number">9.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%B0%E7%A5%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">9.1.1.</span> <span class="toc-text">买票需要的时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-6"><span class="toc-number">9.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%81%B6%E6%95%B0%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">9.2.1.</span> <span class="toc-text">反转偶数链表长度的节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-6"><span class="toc-number">9.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E6%96%9C%E5%90%91%E6%8D%A2%E4%BD%8D%E5%AF%86%E7%A0%81"><span class="toc-number">9.3.1.</span> <span class="toc-text">解码斜向换位密码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-6"><span class="toc-number">9.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%90%AB%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A5%BD%E5%8F%8B%E8%AF%B7%E6%B1%82"><span class="toc-number">9.4.1.</span> <span class="toc-text">处理含限制条件的好友请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#265%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-10-31"><span class="toc-number">10.</span> <span class="toc-text">265场周赛 2021-10-31</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-7"><span class="toc-number">10.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">10.1.1.</span> <span class="toc-text">值相等的最小索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-7"><span class="toc-number">10.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E4%B8%B4%E7%95%8C%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="toc-number">10.2.1.</span> <span class="toc-text">找出临界点之间的最小和最大距离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-7"><span class="toc-number">10.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BF%90%E7%AE%97%E6%95%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">转化数字的最小运算数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-7"><span class="toc-number">10.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A3%80%E6%B5%8B"><span class="toc-number">10.4.1.</span> <span class="toc-text">同源字符串检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#264%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-10-24"><span class="toc-number">11.</span> <span class="toc-text">264场周赛 2021-10-24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-8"><span class="toc-number">11.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D"><span class="toc-number">11.1.1.</span> <span class="toc-text">句子中的有效单词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-8"><span class="toc-number">11.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%95%B0"><span class="toc-number">11.2.1.</span> <span class="toc-text">下一个更大的数值平衡数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-8"><span class="toc-number">11.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E6%95%B0%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE"><span class="toc-number">11.3.1.</span> <span class="toc-text">统计最高分数的节点数目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-8"><span class="toc-number">11.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B"><span class="toc-number">11.4.1.</span> <span class="toc-text">并行课程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#263%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-10-17"><span class="toc-number">12.</span> <span class="toc-text">263场周赛 2021-10-17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-9"><span class="toc-number">12.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E9%80%92%E5%A2%9E"><span class="toc-number">12.1.1.</span> <span class="toc-text">检查句子中的数字是否递增</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-9"><span class="toc-number">12.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.2.1.</span> <span class="toc-text">简易银行系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-9"><span class="toc-number">12.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE"><span class="toc-number">12.3.1.</span> <span class="toc-text">统计按位或能得到的最大值的子集数目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-9"><span class="toc-number">12.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%9F%AD%E6%97%B6%E9%97%B4"><span class="toc-number">12.4.1.</span> <span class="toc-text">到达目的地的第二短时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-2021-10-16"><span class="toc-number">13.</span> <span class="toc-text">63场双周赛 2021-10-16</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-10"><span class="toc-number">13.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E6%AF%8F%E4%BD%8D%E5%AD%A6%E7%94%9F%E9%83%BD%E6%9C%89%E5%BA%A7%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">13.1.1.</span> <span class="toc-text">使每位学生都有座位的最小移动次数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-10"><span class="toc-number">13.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2"><span class="toc-number">13.2.1.</span> <span class="toc-text">如果相邻两个颜色相同则删除当前颜色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-10"><span class="toc-number">13.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E6%97%B6%E5%88%BB"><span class="toc-number">13.3.1.</span> <span class="toc-text">网络空闲时刻</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-10"><span class="toc-number">13.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%9A%84%E7%AC%ACk%E5%B0%8F%E4%B9%98%E7%A7%AF"><span class="toc-number">13.4.1.</span> <span class="toc-text">两个有序数的第k小乘积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-2021-10-02"><span class="toc-number">14.</span> <span class="toc-text">62场双周赛 2021-10-02</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-11"><span class="toc-number">14.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8F%98%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">14.1.1.</span> <span class="toc-text">将一维数组变成二维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-11"><span class="toc-number">14.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%90%8E%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9"><span class="toc-number">14.2.1.</span> <span class="toc-text">连接后等于目标字符串的字符串对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-11"><span class="toc-number">14.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6"><span class="toc-number">14.3.1.</span> <span class="toc-text">考试的最大困扰度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-11"><span class="toc-number">14.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%9A%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">14.4.1.</span> <span class="toc-text">分割数组的最多方案数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#252%E5%9C%BA%E5%91%A8%E8%B5%9B-2021-08-02"><span class="toc-number">15.</span> <span class="toc-text">252场周赛 2021-08-02</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-12"><span class="toc-number">15.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E9%99%A4%E6%95%B0"><span class="toc-number">15.1.1.</span> <span class="toc-text">三除数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-12"><span class="toc-number">15.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E6%95%B0"><span class="toc-number">15.2.1.</span> <span class="toc-text">你可以工作的最大周数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-12"><span class="toc-number">15.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E8%B6%B3%E5%A4%9F%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%B1%E5%9B%AD%E5%91%A8%E9%95%BF"><span class="toc-number">15.3.1.</span> <span class="toc-text">收集足够苹果的最小花园周长</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-12"><span class="toc-number">15.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">15.4.1.</span> <span class="toc-text">统计特殊子序列的数目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-2021-07-24"><span class="toc-number">16.</span> <span class="toc-text">57场双周赛 2021-07-24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-easy-13"><span class="toc-number">16.1.</span> <span class="toc-text">第一题(easy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%90%8C"><span class="toc-number">16.1.1.</span> <span class="toc-text">检查是否所有字符出现次数相同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-Medium-13"><span class="toc-number">16.2.</span> <span class="toc-text">第二题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%9C%AA%E8%A2%AB%E5%8D%A0%E6%8D%AE%E6%A4%85%E5%AD%90%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="toc-number">16.2.1.</span> <span class="toc-text">最小未被占据椅子的编号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98-Medium-13"><span class="toc-number">16.3.</span> <span class="toc-text">第三题(Medium)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%BB%98%E7%94%BB%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">16.3.1.</span> <span class="toc-text">描述绘画的结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98-Hard-13"><span class="toc-number">16.4.</span> <span class="toc-text">第四题(Hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9A%84%E4%BA%BA%E6%95%B0"><span class="toc-number">16.4.1.</span> <span class="toc-text">队列中可以看到的人数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/" title="LC周赛&amp;&amp;双周赛记录"><img src="/img/55.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LC周赛&amp;&amp;双周赛记录"/></a><div class="content"><a class="title" href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/" title="LC周赛&amp;&amp;双周赛记录">LC周赛&amp;&amp;双周赛记录</a><time datetime="2021-12-16T07:37:02.000Z" title="Created 2021-12-16 15:37:02">2021-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/" title="TinyWebServer项目"><img src="/img/Tinyserver.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TinyWebServer项目"/></a><div class="content"><a class="title" href="/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/" title="TinyWebServer项目">TinyWebServer项目</a><time datetime="2021-11-26T07:37:02.000Z" title="Created 2021-11-26 15:37:02">2021-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="linux高性能服务器笔记"><img src="/img/13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux高性能服务器笔记"/></a><div class="content"><a class="title" href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="linux高性能服务器笔记">linux高性能服务器笔记</a><time datetime="2021-11-25T07:37:02.000Z" title="Created 2021-11-25 15:37:02">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="moduo项目/读书笔记"><img src="/img/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="moduo项目/读书笔记"/></a><div class="content"><a class="title" href="/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="moduo项目/读书笔记">moduo项目/读书笔记</a><time datetime="2021-11-25T07:37:02.000Z" title="Created 2021-11-25 15:37:02">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="现代操作系统学习笔记"><img src="/img/17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代操作系统学习笔记"/></a><div class="content"><a class="title" href="/2021/11/25/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="现代操作系统学习笔记">现代操作系统学习笔记</a><time datetime="2021-11-25T07:37:02.000Z" title="Created 2021-11-25 15:37:02">2021-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By chou</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>