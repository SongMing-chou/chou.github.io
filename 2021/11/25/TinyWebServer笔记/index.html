

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/112.png">
  <link rel="icon" href="/img/112.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="前言详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。">
  <meta name="author" content="小M">
  <meta name="keywords" content="">
  <meta name="description" content="前言详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="(Web入门)TinyWebServer笔记">
<meta property="og:url" content="http://example.com/2021/11/25/TinyWebServer%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Chou">
<meta property="og:description" content="前言详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/11.jpg">
<meta property="article:published_time" content="2021-11-25T07:37:02.000Z">
<meta property="article:modified_time" content="2021-12-20T03:41:57.077Z">
<meta property="article:author" content="chou">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/11.jpg">
  
  <title>(Web入门)TinyWebServer笔记 - Chou</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>chou</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/55.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="(Web入门)TinyWebServer笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-25 15:37" pubdate>
        November 25, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">(Web入门)TinyWebServer笔记</h1>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。</p>
<span id="more"></span>
<h1 id="TinyWebServer-github上的一个开源项目"><a href="#TinyWebServer-github上的一个开源项目" class="headerlink" title="TinyWebServer github上的一个开源项目"></a>TinyWebServer github上的一个开源项目</h1><p>地址：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer%E3%80%82">https://github.com/qinguoyi/TinyWebServer。</a></p>
<p>Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.</p>
<ul>
<li>使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型</li>
<li>使用状态机解析HTTP请求报文，支持解析GET和POST请求</li>
<li>访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件</li>
<li>实现同步/异步日志系统，记录服务器运行状态</li>
<li>经Webbench压力测试可以实现上万的并发连接数据交换</li>
</ul>
<p>框架：</p>
<p><img src="/img/11.jpg" srcset="/img/loading.gif" lazyload>  </p>
<h2 id="1-线程同步机制包装类Locker"><a href="#1-线程同步机制包装类Locker" class="headerlink" title="1. 线程同步机制包装类Locker"></a>1. 线程同步机制包装类Locker</h2><p>文件locker是对信号量互斥锁、条件变量的几个函数进行封装。实现多线程同步，确保任一时刻只能有一个线程进入关键代码段。</p>
<h3 id="1-1-class-sem"><a href="#1-1-class-sem" class="headerlink" title="1.1 class sem"></a>1.1 class sem</h3><ul>
<li><p>什么是是信号量</p>
<p>  linux sem信号量是一种特殊的变量，访问具有原子性，用于解决进程或线程间共享资源引发的同步问题。</p>
<p>  用户态进程对sem信号量可以有以下两种操作：</p>
<ul>
<li>等待信号量, 当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。</li>
<li>发送信号量,将信号量加1，信号量大于0时，唤醒调用sem_pos的线程。</li>
</ul>
<p>  linux信号量相关函数声明头文件semaphore.h头文件中，所以使用信号量之前需要包含头文件。</p>
<blockquote>
<p>#include &lt;semaphore.h&gt;</p>
</blockquote>
</li>
<li><p>sem_init</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *sem, <span class="hljs-keyword">int</span> pshared, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> value)</span></span>;<br>该函数初始化由sem指向信号对象，并给他一个初始的整数值value。pshared控制信号量的类型，值为<span class="hljs-number">0</span>代表信号量用于多线程同步，值如果大于<span class="hljs-number">0</span>表示可以共享，用于多个相关进程的同步。参数pshared&gt;<span class="hljs-number">0</span>时指定了共享内存区域，所以可以在进程间共享该变量<br></code></pre></div></td></tr></table></figure></li>
<li><p>sem_wait</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *sem)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_trywait</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *sem)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>  sem_wait是一个阻塞函数，测试所指定信号量的值，他的操作时原子的，若sem value &gt; 0,则该信号量值减去1并立即返回，若sem value == 0，则阻塞直到sem value &gt; 0，此时立即减去1，然后返回。<br>  sem_trywait函数是非阻塞的函数，他会尝试获取sem value值，如果sem value == 0，不是阻塞住，而是返回一个错误EAGAIN。</p>
</li>
<li><p>sem_post</p>
<p>  把指定的信号量sem的值加1，唤醒正在等待该信号量的任意线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>*sem)</span></span>;<br></code></pre></div></td></tr></table></figure></li>
<li><p>sem_getvalue</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_getvalue</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>* sem,<span class="hljs-keyword">int</span>* sval)</span></span>;<br>获取信号量sem 当前的值，把该值保存在sval，如有一个或者多个线程在调用sem_wait阻塞在该信号量上，该函数返回阻塞在该信号量上进程或线程个数。<br></code></pre></div></td></tr></table></figure></li>
<li><p>sem_destroy</p>
<p>  该函数用于对用完的信号量的清理，它的原型如下：</p>
<blockquote>
<p>int sem_destroy(sem_t* sem);</p>
</blockquote>
</li>
</ul>
<h3 id="1-2-class-lock"><a href="#1-2-class-lock" class="headerlink" title="1.2 class lock"></a>1.2 class lock</h3><ul>
<li><p>互斥量</p>
<p>  系统中如果存在资源共享，线程中存在竞争，如果没有合理的同步机制的话，会出现数据混论现象，为了实现同步机制，其中一种就是互斥锁mutex(互斥量)。互斥锁，也称互斥量，可以保护关键代码段，以确保独占方式访问，当进入关键代码段，获得互斥锁将其加锁；离开关键代码段，唤醒等待该互斥锁的线程。<br>  在linux环境下，类型pthread_mutex_t其本质是一个结构体，一般以下面方式定义：变量mutex只有两种值1、0；</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-keyword">pthread_mutex_t</span> mutex;<br></code></pre></div></td></tr></table></figure></li>
<li><p>pthread_mutex_init</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>* <span class="hljs-keyword">restrict</span> mutex,<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_mutexattr_t</span>* <span class="hljs-keyword">restrict</span> attr)</span></span>;<br>函数作用，初始化一个互斥锁，成功返回<span class="hljs-number">0</span>，失败返回错误码。初值可视为<span class="hljs-number">1</span>；mutex：传出参数，调用时应传&amp;mutex给函数；attr:互斥量属性，是一个传入参数，通常传入<span class="hljs-literal">NULL</span>，表示默认属性(即线程间共享)。<br></code></pre></div></td></tr></table></figure>
<p>  关键字：restrict。仅作用于指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成，不能通过除本指针以外的其他变量或指针来修改。</p>
</li>
<li><p>pthread_mutex_lock</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span> *mutex)</span></span><br><span class="hljs-function">获取锁，成功时返回0，如果获取失败，则该线程将阻塞，直到持有该互斥量的其他线程解锁为止,在访问共享资源前加锁，访问结束后立即解锁，锁的“粒度”应该越小越好。</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>pthread_mutex_unlock</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>*mutex)</span></span>;<br>释放锁，在释放锁的同时，会将所有阻塞的线程全部唤醒，至于哪个线程先被唤醒取决于优先级、调度。默认情况下先阻塞的线程先被唤醒。<br></code></pre></div></td></tr></table></figure></li>
<li><p>pthread_mutex_trylock</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>*mutex)</span></span>;<br>尝试获取锁，成功返回<span class="hljs-number">0</span>，获取失败不会阻塞当前线程，而是返回一个值来描述互斥锁的状况。<br></code></pre></div></td></tr></table></figure></li>
<li><p>pthread_mutex_destroy</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span> *mutex)</span></span>;<br>函数作用，销毁一个互斥锁。成功返回<span class="hljs-number">0</span>，失败返回错误码<br><br></code></pre></div></td></tr></table></figure>
<h3 id="1-3-class-cond"><a href="#1-3-class-cond" class="headerlink" title="1.3 class cond"></a>1.3 class cond</h3></li>
<li><p>条件变量</p>
<p>  与互斥锁不同，条件变量是用来等待的，而不是用来上锁的，条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。互斥锁的一个明显缺点就是他只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足。</p>
</li>
<li><p>pthread_cond_init</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span>*<span class="hljs-keyword">restrict</span> cond,<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_condattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span></span>;<br><br>函数作用，初始化一个条件变量，参数说明：cond:条件变量，调用时应传&amp;cond给该函数，attr:条件变量，通常传入<span class="hljs-literal">NULL</span>，表示使用默认属性。<br></code></pre></div></td></tr></table></figure></li>
<li><p>pthread_cond_wait And pthread_cond_timedwait</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond,<span class="hljs-keyword">pthread_mutex_t</span> * restric mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> * <span class="hljs-keyword">restrict</span> cond,<span class="hljs-keyword">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex,<span class="hljs-keyword">const</span> struct timespec* <span class="hljs-keyword">restrict</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>  成功时返回0，错误则返回错误码，这两个分别是阻塞等待和超时等待，等待条件变为真，传递给pthread_cond_wait的互斥量对条件进行保护，调用者把锁住的互斥量传给函数，函数把调用线程放到等待条件的线程列表上，然后对互斥量解锁，这两个操作是原子的。</p>
</li>
<li><p>pthread_cond_signal And pthread_cond_broadcast</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> *cond)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> * cond)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>这两个函数用于通知线程条件已经满足，调用这个函数也称向线程或条件发送信号，必须注意一定要在改变状态以后再给线程发送信号。成功返回0，出错返回错误编号。</p>
</li>
<li><p>pthread_cond_destroy   </p>
<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destroy(<span class="hljs-params">pthread_cond_t</span><span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;  <br>函数作用，销毁一个条件变量。成功返回<span class="hljs-number">0</span>，失败返回错误码。  <br></code></pre></div></td></tr></table></figure></li>
</ul>
<h2 id="2-同步-异步日志系统log"><a href="#2-同步-异步日志系统log" class="headerlink" title="2 .同步/异步日志系统log"></a>2 .同步/异步日志系统log</h2><h3 id="2-1block-queue-h"><a href="#2-1block-queue-h" class="headerlink" title="2.1block_queue.h"></a>2.1block_queue.h</h3><p> 循环数组实现的阻塞队列的一个模板类，从性能上考虑，没有使用STL的queue作为基本数据结构，而是使用循环数组，省去了动态内存分配和回收。线程安全，每个操作前都要先加互斥锁，操作完后，再解锁。</p>
<p>循环数组实现主要是用了以下两个式子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_back = (m_back + <span class="hljs-number">1</span>) % m_max_size<br>m_front = (m_front + <span class="hljs-number">1</span>)% m_max_size<br></code></pre></div></td></tr></table></figure>

<p>数据成员</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>locker m_mutex; <span class="hljs-comment">//互斥锁</span><br>cond m_cond;    <span class="hljs-comment">//信号量</span><br>T *m_array;     <span class="hljs-comment">//数组指针</span><br><span class="hljs-keyword">int</span> m_size;     <span class="hljs-comment">//数组当前大小</span><br><span class="hljs-keyword">int</span> m_max_size; <span class="hljs-comment">//数组最大大小</span><br><span class="hljs-keyword">int</span> m_front;    <span class="hljs-comment">//数组非空最先储存元素索引</span><br><span class="hljs-keyword">int</span> m_back;     <span class="hljs-comment">//数组非空最后元素索引</span><br></code></pre></div></td></tr></table></figure>

<p>接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">front</span><span class="hljs-params">(T &amp;value)</span></span>; <span class="hljs-comment">//引用的方式，这里面复制到value,数组空返回false</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">back</span><span class="hljs-params">(T &amp;value)</span></span>; <span class="hljs-comment">//同上</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//当前大小</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_size</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;item)</span></span>;<span class="hljs-comment">//const，判断是否满了，计算下一索引m_back = (m_back + 1) % m_max_size，赋值。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(T &amp;item)</span></span>; <span class="hljs-comment">//pop时如果当前队列没有元素，将会等待条件变量调用cond.wait函数，计算下一索引m_front = (m_front + 1)% m_max_size，赋值返回。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(T &amp;item,<span class="hljs-keyword">int</span> ms_timeout)</span></span>;<span class="hljs-comment">//在等待条件变量的时候加了超时处理。调用cond_timewait函数</span><br></code></pre></div></td></tr></table></figure>

<h3 id="2-2-log-h"><a href="#2-2-log-h" class="headerlink" title="2.2 log.h"></a>2.2 log.h</h3><p>在log.h声明了一个单例模式的log类，该类可设置同步异步，异步时单独开启一个线程从阻塞队列中取出日志并写入，同步时只是单独写入，要注意改变类内的一些变量(行数相关)时要上锁，每次更换文件或者阻塞队列满了都要上锁保证日志能完全正确写入。</p>
<ul>
<li><p>单例模式</p>
<ul>
<li>单例模式的实现</li>
</ul>
<p>  1.构造函数声明为private或protect防止被外部函数实例化。</p>
<p>  2.提供一个全局的静态方法(全局访问点)。</p>
<p>  3.内部保存一个private static的类指针保存唯一的实例，实例的动作由一个public的类方法代劳，该方法也返回单例类唯一的实例。</p>
<p>  如果只是这样实现是线程不安全的，当两个线程同时访问静态方法的时候，会同时构造一个实例。</p>
</li>
<li><p>懒汉式和饿汉式</p>
<ul>
<li>懒汉不到万不得已就不会去实例化类，只有在第一次使用类实例的时候才会实例化。</li>
</ul>
<p>  懒汉式在单例模式中的静态方法加锁就可以实现。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">singleton</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">singleton</span>()<br>    &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> singleton* p;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> singleton* <span class="hljs-title">initance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">pthread_mutex_t</span> singleton::mutex;<br>singleton* singleton::p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function">singleton* <span class="hljs-title">singleton::initance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>            p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">singleton</span>();<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>饿汉 在单例类定义的时候就进行初始化。</p>
<p>  饿汉式静态方法初始化是就实例化，而全局方法就不需要实例化了；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singelton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singelton</span>()&#123;<br>        m_count ++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Singelton begin\n&quot;</span>);<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);                            <span class="hljs-comment">// 加sleep为了放大效果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Singelton end\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> Singelton *single;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singelton *<span class="hljs-title">GetSingelton</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_count;<br>&#125;;<br><span class="hljs-comment">// 饿汉模式的关键：初始化即实例化</span><br>Singelton *Singelton::single = <span class="hljs-keyword">new</span> Singelton;<br><span class="hljs-keyword">int</span> Singelton::m_count = <span class="hljs-number">0</span>;<br><span class="hljs-function">Singelton *<span class="hljs-title">Singelton::GetSingelton</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 不再需要进行实例化</span><br>    <span class="hljs-comment">//if(single == nullptr)&#123;</span><br>    <span class="hljs-comment">//    single = new Singelton;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">return</span> single;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>类成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> dir_name[<span class="hljs-number">128</span>]; <span class="hljs-comment">//路径名</span><br><span class="hljs-keyword">char</span> log_name[<span class="hljs-number">128</span>]; <span class="hljs-comment">//log文件名</span><br><span class="hljs-keyword">int</span> m_split_lines;  <span class="hljs-comment">//日志最大行数</span><br><span class="hljs-keyword">int</span> m_log_buf_size; <span class="hljs-comment">//日志缓冲区大小</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m_count;  <span class="hljs-comment">//日志行数记录</span><br><span class="hljs-keyword">int</span> m_today;        <span class="hljs-comment">//因为按天分类,记录当前时间是那一天</span><br>FILE *m_fp;         <span class="hljs-comment">//打开log的文件指针</span><br><span class="hljs-keyword">char</span> *m_buf;<br>block_queue&lt;string&gt; *m_log_queue; <span class="hljs-comment">//阻塞队列</span><br><span class="hljs-keyword">bool</span> m_is_async;                  <span class="hljs-comment">//是否同步标志位</span><br>locker m_mutex;<br><span class="hljs-keyword">int</span> m_close_log; <span class="hljs-comment">//关闭日志</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li>成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Log *<span class="hljs-title">get_instance</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//单例初始化</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">flush_log_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*args)</span></span>;<span class="hljs-comment">//回调函数，封装void*async_write_log()</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file_name,<span class="hljs-keyword">int</span> close_log,<span class="hljs-keyword">int</span> log_buf_size == <span class="hljs-number">8192</span>,<span class="hljs-keyword">int</span> split_lines = <span class="hljs-number">5000000</span>,<span class="hljs-keyword">int</span> max_queue_size  = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//强制刷新写入流缓冲区</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">async_write_log</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//阻塞队列中取出log并写入，带锁。</span><br><br></code></pre></div></td></tr></table></figure>

<p>在函数void write_log(int level,const char *<br>format,…)中用了省略符形参，省略符形参应该仅仅用于c和c++通用的类型，因为大多数类型的对象在传递省略形参时都无法正确拷贝。<br>使用省略符形参需要用到头文件 cstdarg下面是<cstdarg>头文件的几个宏定义：  </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdarg&gt;</span>  <span class="hljs-comment">// C中是&lt;stdarg.h&gt;</span></span><br><span class="hljs-comment">// va_list是一种数据类型，args用于持有可变参数。</span><br><span class="hljs-comment">// 定义typedef char* va_list;</span><br>va_list args;<br><br><span class="hljs-comment">// 调用va_start并传入两个参数：第一个参数为va_list类型的变量</span><br><span class="hljs-comment">// 第二个参数为&quot;...&quot;前最后一个参数名</span><br><span class="hljs-comment">// 将args初始化为指向第一个参数（可变参数列表）</span><br><span class="hljs-built_in">va_start</span>(args, paramN);<br><br><span class="hljs-comment">// 检索参数，va_arg的第一个参数是va_list变量，第二个参数指定返回值的类型</span><br><span class="hljs-comment">// 每一次调用va_arg会获取当前的参数，并自动更新指向下一个可变参数。</span><br><span class="hljs-built_in">va_arg</span>(args,type);<br><br><span class="hljs-comment">// 释放va_list变量</span><br><span class="hljs-built_in">va_end</span>(args);<br></code></pre></div></td></tr></table></figure>

<p>例如如下的用法，该用法只适合c语言支持的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdarg&gt;</span></span><br><span class="hljs-comment">//省略符型参仅仅用于c和c++通用的类型，特别应该注意的是，大多数类类型的对象在传递省略符型参都无法正确拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count,...)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is below 0!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//为了实现可变参数列表，首先需要声明一个va_list类型的指针，该指针用来依次指向各个参数</span><br>    va_list arg_ptr;<br><br>    <span class="hljs-comment">//va_start是一个宏，用来初始化va_list，使其指向列表的第一个参数，va_start的第二个参数是sum函数省略符前的参数，用来固定第一个参数的位置</span><br>    va_start(arg_ptr,count);<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值</span><br>    <span class="hljs-comment">//va_arg宏的第二个参数是需要统计的第一个参数的类型，如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; count;i++) &#123;<br>        res+=va_arg(arg_ptr,<span class="hljs-keyword">int</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将va_list类型的指针复位成空值</span><br>    <span class="hljs-comment">//就是清空可变参数列表</span><br>    va_end(arg_ptr);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>sum(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//return 15</span><br><br></code></pre></div></td></tr></table></figure>
<p>在对log内容的操作中，log日志类用的是fopen函数，fopen 和open的区别主要有以下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function">EILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;<br><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>mode指定文件打开的方式：  </p>
<ul>
<li>r：只读方式打开一个文本文件（该文件必须存在）  </li>
<li>r+：可读可写方式打开一个文本文件（该文件必须存在）  </li>
<li>w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）  </li>
<li>w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）  </li>
<li>a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））  </li>
<li>a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））  </li>
</ul>
</li>
<li><p>a 和 a+ 的区别：a 不能读，a+ 可以读  </p>
<ul>
<li>rb：只读方式打开一个二进制文件（使用法则同r）  </li>
<li>rb+：可读可写方式打开一个二进制文件（使用法则同r+）  </li>
<li>wb：只写方式打开一个二进制文件（使用法则同w）  </li>
<li>wb+：可读可写方式生成一个二进制文件（使用法则同w+）  </li>
<li>ab：追加方式打开一个二进制文件（使用法则同a）  </li>
<li>ab+：可读可写方式追加一个二进制文件（使用法则同a+）  </li>
</ul>
</li>
</ul>
<p>返回值，fopen()返回的是一个FILE类型的指针，若打开失败返回NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*pathname, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*pathname, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>flag用于指定文件打开/创建的方式，这个参数可由以下三个互斥的常量(定义于fcntl.h)，通过逻辑或连接。<ul>
<li>O_RDONLY  只读  </li>
<li>O_WRONLY  只写  </li>
<li>O_RDWR    读写<br>返回值，open返回的是一个文件描述符，打开失败返回-1。</li>
</ul>
</li>
</ul>
<p>区别  </p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">open属于低级IO，fopen属于高级IO;<br>前者返回一个文件描述符，后者返回一个指针；<br>前者无缓冲，后者有缓冲；<br>前者与<span class="hljs-built_in">read</span>,write等配合使用，后者与fread,fwrite使用；<br>后者是在前者的基础上扩充而来的，在大多数情况下，用后者；<br>fopen是c库中的函数，而open是linux中的系统调用。<br></code></pre></div></td></tr></table></figure>

<p>c库函数strrchr():  </p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str,<span class="hljs-keyword">int</span> c)</span></span>;<br>str--C字符串<br>c  --要搜索的字符，以<span class="hljs-keyword">int</span>形式传递，但是最终回转回<span class="hljs-keyword">char</span>形式。<br></code></pre></div></td></tr></table></figure>
<p>在本项目中主要是用来分割路径‘/’和文件名的位置(找到文件名)；<br>c库函数snprintf()</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br>    <span class="hljs-comment">//设将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，    </span><br>    s<span class="hljs-comment">//ize 为要写入的字符的最大数目，超过 size 会被截断</span><br>    <span class="hljs-built_in">snprintf</span>(log_full_name,<span class="hljs-number">255</span>,<span class="hljs-string">&quot;%d_%d_%02d_%s&quot;</span>,my_tm.tm_year + <span class="hljs-number">1900</span>,<br>                 my_tm.tm_mon,my_tm.tm_mday,file_name);<br></code></pre></div></td></tr></table></figure>
<p>c库函数strcpy()和strncpy()</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//将src所指向的字符串复制到dest</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * src)</span></span>;<br><span class="hljs-comment">//把src所指向的字符串复制到dest最多复制n个字符。当src的长度小于n时，dest的剩余部分将用空字节填充</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*src,<span class="hljs-keyword">size_t</span> size)</span></span>;<br></code></pre></div></td></tr></table></figure>
<h2 id="3-线程池-半同步-半反应堆线程池"><a href="#3-线程池-半同步-半反应堆线程池" class="headerlink" title="3 .线程池 半同步/半反应堆线程池"></a>3 .线程池 半同步/半反应堆线程池</h2><p>补充知识：  </p>
<h3 id="半同步-半异步模型-HSHA"><a href="#半同步-半异步模型-HSHA" class="headerlink" title="半同步/半异步模型 HSHA"></a>半同步/半异步模型 HSHA</h3><ul>
<li>什么是线程池<br>线程池是服务器预先创建的一组线程，这些线程运行着相同的代码，当新任务到来时，主线程通过某种方式选择线程池中的某一个线程来为之服务，服务完之后又放回线程池(其实就是阻塞和唤醒)。  </li>
<li>为什么需要线程池<br>相比于动态创建线程来说，线程池可以提高速度，因为线程的创建和销毁是要时间的。如果频繁的线程创建和销毁线程是非常消耗内核资源的。  </li>
<li>什么是半同步/半异步<br>[半同步/半异步]模式，(half-sync/halt-async,以下就简称HSHA)，主要分三层：<figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">异步IO<span class="hljs-comment">(主线程)</span>;<br>队列层<span class="hljs-comment">(任务队列)</span>；<br>同步处理层<span class="hljs-comment">(线程池)</span>；  <br></code></pre></div></td></tr></table></figure>
异步IO与同步处理</li>
</ul>
<ul>
<li>所谓同步：在客户端连接，请求数据，以及向队列中写入数据的时候是异步的。在写入完成可能会执行预设的回调函数，进行预处理和其他通知操作，也便是Proactor模式。  </li>
<li>关于异步IO，严重依赖内核的支持，比如window的IOCP就是公认的不错的异步IO实现，而Linux的AIO系列内部还是用多线程来模拟，实则伪异步，epool不是异步IO，因为要遍历发生变化的FD然后循环将数据读完。  </li>
<li>所谓同步：在线程池中，工作线程从任务队列中每次取出任务，其具体的业务逻辑是同步的，虽然在消费队列的时候是多线程，但是并不会多个线程处理一次请求。  </li>
</ul>
<p>半同步/半异步模型 HSHA是工作线程负责异步地从客户端fd获取客户端的请求数据，而工作线程则是并发的对该数据进行处理，工作线程不关心客户端fd，不关心通信，而IO线程不关心处理过程。    </p>
<h3 id="半同步-半反应堆模型-HSHR"><a href="#半同步-半反应堆模型-HSHR" class="headerlink" title="半同步/半反应堆模型 HSHR"></a>半同步/半反应堆模型 HSHR</h3><ul>
<li>HSHA模式十分依赖异步IO，然而实现真正异步通常比较困难，IO多路复用技术的发展带给人们新思路，用IO多路复用代替异步IO，对HAHS进行改造。这就是半同步半反应堆模型(Half-Sync/Halt-Reactor,HSHR);  </li>
</ul>
<p>半同步/半反应堆模型 HSHR ，主线程只监听socket,当监测到服务器sock可读，就会进行accept,获得fd放入队列。也就是说与HSHA不同，HSHR的队列放的不是请求数据，而是fd，工作线程从队列中取的不是数据，而是客户端fd。和HSHA不同，HSHR将IO的过程侵入到了工作线程中。工作线程的逻辑循环内从队列取道fd后，对fd进行read/recv获取请求数据，然后进行处理，最后直接write/send客户端fd，将数据返回给客户端。可以看来，这种IO的方式是一种Reactor模式，这就是该模型中半反应堆一词的由来。</p>
<p>工作队列  </p>
<blockquote>
<p>工作线程消费队列数据的方式  </p>
</blockquote>
<ul>
<li>和一般的队列模型相同，分为推和拉的两种模型，通常HSHA为推模型，需要一个条件变量来实现。即队列尚无数据，则工作线程阻塞休眠，等待数据产生，而当IO线程将数据写入任务队列的时候，则会唤醒休眠的工作线程来处理；拉模型即不再需要条件变量，工作线程内作死循环，不停轮训队列数据。两种模型各有利弊，如果是IO密集型的，比如并发度特别高，以至于总能取到数据，那么就不需要推模型。</li>
</ul>
<p>本项目用的是半同步半反应堆模式，http连接放进队列中。然后由工作线程来取任务。<br>实现细节：</p>
<p>数据成员：  </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_thread_number;        <span class="hljs-comment">//线程池中的线程数</span><br>    <span class="hljs-keyword">int</span> m_max_requests;         <span class="hljs-comment">//请求队列中允许的最大请求数</span><br>    <span class="hljs-keyword">pthread_t</span> *m_threads;       <span class="hljs-comment">//描述线程池的数组，其大小为m_thread_number</span><br>    std::list&lt;T *&gt; m_workqueue; <span class="hljs-comment">//请求队列</span><br>    locker m_queuelocker;       <span class="hljs-comment">//保护请求队列的互斥锁</span><br>    sem m_queuestat;            <span class="hljs-comment">//是否有任务需要处理</span><br>    connection_pool *m_connPool;  <span class="hljs-comment">//数据库</span><br>    <span class="hljs-keyword">int</span> m_actor_model;          <span class="hljs-comment">//模型切换</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>成员函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span><br>    <span class="hljs-built_in">threadpool</span>(<span class="hljs-keyword">int</span> actor_model, connection_pool *connPool, <span class="hljs-keyword">int</span> thread_number = <span class="hljs-number">8</span>, <span class="hljs-keyword">int</span> max_request = <span class="hljs-number">10000</span>);<br>    ~<span class="hljs-built_in">threadpool</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">append</span><span class="hljs-params">(T *request, <span class="hljs-keyword">int</span> state)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">append_p</span><span class="hljs-params">(T *request)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>在本项目中的用的是模板类<del>其实没必要</del>。如果要将声明和实现分开的话需要在头文件中实例化，否则编译不过去。  </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//要在cpp文件加上，这样的一句，将模板类实例化以用来多文件编译</span><br><span class="hljs-keyword">template</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">threadpool</span>&lt;</span>mDate&gt;<br><br></code></pre></div></td></tr></table></figure>
<p>在构造函数中，构造线程数组时，将线程分离，使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//分离线程，自己回收无需父线程回收</span><br><span class="hljs-built_in">pthread_detach</span>(id);<br></code></pre></div></td></tr></table></figure>

<h2 id="4-校验-amp-数据库连接池"><a href="#4-校验-amp-数据库连接池" class="headerlink" title="4 .校验 &amp; 数据库连接池"></a>4 .校验 &amp; 数据库连接池</h2><p>补充知识：</p>
<p>分配或初始化mysql_real_connect()相适应的MYSQL对象，如果指针是NULL指针，该函数将分配，初始化并返回新对象。否则<br>将初始化对像，并返回对象的地址，如果mysql_init()分配了新对象，当调用mysql_close()来关闭连接时，将释放对象。初始化句柄，出现无足够内存时，返回NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_init</span><span class="hljs-params">(MYSQL*mysql)</span></span>;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须;成功完成。参数的指定方式如下：</li>
</ul>
<ul>
<li>第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。请参见25.2.3.48节，“mysql_options()”。</li>
<li>“host”的值必须是主机名或IP地址。如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP/IP连接到服务器。</li>
<li>“user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串””，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名。请参见26.1.9.2节，“在Windows上配置MyODBC DSN”。</li>
<li>“passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</li>
<li>注释：调用mysql_real_connect()之前，不要尝试加密密码，密码加密将由客户端API自动处理。<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_real_connect</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *passwd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *db, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *unix_socket, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> client_flag)</span></span><br></code></pre></div></td></tr></table></figure>
数据库连接池</li>
<li>单例模式，保证唯一</li>
<li>list实现连接池</li>
<li>连接池为静态大小</li>
<li>互斥锁实现线程安全</li>
</ul>
<p>校验</p>
<ul>
<li>HTTP请求采用POST方式</li>
<li>登录用户名和密码校验</li>
<li>用户注册及多线程注册安全</li>
</ul>
<p>因为这项目的数据库是写死的，所以所有连接的数据库的名字，数据库端口什么都一样，所以就创建一个数据库连接池，让不会因为销毁连接创建连接而消耗额外的资源。</p>
<p>数据成员</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_MaxConn;  <span class="hljs-comment">//最大连接数</span><br> <span class="hljs-keyword">int</span> m_CurConn;  <span class="hljs-comment">//当前已使用的连接数</span><br> <span class="hljs-keyword">int</span> m_FreeConn; <span class="hljs-comment">//当前空闲的连接数</span><br> locker lock;<br> list&lt;MYSQL *&gt; connList; <span class="hljs-comment">//连接池</span><br> sem reserve;<br><br><span class="hljs-keyword">public</span>:<br> string m_url;			 <span class="hljs-comment">//主机地址</span><br> string m_Port;		 <span class="hljs-comment">//数据库端口号</span><br> string m_User;		 <span class="hljs-comment">//登陆数据库用户名</span><br> string m_PassWord;	 <span class="hljs-comment">//登陆数据库密码</span><br> string m_DatabaseName; <span class="hljs-comment">//使用数据库名</span><br> <span class="hljs-keyword">int</span> m_close_log;	<span class="hljs-comment">//日志开关</span><br></code></pre></div></td></tr></table></figure>

<p>成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">MYSQL* <span class="hljs-title">GetConnection</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//获取数据库连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReleaseConnection</span><span class="hljs-params">(MYSQL *conn)</span></span>; <span class="hljs-comment">//释放连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetFreeConn</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyPool</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">//销毁所有连接</span><br><br>    <span class="hljs-comment">//单例模式</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> connection_pool * <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(string url, string User, string PassWord, string DataBaseName, <span class="hljs-keyword">int</span> Port, <span class="hljs-keyword">int</span> MaxConn, <span class="hljs-keyword">int</span> close_log)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">connection_pool</span>();<br>    ~<span class="hljs-built_in">connection_pool</span>();<br><br></code></pre></div></td></tr></table></figure>
<p>初始化mysql,信号量初始化成m_FreeConn(m_MaxConn)；<br>当有请求的时候，在数据库连接池中返回一个可用连接，更新使用和空闲连接数，注意在取连接和更新空闲连接数的时候要使用锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connection_pool::ReleaseConnection</span><span class="hljs-params">(MYSQL *con)</span> </span>&#123;<br> MYSQL *con = <span class="hljs-literal">NULL</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == connList.<span class="hljs-built_in">size</span>())<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br> reserve.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">//如果信号量不可用 阻塞</span><br> lock.<span class="hljs-built_in">lock</span>();<br> con = connList.<span class="hljs-built_in">front</span>();<br> connList.<span class="hljs-built_in">pop_front</span>();<br> --m_FreeConn;<br> ++m_CurConn;<br> lock.<span class="hljs-built_in">unlock</span>();<br> <span class="hljs-keyword">return</span> con;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>释放连接的时候，压入连接池和改变可用空闲个数的时候也需要上锁，上锁之后不要忘了更新信号量(+1)。</p>
<p>在销毁数据库连接池的整个过程都要持有锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connection_pool::DestroyPool</span><span class="hljs-params">()</span> </span>&#123;<br><br> lock.<span class="hljs-built_in">lock</span>();<br> <span class="hljs-keyword">if</span> (connList.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br> &#123;<br>  list&lt;MYSQL *&gt;::iterator it;<br>  <span class="hljs-keyword">for</span> (it = connList.<span class="hljs-built_in">begin</span>(); it != connList.<span class="hljs-built_in">end</span>(); ++it)<br>  &#123;<br>   MYSQL *con = *it;<br>   <span class="hljs-built_in">mysql_close</span>(con);<br>  &#125;  <br>  m_CurConn = <span class="hljs-number">0</span>;<br>  m_FreeConn = <span class="hljs-number">0</span>;<br>  connList.<span class="hljs-built_in">clear</span>();<br> &#125;<br><br> lock.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-http连接处理类"><a href="#5-http连接处理类" class="headerlink" title="5. http连接处理类"></a>5. http连接处理类</h2><p>根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机</p>
<blockquote>
<ul>
<li>客户端发出http连接请求</li>
<li>从状态机读取数据,更新自身状态和接收数据,传给主状态机</li>
<li>主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取</li>
</ul>
</blockquote>
<p>补充知识：<br>recv函数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recv</span><span class="hljs-params">(SOCKET s,<span class="hljs-keyword">char</span> *buf,<span class="hljs-keyword">int</span> len,<span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-comment">//s     标识已连接套接字的描述符</span><br><span class="hljs-comment">//buf   指向缓冲区的指针，以接受传入的数据</span><br><span class="hljs-comment">//len   buf参数指向缓冲区的长度一般是参数二-1，留出&quot;\0&quot;</span><br><span class="hljs-comment">//flags 一组影响此功能行为的标志</span><br><br>返回值：  <br><span class="hljs-number">1.</span> 成功执行，返回接受到的字节数  <br><span class="hljs-number">2.</span> 另一端已关闭，则返回<span class="hljs-number">0</span>  <br><span class="hljs-number">3.</span> 失败返回<span class="hljs-number">-1</span>，errno被设为以下的某一个值  <br>* EAGAIN:套接字已标记为非阻塞，而接收操作被阻塞或者接受超时，  <br>* EBADF：sock不是有效的描述符，  <br>* ECONNREFUSE：远程主机阻绝网络连接  <br>* EFAULT：内存空间访问出错，  <br>* EINTR：操作被信号中断，  <br>* EINVAL：参数无效，  <br>* ENOMEM：内存不足，  <br>* ENOTCONN：面向连接的套接字尚未被连接上，  <br>* ENOTSOCK：sock索引的不是套接字，当返回的值是<span class="hljs-number">0</span>，为正常关闭连接。  <br>特别的：  <br><br></code></pre></div></td></tr></table></figure>
<p>用到的C库函数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//C 库函数 char *strpbrk(const char *str1, const char *str2) 检索字符串 str1 中第一个匹配字符串 </span><br><span class="hljs-comment">//str2,中字符的字符不包含空结束字符也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，</span><br><span class="hljs-comment">//则停止检验，并返回该字符位置。</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strpbrk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  *str2)</span></span>;  <br><br><br><span class="hljs-comment">//检索字符串参数是否相等，忽略大小写,两字符串相同返回0，s1大于s2返回大于0值，反之返回小于0值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcasecmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s2)</span></span>;<br><br><span class="hljs-comment">//检索str1中第一个不在字符串str2中出现的字符下标</span><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strspn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * str1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str2)</span></span>;<br><br><span class="hljs-comment">//返回iu字符串str中第一次出现字符c的位置，如果未找到返回null,c会转换成字符</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> c)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//把src所指向的字符串追加到dest所指向的字符串的结尾</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src)</span></span>;<br><br>```   <br>linux文件相关部分函数<br>```c++<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">//通过文件名file_name获取文件信息，并保存在buf所指的结构体stat中</span><br><span class="hljs-comment">//成功返回0，失败返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file_name,struct stat *buf)</span></span>;<br><br><span class="hljs-comment">//stat 结构体，如果保护模式不是S——IROTH,返回FORBIDDEN——REQUEST</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">dev_t</span>       st_dev;     <span class="hljs-comment">/* ID of device containing file -文件所在设备的ID*/</span><br>    <span class="hljs-keyword">ino_t</span>       st_ino;     <span class="hljs-comment">/* inode number -inode节点号*/</span><br>    <span class="hljs-keyword">mode_t</span>      st_mode;    <span class="hljs-comment">/* protection -保护模式?*/</span><br>    <span class="hljs-keyword">nlink_t</span>     st_nlink;   <span class="hljs-comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span><br>    <span class="hljs-keyword">uid_t</span>       st_uid;     <span class="hljs-comment">/* user ID of owner -user id*/</span><br>    <span class="hljs-keyword">gid_t</span>       st_gid;     <span class="hljs-comment">/* group ID of owner - group id*/</span><br>    <span class="hljs-keyword">dev_t</span>       st_rdev;    <span class="hljs-comment">/* device ID (if special file) -设备号，针对设备文件*/</span><br>    <span class="hljs-keyword">off_t</span>       st_size;    <span class="hljs-comment">/* total size, in bytes -文件大小，字节为单位*/</span><br>    <span class="hljs-keyword">blksize_t</span>   st_blksize; <span class="hljs-comment">/* blocksize for filesystem I/O -系统块的大小*/</span><br>    <span class="hljs-keyword">blkcnt_t</span>    st_blocks;  <span class="hljs-comment">/* number of blocks allocated -文件所占块数*/</span><br>    <span class="hljs-keyword">time_t</span>      st_atime;   <span class="hljs-comment">/* time of last access -最近存取时间*/</span><br>    <span class="hljs-keyword">time_t</span>      st_mtime;   <span class="hljs-comment">/* time of last modification -最近修改时间*/</span><br>    <span class="hljs-keyword">time_t</span>      st_ctime;   <span class="hljs-comment">/* time of last status change - */</span><br>&#125;;<br><br><br><br></code></pre></div></td></tr></table></figure>
<p>http请求报文：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">GET     /sonmedir/page.html     HTTP/<span class="hljs-number">1.1</span><br>Host:   www.someschool.edu<br>Connection:     close<br>User_agent: Mozilla/<span class="hljs-number">5.0</span><br>Accept-language:    fr<br></code></pre></div></td></tr></table></figure>

<p>该项目的请求有以下几种：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">0</span> 注册<br><span class="hljs-number">1</span> 登陆<br><span class="hljs-number">2</span> 选择<br><span class="hljs-number">3</span> 注册之后跳转的登录界面<br><span class="hljs-number">5</span> 看图片<br><span class="hljs-number">6</span> 看视频<br><span class="hljs-number">7</span> 关注页面<br></code></pre></div></td></tr></table></figure>
<p>http_conn.h中成员和成员函数如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">http_conn</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> FILENAME_LEN = <span class="hljs-number">200</span>;  <span class="hljs-comment">//文件名字长度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> READ_BUFFER_SIZE = <span class="hljs-number">2048</span>;   <span class="hljs-comment">//每次读取数据长度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> WRITE_BUFFER_SIZE = <span class="hljs-number">1024</span>;  <span class="hljs-comment">//每次写的长度</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">METHOD</span> &#123;</span><span class="hljs-comment">//行为</span><br>        GET = <span class="hljs-number">0</span>,<br>        POST,<br>        HEAD,<br>        PUT,<br>        DELETE,<br>        TRACE,<br>        OPTIONS,<br>        CONNECT,<br>        PATH<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CHECK_STATE</span> &#123;</span><span class="hljs-comment">//状态</span><br>        CHECK_STATE_REQUESTLINE = <span class="hljs-number">0</span>,<br>        CHECK_STATE_HEADER,<br>        CHECK_STATE_CONTENE<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">HTTP_CODE</span> &#123;</span><br>        NO_REQUEST,<br>        GET_REQUEST,<br>        BAD_REQUEST,<br>        NO_RESOURCE,<br>        FORBIDDEN_REQUEST,<br>        FILE_REQUEST,<br>        INTERNAL_ERROR,<br>        CLOSED_CONNECTION<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LINE_STATUS</span> &#123;</span><br>        LINE_OK = <span class="hljs-number">0</span>,<br>        LINE_BAD,<br>        LINE_OPEN<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">http_conn</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">http_conn</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//初始化连接,外部调用初始化套接字地址</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> sockaddr_in &amp;addr,<span class="hljs-keyword">char</span>*,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                string user,string password,string sqlname)</span></span>;<br>    <span class="hljs-comment">//关闭连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close_conn</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> read_close = <span class="hljs-literal">true</span>)</span></span>;<br>    <span class="hljs-comment">//处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">read_once</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//et模式要将数据一次读完</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//写数据</span><br>    <span class="hljs-comment">//一个get，没什么特殊的</span><br>    <span class="hljs-function">sockaddr_in *<span class="hljs-title">get_address</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;m_address;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initmysql_result</span><span class="hljs-params">(connection_pool*connPool)</span></span>;<br><br>    <span class="hljs-keyword">int</span> timer_flag;<br>    <span class="hljs-keyword">int</span> improv;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_sockfd;<span class="hljs-comment">//套接子</span><br>    sockaddr_in m_address;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//初始化新接受的连接，check_state默认为分析请求状态</span><br>    <span class="hljs-function">HTTP_CODE <span class="hljs-title">process_read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">process_write</span><span class="hljs-params">(HTTP_CODE ret)</span></span>;<br>    <span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_request_line</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *text)</span></span>;<span class="hljs-comment">//解析http请求的一个头部信息，目标url及http版本号</span><br>    <span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_headers</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *text)</span></span>;<span class="hljs-comment">//解析http请求的一个头部消息</span><br>    <span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_content</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *text)</span></span>;<span class="hljs-comment">//判断http是否被完整读入</span><br>    <span class="hljs-function">HTTP_CODE <span class="hljs-title">do_request</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">get_line</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_read_buf + m_start_line; &#125;;<br>    <span class="hljs-function">LINE_STATUS <span class="hljs-title">parse_line</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//从状态机，用于分析出一行的内容，返回值为行的读取状态LINE_OK，LINE_BAD，LINE_OPEN</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unmap</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_response</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_content</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *content)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_status_line</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_headers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> content_length)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_content_type</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_content_length</span><span class="hljs-params">(<span class="hljs-keyword">int</span> content_length)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_linger</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add_blank_line</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_epollfd;<span class="hljs-comment">//epool</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_user_count;<span class="hljs-comment">//用户个数</span><br>    MYSQL *mysql;<span class="hljs-comment">//数据库</span><br>    <span class="hljs-keyword">int</span> m_state;  <span class="hljs-comment">//读为0, 写为1</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_sockfd;<span class="hljs-comment">//套接字</span><br>    sockaddr_in m_address;<span class="hljs-comment">//地址</span><br>    <span class="hljs-keyword">char</span> m_read_buf[READ_BUFFER_SIZE];<span class="hljs-comment">//可接受的数据数据（大小）</span><br>    <span class="hljs-keyword">int</span> m_read_idx;<span class="hljs-comment">//当前读的数据大小</span><br>    <span class="hljs-keyword">int</span> m_checked_idx;<br>    <span class="hljs-keyword">int</span> m_start_line;<br>    <span class="hljs-keyword">char</span> m_write_buf[WRITE_BUFFER_SIZE];<span class="hljs-comment">//可写数据大小</span><br>    <span class="hljs-keyword">int</span> m_write_idx;<span class="hljs-comment">//当前写入的数据大小</span><br>    CHECK_STATE m_check_state;<br>    METHOD m_method;<span class="hljs-comment">//GET or POST？</span><br>    <span class="hljs-keyword">char</span> m_real_file[FILENAME_LEN];<span class="hljs-comment">//请求文件的名字</span><br>    <span class="hljs-keyword">char</span> *m_url;<span class="hljs-comment">//http头部的url</span><br>    <span class="hljs-keyword">char</span> *m_version;<span class="hljs-comment">//http版本</span><br>    <span class="hljs-keyword">char</span> *m_host;<span class="hljs-comment">//http首部为host时，表示对象在的主机地址</span><br>    <span class="hljs-keyword">int</span> m_content_length;<br>    <span class="hljs-keyword">bool</span> m_linger;<span class="hljs-comment">//保持连接keep_alive,标志位</span><br>    <span class="hljs-keyword">char</span> *m_file_address;<span class="hljs-comment">//文件映射mmap 映射大小，stat.st_size</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">m_file_stat</span>;</span><span class="hljs-comment">//文件的状态 int stat(m_real_file,&amp;m_file_stat) &lt; 0return no_source;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">m_iv</span>[2];</span><br>    <span class="hljs-keyword">int</span> m_iv_count;<br>    <span class="hljs-keyword">int</span> cgi;        <span class="hljs-comment">//是否启用的POST</span><br>    <span class="hljs-keyword">char</span> *m_string; <span class="hljs-comment">//存储http中的 用户密码zhanghao</span><br>    <span class="hljs-keyword">int</span> bytes_to_send;<span class="hljs-comment">//已发送字节</span><br>    <span class="hljs-keyword">int</span> bytes_have_send;<span class="hljs-comment">//还需发送字节</span><br>    <span class="hljs-keyword">char</span> *doc_root; <span class="hljs-comment">//根目录地址</span><br><br>    map&lt;string, string&gt; m_users;<br>    <span class="hljs-keyword">int</span> m_TRIGMode;<span class="hljs-comment">//触发方式</span><br>    <span class="hljs-keyword">int</span> m_close_log;<span class="hljs-comment">//日志开关</span><br><br>    <span class="hljs-comment">//数据库临时存近来的参数</span><br>    <span class="hljs-keyword">char</span> sql_user[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">char</span> sql_passwd[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">char</span> sql_name[<span class="hljs-number">100</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>合成http报文</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_response</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    va_list arg_list;<br>    <span class="hljs-built_in">va_start</span>(arg_list, format);<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">vsnprintf</span>(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="hljs-number">1</span> - m_write_idx, format, arg_list);<br>    <span class="hljs-keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="hljs-number">1</span> - m_write_idx))<br>    &#123;<br>        <span class="hljs-built_in">va_end</span>(arg_list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    m_write_idx += len;<br>    <span class="hljs-built_in">va_end</span>(arg_list);<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;request:%s&quot;</span>, m_write_buf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_status_line</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">&quot;%s %d %s\r\n&quot;</span>, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>, status, title);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_headers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> content_len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_content_length</span>(content_len) &amp;&amp; <span class="hljs-built_in">add_linger</span>() &amp;&amp;<br>           <span class="hljs-built_in">add_blank_line</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_content_length</span><span class="hljs-params">(<span class="hljs-keyword">int</span> content_len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_content_type</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_linger</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="hljs-literal">true</span>) ? <span class="hljs-string">&quot;keep-alive&quot;</span> : <span class="hljs-string">&quot;close&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_blank_line</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">http_conn::add_content</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *content)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">&quot;%s&quot;</span>, content);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Learning</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LC周赛&&双周赛记录汇总</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">linux高性能服务器(游双著)学习笔记</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
