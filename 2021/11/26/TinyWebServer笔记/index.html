<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>TinyWebServer项目 | Chou</title><meta name="keywords" content="项目"><meta name="author" content="chou"><meta name="copyright" content="chou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="TinyWebServer项目">
<meta property="og:url" content="http://example.com/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Chou">
<meta property="og:description" content="详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/Tinyserver.png">
<meta property="article:published_time" content="2021-11-26T07:37:02.000Z">
<meta property="article:modified_time" content="2021-12-23T06:43:46.327Z">
<meta property="article:author" content="chou">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Tinyserver.png"><link rel="shortcut icon" href="/img/112.png"><link rel="canonical" href="http://example.com/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TinyWebServer项目',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-12-23 14:43:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/112.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Tinyserver.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Chou</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TinyWebServer项目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-26T07:37:02.000Z" title="Created 2021-11-26 15:37:02">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-12-23T06:43:46.327Z" title="Updated 2021-12-23 14:43:46">2021-12-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="TinyWebServer项目"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。<br><span id="more"></span></p>
<h1 id="TinyWebServer-github上的一个开源项目"><a href="#TinyWebServer-github上的一个开源项目" class="headerlink" title="TinyWebServer github上的一个开源项目"></a>TinyWebServer github上的一个开源项目</h1><p>地址：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer。">https://github.com/qinguoyi/TinyWebServer。</a></p>
<p>Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.</p>
<ul>
<li>使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型</li>
<li>使用状态机解析HTTP请求报文，支持解析GET和POST请求</li>
<li>访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件</li>
<li>实现同步/异步日志系统，记录服务器运行状态</li>
<li>经Webbench压力测试可以实现上万的并发连接数据交换</li>
</ul>
<p>框架：</p>
<p><img src="/img/11.jpg" alt="">  </p>
<h2 id="1-线程同步机制包装类Locker"><a href="#1-线程同步机制包装类Locker" class="headerlink" title="1. 线程同步机制包装类Locker"></a>1. 线程同步机制包装类Locker</h2><p>文件locker是对信号量互斥锁、条件变量的几个函数进行封装。实现多线程同步，确保任一时刻只能有一个线程进入关键代码段。</p>
<h3 id="1-1-class-sem"><a href="#1-1-class-sem" class="headerlink" title="1.1 class sem"></a>1.1 class sem</h3><ul>
<li><p>什么是是信号量</p>
<p> linux sem信号量是一种特殊的变量，访问具有原子性，用于解决进程或线程间共享资源引发的同步问题。</p>
<p> 用户态进程对sem信号量可以有以下两种操作：</p>
<ul>
<li>等待信号量, 当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。</li>
<li><p>发送信号量,将信号量加1，信号量大于0时，唤醒调用sem_pos的线程。</p>
<p>linux信号量相关函数声明头文件semaphore.h头文件中，所以使用信号量之前需要包含头文件。</p>
<blockquote>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <semaphore.h></h1></blockquote>
</li>
</ul>
</li>
<li><p>sem_init</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sem_init(sem_t *sem, int pshared, unsigned int value);
该函数初始化由sem指向信号对象，并给他一个初始的整数值value。pshared控制信号量的类型，值为0代表信号量用于多线程同步，值如果大于0表示可以共享，用于多个相关进程的同步。参数pshared&gt;0时指定了共享内存区域，所以可以在进程间共享该变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>sem_wait</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  sem_wait是一个阻塞函数，测试所指定信号量的值，他的操作时原子的，若sem value &gt; 0,则该信号量值减去1并立即返回，若sem value == 0，则阻塞直到sem value &gt; 0，此时立即减去1，然后返回。<br>  sem_trywait函数是非阻塞的函数，他会尝试获取sem value值，如果sem value == 0，不是阻塞住，而是返回一个错误EAGAIN。</p>
</li>
<li><p>sem_post</p>
<p>  把指定的信号量sem的值加1，唤醒正在等待该信号量的任意线程。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sem_post(sem_t*sem);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>sem_getvalue<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sem_getvalue(sem_t* sem,int* sval);
获取信号量sem 当前的值，把该值保存在sval，如有一个或者多个线程在调用sem_wait阻塞在该信号量上，该函数返回阻塞在该信号量上进程或线程个数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>sem_destroy</p>
<p>  该函数用于对用完的信号量的清理，它的原型如下：</p>
<blockquote>
<p>int sem_destroy(sem_t* sem);</p>
</blockquote>
</li>
</ul>
<h3 id="1-2-class-lock"><a href="#1-2-class-lock" class="headerlink" title="1.2 class lock"></a>1.2 class lock</h3><ul>
<li><p>互斥量</p>
<p>  系统中如果存在资源共享，线程中存在竞争，如果没有合理的同步机制的话，会出现数据混论现象，为了实现同步机制，其中一种就是互斥锁mutex(互斥量)。互斥锁，也称互斥量，可以保护关键代码段，以确保独占方式访问，当进入关键代码段，获得互斥锁将其加锁；离开关键代码段，唤醒等待该互斥锁的线程。<br>  在linux环境下，类型pthread_mutex_t其本质是一个结构体，一般以下面方式定义：变量mutex只有两种值1、0；</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;pthread.h&gt;
pthread_mutex_t mutex;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>pthread_mutex_init</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_mutex_init(pthread_mutex_t* restrict mutex,const pthread_mutexattr_t* restrict attr);
函数作用，初始化一个互斥锁，成功返回0，失败返回错误码。初值可视为1；mutex：传出参数，调用时应传&amp;mutex给函数；attr:互斥量属性，是一个传入参数，通常传入NULL，表示默认属性(即线程间共享)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  关键字：restrict。仅作用于指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成，不能通过除本指针以外的其他变量或指针来修改。</p>
</li>
<li>pthread_mutex_lock<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_mutex_lock(pthread_mutex_t *mutex)
获取锁，成功时返回0，如果获取失败，则该线程将阻塞，直到持有该互斥量的其他线程解锁为止,在访问共享资源前加锁，访问结束后立即解锁，锁的“粒度”应该越小越好。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>pthread_mutex_unlock<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_mutex_unlock(pthread_mutex_t*mutex);
释放锁，在释放锁的同时，会将所有阻塞的线程全部唤醒，至于哪个线程先被唤醒取决于优先级、调度。默认情况下先阻塞的线程先被唤醒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>pthread_mutex_trylock<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_mutex_trylock(pthread_mutex_t*mutex);
尝试获取锁，成功返回0，获取失败不会阻塞当前线程，而是返回一个值来描述互斥锁的状况。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>pthread_mutex_destroy</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_mutex_destroy(pthread_mutex_t *mutex);
函数作用，销毁一个互斥锁。成功返回0，失败返回错误码
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="1-3-class-cond"><a href="#1-3-class-cond" class="headerlink" title="1.3 class cond"></a>1.3 class cond</h3></li>
<li><p>条件变量</p>
<p>  与互斥锁不同，条件变量是用来等待的，而不是用来上锁的，条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。互斥锁的一个明显缺点就是他只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足。</p>
</li>
<li><p>pthread_cond_init</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_cond_init(pthread_cond_t*restrict cond,const pthread_condattr_t *restrict attr);

函数作用，初始化一个条件变量，参数说明：cond:条件变量，调用时应传&amp;cond给该函数，attr:条件变量，通常传入NULL，表示使用默认属性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>pthread_cond_wait And pthread_cond_timedwait</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;pthread.h&gt;
int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t * restric mutex);
int pthread_cond_timedwait(pthread_cond_t * restrict cond,pthread_mutex_t *restrict mutex,const struct timespec* restrict timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  成功时返回0，错误则返回错误码，这两个分别是阻塞等待和超时等待，等待条件变为真，传递给pthread_cond_wait的互斥量对条件进行保护，调用者把锁住的互斥量传给函数，函数把调用线程放到等待条件的线程列表上，然后对互斥量解锁，这两个操作是原子的。</p>
</li>
<li><p>pthread_cond_signal And pthread_cond_broadcast</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t * cond);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这两个函数用于通知线程条件已经满足，调用这个函数也称向线程或条件发送信号，必须注意一定要在改变状态以后再给线程发送信号。成功返回0，出错返回错误编号。</p>
</li>
<li><p>pthread_cond_destroy   </p>
<pre class="line-numbers language-none"><code class="language-none">int pthread_cond_destroy(pthread_cond_t*cond);  
函数作用，销毁一个条件变量。成功返回0，失败返回错误码。  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="2-同步-异步日志系统log"><a href="#2-同步-异步日志系统log" class="headerlink" title="2 .同步/异步日志系统log"></a>2 .同步/异步日志系统log</h2><h3 id="2-1block-queue-h"><a href="#2-1block-queue-h" class="headerlink" title="2.1block_queue.h"></a>2.1block_queue.h</h3><p> 循环数组实现的阻塞队列的一个模板类，从性能上考虑，没有使用STL的queue作为基本数据结构，而是使用循环数组，省去了动态内存分配和回收。线程安全，每个操作前都要先加互斥锁，操作完后，再解锁。</p>
<p>循环数组实现主要是用了以下两个式子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">m_back &#x3D; (m_back + 1) % m_max_size
m_front &#x3D; (m_front + 1)% m_max_size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>数据成员<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:
locker m_mutex; &#x2F;&#x2F;互斥锁
cond m_cond;    &#x2F;&#x2F;信号量
T *m_array;     &#x2F;&#x2F;数组指针
int m_size;     &#x2F;&#x2F;数组当前大小
int m_max_size; &#x2F;&#x2F;数组最大大小
int m_front;    &#x2F;&#x2F;数组非空最先储存元素索引
int m_back;     &#x2F;&#x2F;数组非空最后元素索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p>接口：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void clear();
bool full();
bool empty();
bool front(T &amp;value); &#x2F;&#x2F;引用的方式，这里面复制到value,数组空返回false
bool back(T &amp;value); &#x2F;&#x2F;同上
int  size();    &#x2F;&#x2F;当前大小
int max_size();
bool push(const T &amp;item);&#x2F;&#x2F;const，判断是否满了，计算下一索引m_back &#x3D; (m_back + 1) % m_max_size，赋值。
bool pop(T &amp;item); &#x2F;&#x2F;pop时如果当前队列没有元素，将会等待条件变量调用cond.wait函数，计算下一索引m_front &#x3D; (m_front + 1)% m_max_size，赋值返回。
bool pop(T &amp;item,int ms_timeout);&#x2F;&#x2F;在等待条件变量的时候加了超时处理。调用cond_timewait函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="2-2-log-h"><a href="#2-2-log-h" class="headerlink" title="2.2 log.h"></a>2.2 log.h</h3><p>在log.h声明了一个单例模式的log类，该类可设置同步异步，异步时单独开启一个线程从阻塞队列中取出日志并写入，同步时只是单独写入，要注意改变类内的一些变量(行数相关)时要上锁，每次更换文件或者阻塞队列满了都要上锁保证日志能完全正确写入。</p>
<ul>
<li><p>单例模式</p>
<ul>
<li><p>单例模式的实现</p>
<p>1.构造函数声明为private或protect防止被外部函数实例化。</p>
<p>2.提供一个全局的静态方法(全局访问点)。</p>
<p>3.内部保存一个private static的类指针保存唯一的实例，实例的动作由一个public的类方法代劳，该方法也返回单例类唯一的实例。</p>
<p>如果只是这样实现是线程不安全的，当两个线程同时访问静态方法的时候，会同时构造一个实例。</p>
</li>
</ul>
</li>
<li><p>懒汉式和饿汉式</p>
<ul>
<li><p>懒汉不到万不得已就不会去实例化类，只有在第一次使用类实例的时候才会实例化。</p>
<p>懒汉式在单例模式中的静态方法加锁就可以实现。</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class singleton &#123;
protected:
    singleton()
    &#123;
        &#x2F;&#x2F; 初始化
        pthread_mutex_init(&amp;mutex);
    &#125;
private:
    static singleton* p;
public:
    static pthread_mutex_t mutex;
    static singleton* initance();
&#125;;

pthread_mutex_t singleton::mutex;
singleton* singleton::p &#x3D; NULL;
singleton* singleton::initance()
&#123;
    if (p &#x3D;&#x3D; NULL)
    &#123;
        &#x2F;&#x2F; 加锁
        pthread_mutex_lock(&amp;mutex);
        if (p &#x3D;&#x3D; NULL)
            p &#x3D; new singleton();
        pthread_mutex_unlock(&amp;mutex);
    &#125;
    return p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>饿汉 在单例类定义的时候就进行初始化。</p>
<p>  饿汉式静态方法初始化是就实例化，而全局方法就不需要实例化了；</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singelton&#123;
private:
    Singelton()&#123;
        m_count ++;
        printf(&quot;Singelton begin\n&quot;);
        Sleep(1000);                            &#x2F;&#x2F; 加sleep为了放大效果
        printf(&quot;Singelton end\n&quot;);
    &#125;
    static Singelton *single;
public:
    static Singelton *GetSingelton();
    static void print();
    static int m_count;
&#125;;
&#x2F;&#x2F; 饿汉模式的关键：初始化即实例化
Singelton *Singelton::single &#x3D; new Singelton;
int Singelton::m_count &#x3D; 0;
Singelton *Singelton::GetSingelton()&#123;
    &#x2F;&#x2F; 不再需要进行实例化
    &#x2F;&#x2F;if(single &#x3D;&#x3D; nullptr)&#123;
    &#x2F;&#x2F;    single &#x3D; new Singelton;
    &#x2F;&#x2F;&#125;
    return single;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>类成员</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:
char dir_name[128]; &#x2F;&#x2F;路径名
char log_name[128]; &#x2F;&#x2F;log文件名
int m_split_lines;  &#x2F;&#x2F;日志最大行数
int m_log_buf_size; &#x2F;&#x2F;日志缓冲区大小
long long m_count;  &#x2F;&#x2F;日志行数记录
int m_today;        &#x2F;&#x2F;因为按天分类,记录当前时间是那一天
FILE *m_fp;         &#x2F;&#x2F;打开log的文件指针
char *m_buf;
block_queue&lt;string&gt; *m_log_queue; &#x2F;&#x2F;阻塞队列
bool m_is_async;                  &#x2F;&#x2F;是否同步标志位
locker m_mutex;
int m_close_log; &#x2F;&#x2F;关闭日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>成员函数</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public:
static Log *get_instance();&#x2F;&#x2F;单例初始化
static void *flush_log_thread(void*args);&#x2F;&#x2F;回调函数，封装void*async_write_log()
bool init(const char *file_name,int close_log,int log_buf_size &#x3D;&#x3D; 8192,int split_lines &#x3D; 5000000,int max_queue_size  &#x3D; 0);
void write_log(int level,const char *format,...);
void flush(void);&#x2F;&#x2F;强制刷新写入流缓冲区
private:
void *async_write_log();&#x2F;&#x2F;阻塞队列中取出log并写入，带锁。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在函数void write_log(int level,const char *<br>format,…)中用了省略符形参，省略符形参应该仅仅用于c和c++通用的类型，因为大多数类型的对象在传递省略形参时都无法正确拷贝。<br>使用省略符形参需要用到头文件 cstdarg下面是<cstdarg>头文件的几个宏定义：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdarg&gt;  &#x2F;&#x2F; C中是&lt;stdarg.h&gt;
&#x2F;&#x2F; va_list是一种数据类型，args用于持有可变参数。
&#x2F;&#x2F; 定义typedef char* va_list;
va_list args;

&#x2F;&#x2F; 调用va_start并传入两个参数：第一个参数为va_list类型的变量
&#x2F;&#x2F; 第二个参数为&quot;...&quot;前最后一个参数名
&#x2F;&#x2F; 将args初始化为指向第一个参数（可变参数列表）
va_start(args, paramN);

&#x2F;&#x2F; 检索参数，va_arg的第一个参数是va_list变量，第二个参数指定返回值的类型
&#x2F;&#x2F; 每一次调用va_arg会获取当前的参数，并自动更新指向下一个可变参数。
va_arg(args,type);

&#x2F;&#x2F; 释放va_list变量
va_end(args);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如如下的用法，该用法只适合c语言支持的类型。<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdarg></span></span>
<span class="token comment">//省略符型参仅仅用于c和c++通用的类型，特别应该注意的是，大多数类类型的对象在传递省略符型参都无法正确拷贝</span>
<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count is below 0!!!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//为了实现可变参数列表，首先需要声明一个va_list类型的指针，该指针用来依次指向各个参数</span>
    va_list arg_ptr<span class="token punctuation">;</span>

    <span class="token comment">//va_start是一个宏，用来初始化va_list，使其指向列表的第一个参数，va_start的第二个参数是sum函数省略符前的参数，用来固定第一个参数的位置</span>
    <span class="token function">va_start</span><span class="token punctuation">(</span>arg_ptr<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">//va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值</span>
    <span class="token comment">//va_arg宏的第二个参数是需要统计的第一个参数的类型，如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        res<span class="token operator">+=</span><span class="token function">va_arg</span><span class="token punctuation">(</span>arg_ptr<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//将va_list类型的指针复位成空值</span>
    <span class="token comment">//就是清空可变参数列表</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>arg_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//return 15</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在对log内容的操作中，log日志类用的是fopen函数，fopen 和open的区别主要有以下：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include&lt;stdio.h&gt;
EILE *fopen(const char *path,const char *mode);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p>
<ul>
<li><p>mode指定文件打开的方式：  </p>
<ul>
<li>r：只读方式打开一个文本文件（该文件必须存在）  </li>
<li>r+：可读可写方式打开一个文本文件（该文件必须存在）  </li>
<li>w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）  </li>
<li>w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）  </li>
<li>a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））  </li>
<li>a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））  </li>
</ul>
</li>
<li><p>a 和 a+ 的区别：a 不能读，a+ 可以读  </p>
<ul>
<li>rb：只读方式打开一个二进制文件（使用法则同r）  </li>
<li>rb+：可读可写方式打开一个二进制文件（使用法则同r+）  </li>
<li>wb：只写方式打开一个二进制文件（使用法则同w）  </li>
<li>wb+：可读可写方式生成一个二进制文件（使用法则同w+）  </li>
<li>ab：追加方式打开一个二进制文件（使用法则同a）  </li>
<li>ab+：可读可写方式追加一个二进制文件（使用法则同a+）  </li>
</ul>
</li>
</ul>
<p>返回值，fopen()返回的是一个FILE类型的指针，若打开失败返回NULL。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys&#x2F;types.h&gt;
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;fcntl.h&gt;
int open(const char*pathname, int flags);
int open(const char*pathname, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>flag用于指定文件打开/创建的方式，这个参数可由以下三个互斥的常量(定义于fcntl.h)，通过逻辑或连接。<ul>
<li>O_RDONLY  只读  </li>
<li>O_WRONLY  只写  </li>
<li>O_RDWR    读写<br>返回值，open返回的是一个文件描述符，打开失败返回-1。</li>
</ul>
</li>
</ul>
<p>区别<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">open属于低级IO，fopen属于高级IO<span class="token punctuation">;</span>
前者返回一个文件描述符，后者返回一个指针；
前者无缓冲，后者有缓冲；
前者与read,write等配合使用，后者与fread,fwrite使用；
后者是在前者的基础上扩充而来的，在大多数情况下，用后者；
fopen是c库中的函数，而open是linux中的系统调用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p>c库函数strrchr():<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token operator">--</span>C字符串
c  <span class="token operator">--</span>要搜索的字符，以<span class="token keyword">int</span>形式传递，但是最终回转回<span class="token keyword">char</span>形式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>在本项目中主要是用来分割路径‘/’和文件名的位置(找到文件名)；<br>c库函数snprintf()<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">snprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//设将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，    </span>
    s<span class="token comment">//ize 为要写入的字符的最大数目，超过 size 会被截断</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>log_full_name<span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">"%d_%d_%02d_%s"</span><span class="token punctuation">,</span>my_tm<span class="token punctuation">.</span>tm_year <span class="token operator">+</span> <span class="token number">1900</span><span class="token punctuation">,</span>
                 my_tm<span class="token punctuation">.</span>tm_mon<span class="token punctuation">,</span>my_tm<span class="token punctuation">.</span>tm_mday<span class="token punctuation">,</span>file_name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>c库函数strcpy()和strncpy()<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//将src所指向的字符串复制到dest</span>
<span class="token keyword">char</span><span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span>dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//把src所指向的字符串复制到dest最多复制n个字符。当src的长度小于n时，dest的剩余部分将用空字节填充</span>
<span class="token keyword">char</span><span class="token operator">*</span><span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span>dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>src<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p>
<h2 id="3-线程池-半同步-半反应堆线程池"><a href="#3-线程池-半同步-半反应堆线程池" class="headerlink" title="3 .线程池 半同步/半反应堆线程池"></a>3 .线程池 半同步/半反应堆线程池</h2><p>补充知识：  </p>
<h3 id="半同步-半异步模型-HSHA"><a href="#半同步-半异步模型-HSHA" class="headerlink" title="半同步/半异步模型 HSHA"></a>半同步/半异步模型 HSHA</h3><ul>
<li>什么是线程池<br>线程池是服务器预先创建的一组线程，这些线程运行着相同的代码，当新任务到来时，主线程通过某种方式选择线程池中的某一个线程来为之服务，服务完之后又放回线程池(其实就是阻塞和唤醒)。  </li>
<li>为什么需要线程池<br>相比于动态创建线程来说，线程池可以提高速度，因为线程的创建和销毁是要时间的。如果频繁的线程创建和销毁线程是非常消耗内核资源的。  </li>
<li>什么是半同步/半异步<br>[半同步/半异步]模式，(half-sync/halt-async,以下就简称HSHA)，主要分三层：<pre class="line-numbers language-none"><code class="language-none">异步IO(主线程);
队列层(任务队列)；
同步处理层(线程池)；  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
异步IO与同步处理</li>
</ul>
<ul>
<li>所谓同步：在客户端连接，请求数据，以及向队列中写入数据的时候是异步的。在写入完成可能会执行预设的回调函数，进行预处理和其他通知操作，也便是Proactor模式。  </li>
<li>关于异步IO，严重依赖内核的支持，比如window的IOCP就是公认的不错的异步IO实现，而Linux的AIO系列内部还是用多线程来模拟，实则伪异步，epool不是异步IO，因为要遍历发生变化的FD然后循环将数据读完。  </li>
<li>所谓同步：在线程池中，工作线程从任务队列中每次取出任务，其具体的业务逻辑是同步的，虽然在消费队列的时候是多线程，但是并不会多个线程处理一次请求。  </li>
</ul>
<p>半同步/半异步模型 HSHA是工作线程负责异步地从客户端fd获取客户端的请求数据，而工作线程则是并发的对该数据进行处理，工作线程不关心客户端fd，不关心通信，而IO线程不关心处理过程。    </p>
<h3 id="半同步-半反应堆模型-HSHR"><a href="#半同步-半反应堆模型-HSHR" class="headerlink" title="半同步/半反应堆模型 HSHR"></a>半同步/半反应堆模型 HSHR</h3><ul>
<li>HSHA模式十分依赖异步IO，然而实现真正异步通常比较困难，IO多路复用技术的发展带给人们新思路，用IO多路复用代替异步IO，对HAHS进行改造。这就是半同步半反应堆模型(Half-Sync/Halt-Reactor,HSHR);  </li>
</ul>
<p>半同步/半反应堆模型 HSHR ，主线程只监听socket,当监测到服务器sock可读，就会进行accept,获得fd放入队列。也就是说与HSHA不同，HSHR的队列放的不是请求数据，而是fd，工作线程从队列中取的不是数据，而是客户端fd。和HSHA不同，HSHR将IO的过程侵入到了工作线程中。工作线程的逻辑循环内从队列取道fd后，对fd进行read/recv获取请求数据，然后进行处理，最后直接write/send客户端fd，将数据返回给客户端。可以看来，这种IO的方式是一种Reactor模式，这就是该模型中半反应堆一词的由来。</p>
<p>工作队列  </p>
<blockquote>
<p>工作线程消费队列数据的方式  </p>
<ul>
<li>和一般的队列模型相同，分为推和拉的两种模型，通常HSHA为推模型，需要一个条件变量来实现。即队列尚无数据，则工作线程阻塞休眠，等待数据产生，而当IO线程将数据写入任务队列的时候，则会唤醒休眠的工作线程来处理；拉模型即不再需要条件变量，工作线程内作死循环，不停轮训队列数据。两种模型各有利弊，如果是IO密集型的，比如并发度特别高，以至于总能取到数据，那么就不需要推模型。</li>
</ul>
</blockquote>
<p>本项目用的是半同步半反应堆模式，http连接放进队列中。然后由工作线程来取任务。<br>实现细节：</p>
<p>数据成员：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class xxx&#123;
private:
    int m_thread_number;        &#x2F;&#x2F;线程池中的线程数
    int m_max_requests;         &#x2F;&#x2F;请求队列中允许的最大请求数
    pthread_t *m_threads;       &#x2F;&#x2F;描述线程池的数组，其大小为m_thread_number
    std::list&lt;T *&gt; m_workqueue; &#x2F;&#x2F;请求队列
    locker m_queuelocker;       &#x2F;&#x2F;保护请求队列的互斥锁
    sem m_queuestat;            &#x2F;&#x2F;是否有任务需要处理
    connection_pool *m_connPool;  &#x2F;&#x2F;数据库
    int m_actor_model;          &#x2F;&#x2F;模型切换
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>成员函数：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class xxx&#123;
public:
    &#x2F;*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*&#x2F;
    threadpool(int actor_model, connection_pool *connPool, int thread_number &#x3D; 8, int max_request &#x3D; 10000);
    ~threadpool();
    bool append(T *request, int state);
    bool append_p(T *request);

private:
    &#x2F;*工作线程运行的函数，它不断从工作队列中取出任务并执行之*&#x2F;
    static void *worker(void *arg);
    void run();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在本项目中的用的是模板类<del>其实没必要</del>。如果要将声明和实现分开的话需要在头文件中实例化，否则编译不过去。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;要在cpp文件加上，这样的一句，将模板类实例化以用来多文件编译
template class threadpool&lt;mDate&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>在构造函数中，构造线程数组时，将线程分离，使用:<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;分离线程，自己回收无需父线程回收
pthread_detach(id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p>
<h2 id="4-校验-amp-数据库连接池"><a href="#4-校验-amp-数据库连接池" class="headerlink" title="4 .校验 &amp; 数据库连接池"></a>4 .校验 &amp; 数据库连接池</h2><p>补充知识：</p>
<p>分配或初始化mysql_real_connect()相适应的MYSQL对象，如果指针是NULL指针，该函数将分配，初始化并返回新对象。否则<br>将初始化对像，并返回对象的地址，如果mysql_init()分配了新对象，当调用mysql_close()来关闭连接时，将释放对象。初始化句柄，出现无足够内存时，返回NULL。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL *mysql_init(MYSQL*mysql);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>
<ul>
<li>mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须;成功完成。参数的指定方式如下：</li>
</ul>
<ul>
<li>第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。请参见25.2.3.48节，“mysql_options()”。</li>
<li>“host”的值必须是主机名或IP地址。如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP/IP连接到服务器。</li>
<li>“user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串””，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名。请参见26.1.9.2节，“在Windows上配置MyODBC DSN”。</li>
<li>“passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</li>
<li>注释：调用mysql_real_connect()之前，不要尝试加密密码，密码加密将由客户端API自动处理。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
数据库连接池</li>
<li>单例模式，保证唯一</li>
<li>list实现连接池</li>
<li>连接池为静态大小</li>
<li>互斥锁实现线程安全</li>
</ul>
<p>校验</p>
<ul>
<li>HTTP请求采用POST方式</li>
<li>登录用户名和密码校验</li>
<li>用户注册及多线程注册安全</li>
</ul>
<p>因为这项目的数据库是写死的，所以所有连接的数据库的名字，数据库端口什么都一样，所以就创建一个数据库连接池，让不会因为销毁连接创建连接而消耗额外的资源。</p>
<p>数据成员</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:
    int m_MaxConn;  &#x2F;&#x2F;最大连接数
 int m_CurConn;  &#x2F;&#x2F;当前已使用的连接数
 int m_FreeConn; &#x2F;&#x2F;当前空闲的连接数
 locker lock;
 list&lt;MYSQL *&gt; connList; &#x2F;&#x2F;连接池
 sem reserve;

public:
 string m_url;			 &#x2F;&#x2F;主机地址
 string m_Port;		 &#x2F;&#x2F;数据库端口号
 string m_User;		 &#x2F;&#x2F;登陆数据库用户名
 string m_PassWord;	 &#x2F;&#x2F;登陆数据库密码
 string m_DatabaseName; &#x2F;&#x2F;使用数据库名
 int m_close_log;	&#x2F;&#x2F;日志开关<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>成员函数<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public:
    MYSQL* GetConnection();     &#x2F;&#x2F;获取数据库连接
    bool ReleaseConnection(MYSQL *conn); &#x2F;&#x2F;释放连接
    int GetFreeConn();              &#x2F;&#x2F;获取连接
    void DestroyPool();             &#x2F;&#x2F;销毁所有连接

    &#x2F;&#x2F;单例模式
    static connection_pool * GetInstance();
    void init(string url, string User, string PassWord, string DataBaseName, int Port, int MaxConn, int close_log);
private:
    connection_pool();
    ~connection_pool();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>初始化mysql,信号量初始化成m_FreeConn(m_MaxConn)；<br>当有请求的时候，在数据库连接池中返回一个可用连接，更新使用和空闲连接数，注意在取连接和更新空闲连接数的时候要使用锁。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool connection_pool::ReleaseConnection(MYSQL *con) &#123;
 MYSQL *con &#x3D; NULL;
 if (0 &#x3D;&#x3D; connList.size())
  return NULL;
 reserve.wait(); &#x2F;&#x2F;如果信号量不可用 阻塞
 lock.lock();
 con &#x3D; connList.front();
 connList.pop_front();
 --m_FreeConn;
 ++m_CurConn;
 lock.unlock();
 return con;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>释放连接的时候，压入连接池和改变可用空闲个数的时候也需要上锁，上锁之后不要忘了更新信号量(+1)。</p>
<p>在销毁数据库连接池的整个过程都要持有锁。<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void connection_pool::DestroyPool() &#123;

 lock.lock();
 if (connList.size() &gt; 0)
 &#123;
  list&lt;MYSQL *&gt;::iterator it;
  for (it &#x3D; connList.begin(); it !&#x3D; connList.end(); ++it)
  &#123;
   MYSQL *con &#x3D; *it;
   mysql_close(con);
  &#125;  
  m_CurConn &#x3D; 0;
  m_FreeConn &#x3D; 0;
  connList.clear();
 &#125;

 lock.unlock();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h2 id="5-http连接处理类"><a href="#5-http连接处理类" class="headerlink" title="5. http连接处理类"></a>5. http连接处理类</h2><p>根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机</p>
<blockquote>
<ul>
<li>客户端发出http连接请求</li>
<li>从状态机读取数据,更新自身状态和接收数据,传给主状态机</li>
<li>主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取</li>
</ul>
</blockquote>
<p>补充知识：<br>recv函数<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int recv(SOCKET s,char *buf,int len,int flags);

&#x2F;&#x2F;s     标识已连接套接字的描述符
&#x2F;&#x2F;buf   指向缓冲区的指针，以接受传入的数据
&#x2F;&#x2F;len   buf参数指向缓冲区的长度一般是参数二-1，留出&quot;\0&quot;
&#x2F;&#x2F;flags 一组影响此功能行为的标志

返回值：  
1. 成功执行，返回接受到的字节数  
2. 另一端已关闭，则返回0  
3. 失败返回-1，errno被设为以下的某一个值  
* EAGAIN:套接字已标记为非阻塞，而接收操作被阻塞或者接受超时，  
* EBADF：sock不是有效的描述符，  
* ECONNREFUSE：远程主机阻绝网络连接  
* EFAULT：内存空间访问出错，  
* EINTR：操作被信号中断，  
* EINVAL：参数无效，  
* ENOMEM：内存不足，  
* ENOTCONN：面向连接的套接字尚未被连接上，  
* ENOTSOCK：sock索引的不是套接字，当返回的值是0，为正常关闭连接。  
特别的：  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>用到的C库函数<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;C 库函数 char *strpbrk(const char *str1, const char *str2) 检索字符串 str1 中第一个匹配字符串 
&#x2F;&#x2F;str2,中字符的字符不包含空结束字符也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，
&#x2F;&#x2F;则停止检验，并返回该字符位置。
char *strpbrk(const char *str1,const char  *str2);  


&#x2F;&#x2F;检索字符串参数是否相等，忽略大小写,两字符串相同返回0，s1大于s2返回大于0值，反之返回小于0值
int strcasecmp(const char *s1,const char *s2);

&#x2F;&#x2F;检索str1中第一个不在字符串str2中出现的字符下标
size_t strspn(const char * str1,const char* str2);

&#x2F;&#x2F;返回iu字符串str中第一次出现字符c的位置，如果未找到返回null,c会转换成字符
char *strchr(const char *str, int c)；

&#x2F;&#x2F;把src所指向的字符串追加到dest所指向的字符串的结尾
char *strcat(char *dest,const char *src);

&#96;&#96;&#96;   
linux文件相关部分函数
&#96;&#96;&#96;c++
#include&lt;sys&#x2F;stat.h&gt;
#include&lt;unistd.h&gt;
&#x2F;&#x2F;通过文件名file_name获取文件信息，并保存在buf所指的结构体stat中
&#x2F;&#x2F;成功返回0，失败返回-1
int stat(const char *file_name,struct stat *buf);

&#x2F;&#x2F;stat 结构体，如果保护模式不是S——IROTH,返回FORBIDDEN——REQUEST
struct stat
&#123;
    dev_t       st_dev;     &#x2F;* ID of device containing file -文件所在设备的ID*&#x2F;
    ino_t       st_ino;     &#x2F;* inode number -inode节点号*&#x2F;
    mode_t      st_mode;    &#x2F;* protection -保护模式?*&#x2F;
    nlink_t     st_nlink;   &#x2F;* number of hard links -链向此文件的连接数(硬连接)*&#x2F;
    uid_t       st_uid;     &#x2F;* user ID of owner -user id*&#x2F;
    gid_t       st_gid;     &#x2F;* group ID of owner - group id*&#x2F;
    dev_t       st_rdev;    &#x2F;* device ID (if special file) -设备号，针对设备文件*&#x2F;
    off_t       st_size;    &#x2F;* total size, in bytes -文件大小，字节为单位*&#x2F;
    blksize_t   st_blksize; &#x2F;* blocksize for filesystem I&#x2F;O -系统块的大小*&#x2F;
    blkcnt_t    st_blocks;  &#x2F;* number of blocks allocated -文件所占块数*&#x2F;
    time_t      st_atime;   &#x2F;* time of last access -最近存取时间*&#x2F;
    time_t      st_mtime;   &#x2F;* time of last modification -最近修改时间*&#x2F;
    time_t      st_ctime;   &#x2F;* time of last status change - *&#x2F;
&#125;;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>http请求报文：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">GET     &#x2F;sonmedir&#x2F;page.html     HTTP&#x2F;1.1
Host:   www.someschool.edu
Connection:     close
User_agent: Mozilla&#x2F;5.0
Accept-language:    fr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该项目的请求有以下几种：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">0 注册
1 登陆
2 选择
3 注册之后跳转的登录界面
5 看图片
6 看视频
7 关注页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>http_conn.h中成员和成员函数如下：<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class http_conn &#123;
public:

    static const int FILENAME_LEN &#x3D; 200;  &#x2F;&#x2F;文件名字长度
    static const int READ_BUFFER_SIZE &#x3D; 2048;   &#x2F;&#x2F;每次读取数据长度
    static const int WRITE_BUFFER_SIZE &#x3D; 1024;  &#x2F;&#x2F;每次写的长度

    enum METHOD &#123;&#x2F;&#x2F;行为
        GET &#x3D; 0,
        POST,
        HEAD,
        PUT,
        DELETE,
        TRACE,
        OPTIONS,
        CONNECT,
        PATH
    &#125;;
    enum CHECK_STATE &#123;&#x2F;&#x2F;状态
        CHECK_STATE_REQUESTLINE &#x3D; 0,
        CHECK_STATE_HEADER,
        CHECK_STATE_CONTENE
    &#125;;
    enum HTTP_CODE &#123;
        NO_REQUEST,
        GET_REQUEST,
        BAD_REQUEST,
        NO_RESOURCE,
        FORBIDDEN_REQUEST,
        FILE_REQUEST,
        INTERNAL_ERROR,
        CLOSED_CONNECTION
    &#125;;
    enum LINE_STATUS &#123;
        LINE_OK &#x3D; 0,
        LINE_BAD,
        LINE_OPEN
    &#125;;
public:
    http_conn() &#123;&#125;
    ~http_conn() &#123;&#125;
public:
    &#x2F;&#x2F;初始化连接,外部调用初始化套接字地址
    void init(int sockfd,const sockaddr_in &amp;addr,char*,int,int,
                string user,string password,string sqlname);
    &#x2F;&#x2F;关闭连接
    void close_conn(bool read_close &#x3D; true);
    &#x2F;&#x2F;处理
    void process();
    
    bool read_once();&#x2F;&#x2F;et模式要将数据一次读完
    bool write();&#x2F;&#x2F;写数据
    &#x2F;&#x2F;一个get，没什么特殊的
    sockaddr_in *get_address() &#123;
        return &amp;m_address;
    &#125;
    void initmysql_result(connection_pool*connPool);

    int timer_flag;
    int improv;

private:
    int m_sockfd;&#x2F;&#x2F;套接子
    sockaddr_in m_address;

private:
    void init();&#x2F;&#x2F;初始化新接受的连接，check_state默认为分析请求状态
    HTTP_CODE process_read();
    bool process_write(HTTP_CODE ret);
    HTTP_CODE parse_request_line(char *text);&#x2F;&#x2F;解析http请求的一个头部信息，目标url及http版本号
    HTTP_CODE parse_headers(char *text);&#x2F;&#x2F;解析http请求的一个头部消息
    HTTP_CODE parse_content(char *text);&#x2F;&#x2F;判断http是否被完整读入
    HTTP_CODE do_request();
    char *get_line() &#123; return m_read_buf + m_start_line; &#125;;
    LINE_STATUS parse_line();&#x2F;&#x2F;从状态机，用于分析出一行的内容，返回值为行的读取状态LINE_OK，LINE_BAD，LINE_OPEN
    void unmap();


    bool add_response(const char *format, ...);
    bool add_content(const char *content);
    bool add_status_line(int status, const char *title);
    bool add_headers(int content_length);
    bool add_content_type();
    bool add_content_length(int content_length);
    bool add_linger();
    bool add_blank_line();

public:
    static int m_epollfd;&#x2F;&#x2F;epool
    static int m_user_count;&#x2F;&#x2F;用户个数
    MYSQL *mysql;&#x2F;&#x2F;数据库
    int m_state;  &#x2F;&#x2F;读为0, 写为1

private:
    int m_sockfd;&#x2F;&#x2F;套接字
    sockaddr_in m_address;&#x2F;&#x2F;地址
    char m_read_buf[READ_BUFFER_SIZE];&#x2F;&#x2F;可接受的数据数据（大小）
    int m_read_idx;&#x2F;&#x2F;当前读的数据大小
    int m_checked_idx;
    int m_start_line;
    char m_write_buf[WRITE_BUFFER_SIZE];&#x2F;&#x2F;可写数据大小
    int m_write_idx;&#x2F;&#x2F;当前写入的数据大小
    CHECK_STATE m_check_state;
    METHOD m_method;&#x2F;&#x2F;GET or POST？
    char m_real_file[FILENAME_LEN];&#x2F;&#x2F;请求文件的名字
    char *m_url;&#x2F;&#x2F;http头部的url
    char *m_version;&#x2F;&#x2F;http版本
    char *m_host;&#x2F;&#x2F;http首部为host时，表示对象在的主机地址
    int m_content_length;
    bool m_linger;&#x2F;&#x2F;保持连接keep_alive,标志位
    char *m_file_address;&#x2F;&#x2F;文件映射mmap 映射大小，stat.st_size
    struct stat m_file_stat;&#x2F;&#x2F;文件的状态 int stat(m_real_file,&amp;m_file_stat) &lt; 0return no_source;
    struct iovec m_iv[2];
    int m_iv_count;
    int cgi;        &#x2F;&#x2F;是否启用的POST
    char *m_string; &#x2F;&#x2F;存储http中的 用户密码zhanghao
    int bytes_to_send;&#x2F;&#x2F;已发送字节
    int bytes_have_send;&#x2F;&#x2F;还需发送字节
    char *doc_root; &#x2F;&#x2F;根目录地址

    map&lt;string, string&gt; m_users;
    int m_TRIGMode;&#x2F;&#x2F;触发方式
    int m_close_log;&#x2F;&#x2F;日志开关

    &#x2F;&#x2F;数据库临时存近来的参数
    char sql_user[100];
    char sql_passwd[100];
    char sql_name[100];
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p>合成http报文<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool http_conn::add_response(const char *format, ...)
&#123;
    if (m_write_idx &gt;&#x3D; WRITE_BUFFER_SIZE)
        return false;
    va_list arg_list;
    va_start(arg_list, format);
    int len &#x3D; vsnprintf(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list);
    if (len &gt;&#x3D; (WRITE_BUFFER_SIZE - 1 - m_write_idx))
    &#123;
        va_end(arg_list);
        return false;
    &#125;
    m_write_idx +&#x3D; len;
    va_end(arg_list);

    LOG_INFO(&quot;request:%s&quot;, m_write_buf);

    return true;
&#125;

bool http_conn::add_status_line(int status, const char *title)
&#123;
    return add_response(&quot;%s %d %s\r\n&quot;, &quot;HTTP&#x2F;1.1&quot;, status, title);
&#125;
bool http_conn::add_headers(int content_len)
&#123;
    return add_content_length(content_len) &amp;&amp; add_linger() &amp;&amp;
           add_blank_line();
&#125;
bool http_conn::add_content_length(int content_len)
&#123;
    return add_response(&quot;Content-Length:%d\r\n&quot;, content_len);
&#125;
bool http_conn::add_content_type()
&#123;
    return add_response(&quot;Content-Type:%s\r\n&quot;, &quot;text&#x2F;html&quot;);
&#125;
bool http_conn::add_linger()
&#123;
    return add_response(&quot;Connection:%s\r\n&quot;, (m_linger &#x3D;&#x3D; true) ? &quot;keep-alive&quot; : &quot;close&quot;);
&#125;
bool http_conn::add_blank_line()
&#123;
    return add_response(&quot;%s&quot;, &quot;\r\n&quot;);
&#125;
bool http_conn::add_content(const char *content)
&#123;
    return add_response(&quot;%s&quot;, content);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>Learning</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">chou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/">http://example.com/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post_share"><div class="social-share" data-image="/img/Tinyserver.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/"><img class="prev-cover" src="/img/55.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">LC周赛&amp;&amp;双周赛记录</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">linux高性能服务器笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/11/24/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="STL源码剖析"><img class="cover" src="/img/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-24</div><div class="title">STL源码剖析</div></div></a></div><div><a href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="linux高性能服务器笔记"><img class="cover" src="/img/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">linux高性能服务器笔记</div></div></a></div><div><a href="/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="moduo项目/读书笔记"><img class="cover" src="/img/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">moduo项目/读书笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/112.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chou</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TinyWebServer-github%E4%B8%8A%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">TinyWebServer github上的一个开源项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8C%85%E8%A3%85%E7%B1%BBLocker"><span class="toc-number">1.1.</span> <span class="toc-text">1. 线程同步机制包装类Locker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-class-sem"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 class sem</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">2.</span> <span class="toc-text">include </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-class-lock"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.2 class lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-class-cond"><span class="toc-number">2.0.2.</span> <span class="toc-text">1.3 class cond</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9Flog"><span class="toc-number">2.1.</span> <span class="toc-text">2 .同步&#x2F;异步日志系统log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1block-queue-h"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1block_queue.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-log-h"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.2 log.h</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.2.</span> <span class="toc-text">3 .线程池 半同步&#x2F;半反应堆线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B-HSHA"><span class="toc-number">2.2.1.</span> <span class="toc-text">半同步&#x2F;半异步模型 HSHA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B-HSHR"><span class="toc-number">2.2.2.</span> <span class="toc-text">半同步&#x2F;半反应堆模型 HSHR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A0%A1%E9%AA%8C-amp-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">2.3.</span> <span class="toc-text">4 .校验 &amp; 数据库连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-http%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">5. http连接处理类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/" title="LC周赛&amp;&amp;双周赛记录"><img src="/img/55.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LC周赛&amp;&amp;双周赛记录"/></a><div class="content"><a class="title" href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/" title="LC周赛&amp;&amp;双周赛记录">LC周赛&amp;&amp;双周赛记录</a><time datetime="2021-12-16T07:37:02.000Z" title="Created 2021-12-16 15:37:02">2021-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/" title="TinyWebServer项目"><img src="/img/Tinyserver.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TinyWebServer项目"/></a><div class="content"><a class="title" href="/2021/11/26/TinyWebServer%E7%AC%94%E8%AE%B0/" title="TinyWebServer项目">TinyWebServer项目</a><time datetime="2021-11-26T07:37:02.000Z" title="Created 2021-11-26 15:37:02">2021-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="linux高性能服务器笔记"><img src="/img/13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux高性能服务器笔记"/></a><div class="content"><a class="title" href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="linux高性能服务器笔记">linux高性能服务器笔记</a><time datetime="2021-11-25T07:37:02.000Z" title="Created 2021-11-25 15:37:02">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="moduo项目/读书笔记"><img src="/img/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="moduo项目/读书笔记"/></a><div class="content"><a class="title" href="/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="moduo项目/读书笔记">moduo项目/读书笔记</a><time datetime="2021-11-25T07:37:02.000Z" title="Created 2021-11-25 15:37:02">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="现代操作系统学习笔记"><img src="/img/17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代操作系统学习笔记"/></a><div class="content"><a class="title" href="/2021/11/25/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" title="现代操作系统学习笔记">现代操作系统学习笔记</a><time datetime="2021-11-25T07:37:02.000Z" title="Created 2021-11-25 15:37:02">2021-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By chou</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>