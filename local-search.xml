<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC周赛&amp;&amp;双周赛记录汇总</title>
    <link href="/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2021/12/16/leetcode%E5%91%A8%E8%B5%9Band%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>人菜瘾又大！刷题and周赛and数据结构，记录全部参加的周赛，记录的意义在于记录本身。<br>最新的会放在前面。</p><span id="more"></span><h2 id="加油！！！-目前AK几次，起飞，大部分三题。。。"><a href="#加油！！！-目前AK几次，起飞，大部分三题。。。" class="headerlink" title="加油！！！ 目前AK几次，起飞，大部分三题。。。"></a>加油！！！ <del>目前AK几次，起飞</del>，大部分三题。。。</h2><p>目前knight。<del>转码人也想拿Guardian</del>。 刚开始的太拉<del>没学也要迫不及待挨打</del>的场次就不记录了，自己偷偷记本子上了 <del>(主要是丢人)</del>。  </p><h2 id="toc《M的数据结构与算法笔记》"><a href="#toc《M的数据结构与算法笔记》" class="headerlink" title="toc《M的数据结构与算法笔记》"></a>toc《M的数据结构与算法笔记》</h2><h2 id="272场双周赛-2020-12-19"><a href="#272场双周赛-2020-12-19" class="headerlink" title="272场双周赛 2020-12-19"></a>272场双周赛 2020-12-19</h2><h3 id="第一题-easy"><a href="#第一题-easy" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="找出数组中第一个回文字符串"><a href="#找出数组中第一个回文字符串" class="headerlink" title="找出数组中第一个回文字符串"></a><a href="https://leetcode-cn.com/problems/find-first-palindromic-string-in-the-array/">找出数组中第一个回文字符串</a></h4><p>给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 “” 。<br>回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串<br>直接找就行   </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">firstPalindrome</span><span class="hljs-params">(vector&lt;string&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            string tt = s[i];<br>            <span class="hljs-built_in">reverse</span>(tt.<span class="hljs-built_in">begin</span>(),tt.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">if</span>(tt == s[i])<span class="hljs-keyword">return</span> tt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium"><a href="#第二题-Medium" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="向字符串添加空格"><a href="#向字符串添加空格" class="headerlink" title="向字符串添加空格"></a><a href="https://leetcode-cn.com/problems/adding-spaces-to-a-string/">向字符串添加空格</a></h4><p>给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。<br>数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。<br>例如，s = “EnjoyYourCoffee” 且 spaces = [5, 9] ，那么我们需要在 ‘Y’ 和 ‘C’ 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 “Enjoy Your Coffee” 。<br>请你添加空格，并返回修改后的字符串。<br>spaces 中的所有值 严格递增  </p><p>调整长度，后续遍历就行，注意spaces也要更改。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addSpaces</span><span class="hljs-params">(string s, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; spaces)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = spaces.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; spaces.<span class="hljs-built_in">size</span>();i++)spaces[i]+=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(k&gt;=<span class="hljs-number">0</span>&amp;&amp;i == spaces[k]) &#123;<br>                s[i] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                k--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                s[i] = s[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium"><a href="#第三题-Medium" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="股票平滑下降的"><a href="#股票平滑下降的" class="headerlink" title="股票平滑下降的"></a><a href="https://leetcode-cn.com/problems/watering-plants-ii/">股票平滑下降的</a></h4><p>给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。<br>一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。<br>请你返回 平滑下降阶段 的数目。  </p><p>示例 1：<br>输入：prices = [3,2,1,4]<br>输出：7<br>解释：总共有 7 个平滑下降阶段：<br>[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]<br>注意，仅一天按照定义也是平滑下降阶段。<br>示例 2：<br>输入：prices = [8,6,7,7]<br>输出：4<br>解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]<br>由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。<br>示例 3：<br>输入：prices = [1]<br>输出：1<br>解释：总共有 1 个平滑下降阶段：[1]   </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDescentPeriods</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = p.<span class="hljs-built_in">size</span>();<br>        p.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">back</span>()+<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = n;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n+<span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(p[i] - p[i - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) &#123;<br>                temp++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// printf(&quot;%d %d\n&quot;,temp,i);</span><br>                res += (temp*(temp+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>;<br>                temp = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard"><a href="#第四题-Hard" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="使数组K递增的最少操作次数"><a href="#使数组K递增的最少操作次数" class="headerlink" title="使数组K递增的最少操作次数"></a><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/">使数组K递增的最少操作次数</a></h4><p>给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。<br>如果对于每个满足 k &lt;= i &lt;= n-1 的下标 i ，都有 arr[i-k] &lt;= arr[i] ，那么我们称 arr 是 K 递增 的。<br>比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为：<br>arr[0] &lt;= arr[2] (4 &lt;= 5)<br>arr[1] &lt;= arr[3] (1 &lt;= 2)<br>arr[2] &lt;= arr[4] (5 &lt;= 6)<br>arr[3] &lt;= arr[5] (2 &lt;= 2)<br>但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] &gt; arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] &gt; arr[3] ）。<br>每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。<br>请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。   </p><p>最长递增子序列模板题，二分就行，一遍二分就行<del>当时找模板的时候慌了</del>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kIncreasing</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = arr.<span class="hljs-built_in">size</span>(),res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l+(r - l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid,arr,k)) &#123;<br>                res = mid;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <br>     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid ,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>  n = (<span class="hljs-keyword">int</span>)nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; k;j++)&#123;<br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n/k+<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>            temp[len] = nums[j];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = j+k; i &lt; n; i+=k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= temp[len]) &#123;<br>                temp[++len] = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = len, pos = <span class="hljs-number">0</span>; <br>                <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (temp[mid] &lt;= nums[i]) &#123;<br>                        pos = mid;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[mid] &gt; nums[i])&#123;<br>                        right = mid - <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                temp[pos + <span class="hljs-number">1</span>] = nums[i];<br>            &#125;<br>        &#125;<br>            res += len ;<br>     &#125;<br>        <span class="hljs-keyword">return</span> n - res &lt;= mid; <br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!  </p><h2 id="271场周赛-2021-12-12"><a href="#271场周赛-2021-12-12" class="headerlink" title="271场周赛   2021-12-12"></a>271场周赛   2021-12-12</h2><h3 id="第一题-easy-1"><a href="#第一题-easy-1" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="环和杆"><a href="#环和杆" class="headerlink" title="环和杆"></a><a href="https://leetcode-cn.com/problems/rings-and-rods/">环和杆</a></h4><p>总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。<br>给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：<br>第 i 对中的 第一个 字符表示第 i 个环的 颜色（’R’、’G’、’B’）。<br>第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（’0’ 到 ‘9’）。<br>例如，”R3G2B1” 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。<br>找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。</p><p>哈希表加位运算。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPoints</span><span class="hljs-params">(string rings)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; rings.<span class="hljs-built_in">size</span>();i+=<span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(rings[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;R&#x27;</span>)k = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rings[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;G&#x27;</span>)k =<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span> k = <span class="hljs-number">4</span>;<br>            map[rings[i]]= (map[rings[i]]|k);<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = map.<span class="hljs-built_in">begin</span>();i!=map.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second == <span class="hljs-number">7</span>)res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-1"><a href="#第二题-Medium-1" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="子数组范围和"><a href="#子数组范围和" class="headerlink" title="子数组范围和"></a><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/">子数组范围和</a></h4><p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。<br>返回 nums 中 所有 子数组范围的 和 。<br>子数组是数组中一个连续 非空 的元素序列。</p><p>直接暴力，记录开始位置，长度增长，维护一个最大一个最小值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">subArrayRanges</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">int</span> mmin = nums[i],mmax = nums[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++) &#123;<br>                mmin = <span class="hljs-built_in">min</span>(mmin,nums[j]),mmax = <span class="hljs-built_in">max</span>(mmax,nums[j]);<br>                res += mmax - mmin;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-1"><a href="#第三题-Medium-1" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="给植物浇水II"><a href="#给植物浇水II" class="headerlink" title="给植物浇水II"></a><a href="https://leetcode-cn.com/problems/watering-plants-ii/">给植物浇水II</a></h4><p>Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。<br>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：<br> Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。<br>如果没有足够的水 完全 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。<br>不管植物需要多少水，浇水所耗费的时间都是一样的。<br>不能 提前重新灌满水罐。<br>每株植物都可以由 Alice 或者 Bob 来浇水。<br>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。<br>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。</p><p>模拟就行。。简单题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumRefill</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; s, <span class="hljs-keyword">int</span> A, <span class="hljs-keyword">int</span> B)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> cura = A,curb = B;<br>        <span class="hljs-keyword">while</span>(i&lt;j) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt; cura) &#123;<br>                cura = A - s[i];<br>                res++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cura = cura  - s[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[j] &gt; curb) &#123;<br>                curb = B - s[j];<br>                res++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curb = curb - s[j];<br>            &#125;<br>            i++;j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==j) &#123;<br>            <span class="hljs-keyword">if</span>(s[i]&gt;<span class="hljs-built_in">max</span>(cura,curb))res++;<br>            i++;j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-1"><a href="#第四题-Hard-1" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="摘水果"><a href="#摘水果" class="headerlink" title="摘水果"></a><a href="https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/">摘水果</a></h4><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。<br>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。<br>返回你可以摘到水果的 最大总数 </p><p>有个路径走两次，有一个路径走一次，模拟就行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxTotalFruits</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; fruits, <span class="hljs-keyword">int</span> startPos, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;<span class="hljs-built_in">f</span>(<span class="hljs-number">200001</span>);<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; fruits.<span class="hljs-built_in">size</span>();i++) &#123;<br>            map[fruits[i][<span class="hljs-number">0</span>]] = fruits[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>  i =  <span class="hljs-number">0</span>;i&lt;  <span class="hljs-number">200001</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; fruits.<span class="hljs-built_in">size</span>()&amp;&amp;fruits[j][<span class="hljs-number">0</span>] == i) &#123;<br>                f[i]+=fruits[j][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>                    f[i]+=f[i - <span class="hljs-number">1</span>];<br>                &#125;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>                f[i] = f[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= startPos&amp;&amp;i&lt;=k/<span class="hljs-number">2</span>;i++) &#123;<br>            <span class="hljs-keyword">int</span> left = k - <span class="hljs-number">2</span>*(i)+startPos&lt;<span class="hljs-number">200000</span>? k - <span class="hljs-number">2</span>*(i)+startPos:<span class="hljs-number">200000</span>;<br>            <span class="hljs-keyword">int</span> aa = f[left] - f[startPos - i];<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(startPos - i) != map.<span class="hljs-built_in">end</span>()) &#123;<br>                aa+=map[startPos - i];<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res,aa);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= startPos&amp;&amp;i&lt;=k;i++) &#123;<br>            <span class="hljs-keyword">int</span> left = (k - i)/<span class="hljs-number">2</span>+startPos&lt;<span class="hljs-number">200000</span>?(k - i)/<span class="hljs-number">2</span>+startPos:<span class="hljs-number">200000</span>;<br>            <span class="hljs-keyword">int</span> aa = f[left] - f[startPos - i];<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(startPos - i) != map.<span class="hljs-built_in">end</span>()) &#123;<br>                aa+=map[startPos - i];<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res,aa);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="66场双周赛-2021-11-27"><a href="#66场双周赛-2021-11-27" class="headerlink" title="66场双周赛 2021-11-27"></a>66场双周赛 2021-11-27</h2><h3 id="第一题-easy-2"><a href="#第一题-easy-2" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="统计出现过一次的公共字符串"><a href="#统计出现过一次的公共字符串" class="headerlink" title="统计出现过一次的公共字符串"></a><a href="https://leetcode-cn.com/problems/count-common-words-with-one-occurrence/">统计出现过一次的公共字符串</a></h4><p>给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; s, vector&lt;string&gt;&amp; ss)</span> </span>&#123;<br>        unordered_map&lt;string ,<span class="hljs-keyword">int</span>&gt; map;<br>        unordered_map&lt;string ,<span class="hljs-keyword">int</span>&gt; map2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            map[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ss.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            map2[ss[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i= map.<span class="hljs-built_in">begin</span>();i!=map.<span class="hljs-built_in">end</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second!=<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(map2[i-&gt;first]==<span class="hljs-number">1</span>)res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-2"><a href="#第二题-Medium-2" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="从房屋收集需要的最少水桶数"><a href="#从房屋收集需要的最少水桶数" class="headerlink" title="从房屋收集需要的最少水桶数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/">从房屋收集需要的最少水桶数</a></h4><p>给你一个下标从 0 开始的字符串 street 。street 中每个字符要么是表示房屋的 ‘H’ ，要么是表示空位的 ‘.’ 。<br>你可以在 空位 放置水桶，从相邻的房屋收集雨水。位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。<br>在确保 每个 房屋旁边都 至少 有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。<br>示例 1：<br>输入：street = “H..H”<br>输出：2<br>解释：<br>我们可以在下标为 1 和 2 处放水桶。<br>“H..H” -&gt; “HBBH”（’B’ 表示放置水桶）。<br>下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。<br>所以每个房屋旁边都至少有一个水桶收集雨水。</p><p>示例 2：<br>输入：street = “.H.H.”<br>输出：1<br>解释：<br>我们可以在下标为 2 处放置一个水桶。<br>“.H.H.” -&gt; “.HBH.”（’B’ 表示放置水桶）。<br>下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。<br>所以每个房屋旁边都至少有一个水桶收集雨水。</p><p>示例 3：<br>输入：street = “.HHH.”<br>输出：-1<br>解释：<br>没有空位可以放置水桶收集下标为 2 处的雨水。<br>所以没有办法收集所有房屋的雨水。</p><p>示例 4：<br>输入：street = “H”<br>输出：-1<br>解释：<br>没有空位放置水桶。<br>所以没有办法收集所有房屋的雨水。</p><p>示例 5：<br>输入：street = “.”<br>输出：0<br>解释：<br>没有房屋需要收集雨水。<br>所以需要 0 个水桶。</p><p>先放一个桶可以接两个房屋的，然后再放其他的，比赛时代码很蠢。。。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumBuckets</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;H&#x27;</span>&amp;&amp;s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;H&#x27;</span>&amp;&amp;s[i]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                res++;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>                s[i+<span class="hljs-number">1</span>]  = <span class="hljs-string">&#x27;o&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] ==<span class="hljs-string">&#x27;H&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] ==<span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    res++;<br>                    s[i] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>&amp;&amp;s[i]==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>                    res++;<br>                    s[i]=<span class="hljs-string">&#x27;o&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;H&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-2"><a href="#第三题-Medium-2" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="网格图中机器人回家的最小代价"><a href="#网格图中机器人回家的最小代价" class="headerlink" title="网格图中机器人回家的最小代价"></a><a href="https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/">网格图中机器人回家的最小代价</a></h4><p>给你一个 m x n 的网格图，其中 (0, 0) 是最左上角的格子，(m - 1, n - 1) 是最右下角的格子。给你一个整数数组 startPos ，startPos = [startrow, startcol] 表示 初始 有一个 机器人 在格子 (startrow, startcol) 处。同时给你一个整数数组 homePos ，homePos = [homerow, homecol] 表示机器人的 家 在格子 (homerow, homecol) 处。</p><p>机器人需要回家。每一步它可以往四个方向移动：上，下，左，右，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从 0 开始的额整数数组：长度为 m 的数组 rowCosts  和长度为 n 的数组 colCosts 。</p><p>如果机器人往 上 或者往 下 移动到第 r 行 的格子，那么代价为 rowCosts[r] 。<br>如果机器人往 左 或者往 右 移动到第 c 列 的格子，那么代价为 colCosts[c] 。<br>请你返回机器人回家需要的 最小总代价 </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; s, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; h, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; r, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; c)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rr</span><span class="hljs-params">(r.size(),<span class="hljs-number">0</span>)</span>,<span class="hljs-title">cc</span><span class="hljs-params">(c.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; r.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>                rr[i] = r[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                rr[i] = r[i] + rr[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; c.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>                cc[i] = c[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cc[i] = c[i] + cc[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">abs</span>(rr[s[<span class="hljs-number">0</span>]] - rr[h[<span class="hljs-number">0</span>]]) + <span class="hljs-built_in">abs</span>(cc[s[<span class="hljs-number">1</span>]] - cc[h[<span class="hljs-number">1</span>]]);<br>        <span class="hljs-keyword">if</span>(h[<span class="hljs-number">0</span>] &lt; s[<span class="hljs-number">0</span>])&#123;<br>            res+=r[h[<span class="hljs-number">0</span>]] - r[s[<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(h[<span class="hljs-number">1</span>]&lt;s[<span class="hljs-number">1</span>]) &#123;<br>            res+=c[h[<span class="hljs-number">1</span>]] - c[s[<span class="hljs-number">1</span>]];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-2"><a href="#第四题-Hard-2" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="统计农场中肥沃金字塔的数目"><a href="#统计农场中肥沃金字塔的数目" class="headerlink" title="统计农场中肥沃金字塔的数目"></a><a href="https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/">统计农场中肥沃金字塔的数目</a></h4><p>有一个 矩形网格 状的农场，划分为 m 行 n 列的单元格。每个格子要么是 肥沃的 （用 1 表示），要么是 贫瘠 的（用 0 表示）。网格图以外的所有与格子都视为贫瘠的。<br>农场中的 金字塔 区域定义如下：<br>区域内格子数目 大于 1 且所有格子都是 肥沃的 。<br>金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r &lt;= i &lt;= r + h - 1 且 c - (i - r) &lt;= j &lt;= c + (i - r) 。<br>一个 倒金字塔 类似定义如下：<br>区域内格子数目 大于 1 且所有格子都是 肥沃的 。<br>倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r - h + 1 &lt;= i &lt;= r 且 c - (r - i) &lt;= j &lt;= c + (r - i) 。<br>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。<br><img src="/img/22.jpg"><br>动态规划，记录金字塔的顶端，金字塔顶端的下面三个块可以组成金字塔的话，这个顶端一定可以组成一个比下面底层更高的塔+和底层三个(最少那个)一样多一样高的塔。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPyramids</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = grid.<span class="hljs-built_in">size</span>(),m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">temp</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">temp2</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//正着</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; m - <span class="hljs-number">1</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>&amp;&amp;grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>&amp;&amp;grid[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>&amp;&amp;grid[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    temp[i][j] = <span class="hljs-built_in">min</span>(temp[i + <span class="hljs-number">1</span>][j],<span class="hljs-built_in">min</span>(temp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>],temp[i + <span class="hljs-number">1</span>][j+ <span class="hljs-number">1</span>]))+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//倒着</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; m - <span class="hljs-number">1</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>&amp;&amp;grid[i  - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>&amp;&amp;grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>&amp;&amp;grid[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    temp2[i][j] = <span class="hljs-built_in">min</span>(temp2[i - <span class="hljs-number">1</span>][j],<span class="hljs-built_in">min</span>(temp2[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>],temp2[i - <span class="hljs-number">1</span>][j+ <span class="hljs-number">1</span>]))+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++) &#123;<br>                res+=temp[i][j]+temp2[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="268场周赛-2021-11-21"><a href="#268场周赛-2021-11-21" class="headerlink" title="268场周赛 2021-11-21"></a>268场周赛 2021-11-21</h2><h3 id="第一题-easy-3"><a href="#第一题-easy-3" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="两栋颜色不同且距离最远的房子"><a href="#两栋颜色不同且距离最远的房子" class="headerlink" title="两栋颜色不同且距离最远的房子"></a><a href="https://leetcode-cn.com/problems/two-furthest-houses-with-different-colors/">两栋颜色不同且距离最远的房子</a></h4><p>街上有 n 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 0 开始且长度为 n 的整数数组 colors ，其中 colors[i] 表示第  i 栋房子的颜色。<br>返回 两栋 颜色 不同 房子之间的 最大 距离。<br>第 i 栋房子和第 j 栋房子之间的距离是 abs(i - j) ，其中 abs(x) 是 x 的绝对值。</p><p>暴力，哈希表记录每种颜色最左的下标就行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; c)</span> </span>&#123;<br>     unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; c.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j=map.<span class="hljs-built_in">begin</span>();j!=map.<span class="hljs-built_in">end</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(j-&gt;first!=c[i]) &#123;<br>                    res = <span class="hljs-built_in">max</span>(res,i-j-&gt;second);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(c[i]) == map.<span class="hljs-built_in">end</span>())&#123;<br>                map[c[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-3"><a href="#第二题-Medium-3" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="给植物浇水"><a href="#给植物浇水" class="headerlink" title="给植物浇水"></a><a href="https://leetcode-cn.com/problems/watering-plants/">给植物浇水</a></h4><p>你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。<br>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p><ul><li>按从左到右的顺序给植物浇水。</li><li>在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li><li>你 不能 提前重新灌满水罐。<br>最初，你在河边（也就是，x = -1），在 x 轴上每移动 一个单位 都需要 一步 。<br>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。</li></ul><p>输入：plants = [2,2,3,3], capacity = 5<br>输出：14<br>解释：从河边开始，此时水罐是装满的：</p><ul><li>走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。</li><li>走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。</li><li>由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。</li><li>走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。</li><li>由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。</li><li>走到植物 3 (4 步) ，浇水。<br>需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。</li></ul><p>输入：plants = [1,1,1,4,2,3], capacity = 4<br>输出：30<br>解释：从河边开始，此时水罐是装满的：</p><ul><li>走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。</li><li>走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。</li><li>走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。</li><li>走到植物 5 (6 步) ，浇水。<br>需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 </li></ul><p>输入：plants = [7,7,7,7,7,7,7], capacity = 8<br>输出：49<br>解释：每次浇水都需要重新灌满水罐。<br>需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wateringPlants</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; p, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>,cur = c,f = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; p.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(cur &gt;= p[i]) &#123;<br>                cur -=p[i];<br>                res++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res+=<span class="hljs-number">2</span>*(i)+<span class="hljs-number">1</span>;<br>                cur = c - p[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-3"><a href="#第三题-Medium-3" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="区间内查询数字的频率"><a href="#区间内查询数字的频率" class="headerlink" title="区间内查询数字的频率"></a><a href="https://leetcode-cn.com/problems/range-frequency-queries/">区间内查询数字的频率</a></h4><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。<br>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。<br>请你实现 RangeFreqQuery 类：</p><ul><li>RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。</li><li>int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。<br>一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</li></ul><p>昨天做了一个题 叫快照数组的，和这个原理差不多，记录每个数字出现的下表，存在unordered_map&lt;int,vector<int>&gt; map;中，两次二分查找，这两个下标的距离就是个数。复杂度(logn);<br>前缀和的方式会超时，构造前缀和的时候复杂度已经（n*n),还有的就是二分的时候要引用，传值在拷贝vector<int>开销很大，也会超时。</p><p>输入：<br>[“RangeFreqQuery”, “query”, “query”]<br>[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]<br>输出：<br>[null, 1, 2]<br>解释：<br>RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);<br>rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。<br>rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RangeFreqQuery</span> &#123;</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RangeFreqQuery</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-built_in">size</span>();i++) &#123;<br>            map[arr[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(value) == map.<span class="hljs-built_in">end</span>())<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">find_min</span>(left,map[value]),r = <span class="hljs-built_in">find_max</span>(right,map[value]);<br>        <span class="hljs-keyword">return</span> r - l;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ll,vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,res = r;<br>        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l+(r - l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid]&gt;=ll) &#123;<br>                res = <span class="hljs-built_in">min</span>(res,mid);<br>                r = mid<span class="hljs-number">-1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ll,vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l+(r - l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid]&lt;= ll) &#123;<br>                res = <span class="hljs-built_in">max</span>(res,mid);<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RangeFreqQuery object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RangeFreqQuery* obj = new RangeFreqQuery(arr);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;query(left,right,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-3"><a href="#第四题-Hard-3" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="K镜像数字的和"><a href="#K镜像数字的和" class="headerlink" title="K镜像数字的和"></a><a href="https://leetcode-cn.com/problems/sum-of-k-mirror-numbers/">K镜像数字的和</a></h4><p>一个 k 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 0 的 正 整数。</p><ul><li>比方说，9 是一个 2 镜像数字。9 在十进制下为 9 ，二进制下为 1001 ，两者从前往后读和从后往前读都一样。</li><li>相反地，4 不是一个 2 镜像数字。4 在二进制下为 100 ，从前往后和从后往前读不相同。<br>给你进制 k 和一个数字 n ，请你返回 k 镜像数字中 最小 的 n 个数 之和 。</li></ul><p>输入：k = 2, n = 5<br>输出：25<br>解释：<br>最小的 5 个 2 镜像数字和它们的二进制表示如下：<br>  十进制       二进制<br>    1          1<br>    3          11<br>    5          101<br>    7          111<br>    9          1001<br>它们的和为 1 + 3 + 5 + 7 + 9 = 25 。</p><p>输入：k = 3, n = 7<br>输出：499<br>解释：<br>7 个最小的 3 镜像数字和它们的三进制表示如下：<br>  十进制       三进制<br>    1          1<br>    2          2<br>    4          11<br>    8          22<br>    121        11111<br>    151        12121<br>    212        21212<br>它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。</p><p>抄了关注的一个c++大佬的代码，贴一下。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kMirror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> check = [](<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num, <span class="hljs-keyword">int</span> k) -&gt; <span class="hljs-keyword">bool</span> &#123;<br>            string s;<br>            <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>                s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + num % k);<br>                num /= k;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; ++i, --j) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> reverse = [](<span class="hljs-keyword">int</span> num) -&gt; <span class="hljs-keyword">int</span> &#123;<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>                ret = ret * <span class="hljs-number">10</span> + num % <span class="hljs-number">10</span>;<br>                num /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(i, k)) &#123;<br>                ret += i;<br>                n--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; n &gt; <span class="hljs-number">0</span>; ++i) &#123;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, i);<br>            <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt; r &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++j) &#123;<br>                <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num = <span class="hljs-number">1LL</span> * r * j + <span class="hljs-built_in">reverse</span>(j);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(num, k)) &#123;<br>                    ret += num;<br>                    n--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt; r &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">10</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++t) &#123;<br>                    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num = <span class="hljs-number">1LL</span> * r * j * <span class="hljs-number">10</span> + <span class="hljs-number">1LL</span> * r * t + <span class="hljs-built_in">reverse</span>(j);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(num, k)) &#123;<br>                        ret += num;<br>                        n--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="267场周赛-2021-11-14"><a href="#267场周赛-2021-11-14" class="headerlink" title="267场周赛 2021-11-14"></a>267场周赛 2021-11-14</h2><h3 id="第一题-easy-4"><a href="#第一题-easy-4" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="买票需要的时间"><a href="#买票需要的时间" class="headerlink" title="买票需要的时间"></a><a href="https://leetcode-cn.com/problems/time-needed-to-buy-tickets/">买票需要的时间</a></h4><p>有 n 个人前来排队买票，其中第 0 人站在队伍 最前方 ，第 (n - 1) 人站在队伍 最后方 。<br>给你一个下标从 0 开始的整数数组 tickets ，数组长度为 n ，其中第 i 人想要购买的票数为 tickets[i] 。<br>每个人买票都需要用掉 恰好 1 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。<br>返回位于位置 k（下标从 0 开始）的人完成买票需要的时间（以秒为单位）。</p><p>直接计算，在位置k前的人要排min(tickets[i],tickets[k]),后面的人需要排min(tickets[i],tickets[k] - 1)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">timeRequiredToBuy</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; t, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> aa = t[k];<br>        <span class="hljs-keyword">int</span> res =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; t.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; k) &#123;<br>                res+=<span class="hljs-built_in">min</span>(aa - <span class="hljs-number">1</span>,t[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res+=<span class="hljs-built_in">min</span>(aa,t[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-4"><a href="#第二题-Medium-4" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="反转偶数链表长度的节点"><a href="#反转偶数链表长度的节点" class="headerlink" title="反转偶数链表长度的节点"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups/">反转偶数链表长度的节点</a></h4><p>给你一个链表的头节点 head 。<br>链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列（1, 2, 3, 4, …）。一个组的 长度 就是组中分配到的节点数目。换句话说：</p><ul><li>节点 1 分配给第一组</li><li>节点 2 和 3 分配给第二组</li><li>节点 4、5 和 6 分配给第三组，以此类推<br>注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。<br>反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 head </li></ul><p>直接存到vector中，这样不会出错。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseEvenLengthGroups</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;vector&lt;ListNode*&gt;&gt;temp;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>) &#123;<br>            vector&lt;ListNode*&gt;kk;<br>            <span class="hljs-keyword">int</span> ll = k;<br>            <span class="hljs-keyword">while</span>(ll&gt;<span class="hljs-number">0</span>&amp;&amp;head!=<span class="hljs-literal">nullptr</span>) &#123;<br>                kk.<span class="hljs-built_in">push_back</span>(head);<br>                head=head-&gt;next;<br>                ll--;<br>            &#125;<br>            temp.<span class="hljs-built_in">push_back</span>(kk);<br>            k++;<br>        &#125;<br>        ListNode*res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode*last = res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; temp.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(temp[i].<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(temp[i].<span class="hljs-built_in">begin</span>(),temp[i].<span class="hljs-built_in">end</span>());<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt; temp[i].<span class="hljs-built_in">size</span>();j++) &#123;<br>                last -&gt;next = temp[i][j];<br>                last = temp[i][j];<br>            &#125;<br>        &#125;<br>        last-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> res-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-4"><a href="#第三题-Medium-4" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="解码斜向换位密码"><a href="#解码斜向换位密码" class="headerlink" title="解码斜向换位密码"></a><a href="https://leetcode-cn.com/problems/decode-the-slanted-ciphertext/">解码斜向换位密码</a></h4><p>字符串 originalText 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 encodedText 。<br>originalText 先按从左上到右下的方式放置到矩阵中。<br>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 originalText 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ‘ ‘ 进行填充。矩阵的列数需满足：用 originalText 填充之后，最右侧列 不为空 。</p><p>先分层，然后在计算宽度，最后把末尾空格去掉。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeCiphertext</span><span class="hljs-params">(string e, <span class="hljs-keyword">int</span> rows)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = e.<span class="hljs-built_in">size</span>()/rows;<br>        vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt; <span class="hljs-built_in">temp</span>(rows,vector&lt;<span class="hljs-keyword">char</span>&gt;(m));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; e.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp[i/m][i - i/m*m] = e[i];<br>        &#125;<br>        string res ;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;temp.<span class="hljs-built_in">size</span>();j++)&#123;<br>            temp[j].<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =temp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(temp[j][i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                flag =<span class="hljs-built_in">max</span>(flag,i) ;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= flag;i++) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; rows;j++) &#123;<br>                    <span class="hljs-keyword">if</span>(j+i&lt;temp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>                    res.<span class="hljs-built_in">push_back</span>(temp[j][j+i]);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(res[i] == <span class="hljs-string">&#x27; &#x27;</span>)res.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-4"><a href="#第四题-Hard-4" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="处理含限制条件的好友请求"><a href="#处理含限制条件的好友请求" class="headerlink" title="处理含限制条件的好友请求"></a><a href="https://leetcode-cn.com/problems/process-restricted-friend-requests/">处理含限制条件的好友请求</a></h4><p>给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。<br>给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。<br>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。<br>如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。<br>返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。<br>注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p><p>当时在想各种优化各种map，其实就是一个并查集，然后暴力判断合并的人和这个小团体的黑名单的人所在集是否相同就行了。<br>没做出来，午觉醒来补写出来了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; f;<br>    <span class="hljs-built_in">UF</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x == f[x] ? x: f[x] = <span class="hljs-built_in">F</span>(f[x]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">U</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x ,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        f[<span class="hljs-built_in">F</span>(x)] = <span class="hljs-built_in">F</span>(y);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">friendRequests</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; req)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,unordered_set&lt;<span class="hljs-keyword">int</span>&gt;&gt; map;<br>        <span class="hljs-function">UF <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.<span class="hljs-built_in">size</span>();i++) &#123;<br>            map[res[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(res[i][<span class="hljs-number">1</span>]);<br>            map[res[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">insert</span>(res[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt;ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; req.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt;u00;<br>            <span class="hljs-keyword">int</span> u0 = a.<span class="hljs-built_in">F</span>(req[i][<span class="hljs-number">0</span>]),u1 = a.<span class="hljs-built_in">F</span>(req[i][<span class="hljs-number">1</span>]);<br>        <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; a.f.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">F</span>(j) == u0) &#123;<br>                    u00.<span class="hljs-built_in">push_back</span>(j);<br>                &#125;<br>            &#125;<br>        <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; u00.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> kk:map[u00[j]]) &#123;<br>                    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">F</span>(kk) == u1) &#123;<br>                        flag = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                a.<span class="hljs-built_in">U</span>(req[i][<span class="hljs-number">0</span>],req[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(flag);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="265场周赛-2021-10-31"><a href="#265场周赛-2021-10-31" class="headerlink" title="265场周赛 2021-10-31"></a>265场周赛 2021-10-31</h2><h3 id="第一题-easy-5"><a href="#第一题-easy-5" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="值相等的最小索引"><a href="#值相等的最小索引" class="headerlink" title="值相等的最小索引"></a><a href="https://leetcode-cn.com/problems/smallest-index-with-equal-value/">值相等的最小索引</a></h4><p>给你一个下标从 0 开始的整数数组 nums ，返回 nums 中满足 i mod 10 == nums[i] 的最小下标 i ；如果不存在这样的下标，返回 -1 。<br>x mod y 表示 x 除以 y 的 余数 。</p><p>直接写，第一次看错题</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">smallestEqual</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span> == nums[i])<span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-5"><a href="#第二题-Medium-5" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="找出临界点之间的最小和最大距离"><a href="#找出临界点之间的最小和最大距离" class="headerlink" title="找出临界点之间的最小和最大距离"></a><a href="https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/">找出临界点之间的最小和最大距离</a></h4><p>链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。<br>如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个  局部极大值点 。<br>如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个  局部极小值点 。<br>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。<br>给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。</p><p>我以为是不同极值点之间的距离，然后就被wa了，原来是不区分的。。。。<br>先用数组存起来，然后记录+排序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nodesBetweenCriticalPoints</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; maxx;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; temp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(temp[i]&gt;temp[i - <span class="hljs-number">1</span>]&amp;&amp;temp[i]&gt;temp[i+<span class="hljs-number">1</span>]) &#123;<br>                maxx.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i]&lt;temp[i - <span class="hljs-number">1</span>]&amp;&amp;temp[i]&lt;temp[i+<span class="hljs-number">1</span>]) &#123;<br>                maxx.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans=&#123;INT_MAX,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-built_in">sort</span>(maxx.<span class="hljs-built_in">begin</span>(),maxx.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(maxx.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; maxx.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>            ans[<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(maxx[i + <span class="hljs-number">1</span>] - maxx[i],ans[<span class="hljs-number">0</span>]);<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = maxx.<span class="hljs-built_in">back</span>() - maxx[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-5"><a href="#第三题-Medium-5" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="转化数字的最小运算数"><a href="#转化数字的最小运算数" class="headerlink" title="转化数字的最小运算数"></a><a href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></h4><p>给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。<br>整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算：<br>如果 0 &lt;= x &lt;= 1000 ，那么，对于数组中的任一下标 i（0 &lt;= i &lt; nums.length），可以将 x 设为下述任一值：</p><ul><li>x + nums[i]</li><li>x - nums[i]</li><li>x ^ nums[i]（按位异或 XOR）<br>注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 &lt;= x &lt;= 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。<br>返回将 x = start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。</li></ul><p>bfs就可以，但是要剪枝，不然妥妥超时。</p><ul><li>剪枝1.用set保存，出现过相同的值就不用放进queue了。</li><li>剪枝2.先检查是否是0=&lt;x&lt;=1000再放进queue。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; set;<br>        set.<span class="hljs-built_in">insert</span>(start);<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> ss = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(ss--) &#123;<br>                <span class="hljs-keyword">int</span> tt = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tt == goal)<span class="hljs-keyword">return</span> k;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tt&lt;<span class="hljs-number">0</span>||tt&gt;<span class="hljs-number">1000</span>)<span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>                    <span class="hljs-keyword">int</span> a = tt +nums[i];<br>                    <span class="hljs-keyword">int</span> b = tt - nums[i];<br>                    <span class="hljs-keyword">int</span> c = tt^nums[i];<br>                    <span class="hljs-keyword">if</span>(a == goal||b==goal||c == goal)<span class="hljs-keyword">return</span> k+<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(a)==set.<span class="hljs-built_in">end</span>()&amp;&amp;a&gt;=<span class="hljs-number">0</span>&amp;&amp;a&lt;=<span class="hljs-number">1000</span>) &#123;<br>                        set.<span class="hljs-built_in">insert</span>(a);<br>                        q.<span class="hljs-built_in">push</span>(a);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(b)==set.<span class="hljs-built_in">end</span>()&amp;&amp;b&gt;=<span class="hljs-number">0</span>&amp;&amp;b&lt;=<span class="hljs-number">1000</span>) &#123;<br>                        set.<span class="hljs-built_in">insert</span>(b);<br>                        q.<span class="hljs-built_in">push</span>(b);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(c) == set.<span class="hljs-built_in">end</span>()&amp;&amp;c&gt;=<span class="hljs-number">0</span>&amp;&amp;c&lt;=<span class="hljs-number">1000</span>) &#123;<br>                        set.<span class="hljs-built_in">insert</span>(c);<br>                        q.<span class="hljs-built_in">push</span>(c);<br>                    &#125;<br>                &#125; <br>            &#125;<br>             k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-5"><a href="#第四题-Hard-5" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="同源字符串检测"><a href="#同源字符串检测" class="headerlink" title="同源字符串检测"></a><a href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/">同源字符串检测</a></h4><p>原字符串由小写字母组成，可以按下述步骤编码：<br>任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。<br>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。<br>重新 顺次连接 序列，得到编码后的字符串。<br>例如，编码 “abcdefghijklmnop” 的一种方法可以描述为：<br>将原字符串分割得到一个序列：[“ab”, “cdefghijklmn”, “o”, “p”] 。<br>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 [“ab”, “12”, “1”, “p”] 。<br>重新顺次连接序列中的元素，得到编码后的字符串：”ab121p” 。<br>给你两个编码后的字符串 s1 和 s2 ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 s1 和 s2 原字符串，返回 true ；否则，返回 false。<br>注意：生成的测试用例满足 s1 和 s2 中连续数字数不超过 3 。</p><p>输入：s1 = “internationalization”, s2 = “i18n”<br>输出：true<br>解释：”internationalization” 可以作为原字符串</p><ul><li>“internationalization”<br>-&gt; 分割：      [“internationalization”]<br>-&gt; 不替换任何元素<br>-&gt; 连接：      “internationalization”，得到 s1</li><li>“internationalization”<br>-&gt; 分割：      [“i”, “nternationalizatio”, “n”]<br>-&gt; 替换：      [“i”, “18”,                 “n”]<br>-&gt; 连接：      “i18n”，得到 s2</li></ul><p>输入：s1 = “l123e”, s2 = “44”<br>输出：true<br>解释：”leetcode” 可以作为原字符串</p><ul><li>“leetcode”<br>-&gt; 分割：       [“l”, “e”, “et”, “cod”, “e”]<br>-&gt; 替换：       [“l”, “1”, “2”,  “3”,   “e”]<br>-&gt; 连接：       “l123e”，得到 s1</li><li>“leetcode”<br>-&gt; 分割：       [“leet”, “code”]<br>-&gt; 替换：       [“4”,    “4”]<br>-&gt; 连接：       “44”，得到 s2</li></ul><p>输入：s1 = “112s”, s2 = “g841”<br>输出：true<br>解释：”gaaaaaaaaaaaas” 可以作为原字符串</p><ul><li>“gaaaaaaaaaaaas”<br>-&gt; 分割：       [“g”, “aaaaaaaaaaaa”, “s”]<br>-&gt; 替换：       [“1”, “12”,           “s”]<br>-&gt; 连接：       “112s”，得到 s1</li><li>“gaaaaaaaaaaaas”<br>-&gt; 分割：       [“g”, “aaaaaaaa”, “aaaa”, “s”]<br>-&gt; 替换：       [“g”, “8”,        “4”,    “1”]<br>-&gt; 连接         “g841”，得到 s2</li></ul><p>输入：s1 = “ab”, s2 = “a2”<br>输出：false<br>解释：不存在这样的原字符串</p><ul><li>编码为 s1 的字符串由两个字母组成</li><li>编码为 s2 的字符串由三个字母组成</li></ul><p>我直接上来一套bfs，检测将数字分割得到不同长度的串，再比较在相同位置的已给出的字母是否相同。写了很多过110/211就超时了。<br>贴下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; a;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; b;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">possiblyEquals</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> k =<span class="hljs-number">0</span>,kk = <span class="hljs-number">0</span>;<br>        string ss1 = s1,ss2 = s2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s1[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s1[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>                ss1[i] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                k++;<br>            &#125;<br>        <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s2[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s2[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>                ss2[i] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                kk++;<br>            &#125;<br>        &#125;<br>        vector&lt;string&gt; dt1 = <span class="hljs-built_in">getString</span>(ss1),dt2 = <span class="hljs-built_in">getString</span>(ss2);<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;kkk,mm;<br>        <span class="hljs-built_in">check</span>(s1,dt1,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,kkk,a);<br>        <span class="hljs-built_in">check</span>(s2,dt2,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,mm,b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; b.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(a[i].<span class="hljs-built_in">back</span>() == b[j].<span class="hljs-built_in">back</span>()) &#123;<br>                   flag |= <span class="hljs-built_in">helper</span>(a[i],b[j],s1,s2);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;aa,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;bb,string&amp; s1,string&amp; s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> xx = <span class="hljs-number">0</span>,yy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;i&lt; s1.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;s2.<span class="hljs-built_in">size</span>();) &#123;<br>            <span class="hljs-keyword">while</span>(i&lt; s1.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;s2.<span class="hljs-built_in">size</span>()&amp;&amp;!(s1[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s1[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>))&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i&lt; s1.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;s2.<span class="hljs-built_in">size</span>()&amp;&amp;!(s2[j]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s2[j]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>))&#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt; s1.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;s2.<span class="hljs-built_in">size</span>()&amp;&amp;xx&lt;aa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>&amp;&amp;yy&lt;bb.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>&amp;&amp;aa[xx]==bb[yy]&amp;&amp;s1[i]!=s2[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>            j++;<br>            xx++;<br>            yy++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(string &amp;s1,vector&lt;string&gt;&amp;dt1,<span class="hljs-keyword">int</span> cur,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> j,vector&lt;<span class="hljs-keyword">int</span>&gt; kk,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp;oo)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(level == s1.<span class="hljs-built_in">size</span>()) &#123;<br>            kk.<span class="hljs-built_in">push_back</span>(cur);<br>            oo.<span class="hljs-built_in">push_back</span>(kk);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s1[level]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s1[level]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>            cur++;<br>            kk.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-built_in">check</span>(s1,dt1,cur,level+<span class="hljs-number">1</span>,j,kk,oo);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; ll = <span class="hljs-built_in">get</span>(dt1[j]);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k&lt;ll.<span class="hljs-built_in">size</span>();k++) &#123;<br>                <span class="hljs-built_in">check</span>(s1,dt1,cur+ll[k],level+dt1[j].<span class="hljs-built_in">size</span>(),j+<span class="hljs-number">1</span>,kk,oo);<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">get</span>(string&amp; s) &#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()== <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>&#123;&#125;;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> &#123;s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;0&#x27;</span>&#125;;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span> +s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>,(s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+s[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">int</span> a = s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>+ s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>+ s[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">int</span> b = s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>+ ((s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+ s[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">int</span> c = (s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+ s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>+ s[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">int</span> d = (s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">100</span>+ (s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+ s[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">return</span> &#123;a,b,c,d&#125;;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getString</span><span class="hljs-params">(string&amp; word)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        string result;<br>        <span class="hljs-function">stringstream <span class="hljs-title">input</span><span class="hljs-params">(word)</span></span>;<br>        <span class="hljs-keyword">while</span> (input &gt;&gt; result) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="264场周赛-2021-10-24"><a href="#264场周赛-2021-10-24" class="headerlink" title="264场周赛 2021-10-24"></a>264场周赛 2021-10-24</h2><h3 id="第一题-easy-6"><a href="#第一题-easy-6" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="句子中的有效单词"><a href="#句子中的有效单词" class="headerlink" title="句子中的有效单词"></a><a href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/">句子中的有效单词</a></h4><p>句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。<br>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：<br>仅由小写字母、连字符和/或标点（不含数字）。<br>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。<br>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。<br>写了最久的第一题。。。。直接模拟。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countValidWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; temp = <span class="hljs-built_in">getString</span>(s);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; temp.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(temp[i][<span class="hljs-number">0</span>] ==<span class="hljs-string">&#x27;-&#x27;</span>||temp[i].<span class="hljs-built_in">back</span>()==<span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>,m = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; temp[i].<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(temp[i][j] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(!((temp[i][j - <span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;temp[i][j - <span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>&amp;&amp;temp[i][j+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>&amp;&amp;temp[i][j+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>))&#123;<br>                        f=<span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    f++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>||temp[i][j] == <span class="hljs-string">&#x27;,&#x27;</span>||temp[i][j] == <span class="hljs-string">&#x27;!&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(j != temp[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>                        m=<span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    m++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp[i][j]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;temp[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    f = <span class="hljs-number">2</span>;<br>                    m=<span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f&lt;=<span class="hljs-number">1</span>&amp;&amp;m&lt;=<span class="hljs-number">1</span>)res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    vector&lt;string&gt; <span class="hljs-built_in">getString</span>(string word) &#123;<br>        vector&lt;string&gt; res;<br>        string result;<br>        stringstream <span class="hljs-built_in">input</span>(word);<br>        <span class="hljs-keyword">while</span> (input &gt;&gt; result) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-6"><a href="#第二题-Medium-6" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="下一个更大的数值平衡数"><a href="#下一个更大的数值平衡数" class="headerlink" title="下一个更大的数值平衡数"></a><a href="https://leetcode-cn.com/problems/next-greater-numerically-balanced-number/">下一个更大的数值平衡数</a></h4><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。<br>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。<br>输入：n = 1000<br>输出：1333<br>解释：<br>1333 是一个数值平衡数，因为：</p><ul><li>数字 1 出现 1 次。</li><li>数字 3 出现 3 次。<br>这也是严格大于 1000 的最小数值平衡数。<br>注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。</li></ul><p>输入：n = 3000<br>输出：3133<br>解释：<br>3133 是一个数值平衡数，因为：</p><ul><li>数字 1 出现 1 次。</li><li>数字 3 出现 3 次。<br>这也是严格大于 3000 的最小数值平衡数。</li></ul><p>当时就是少了第一个大于666666返回1224444结果超时。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">666666</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1224444</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i = n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100000000</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">helper</span>(i)) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp; i)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ii = i;<br>        unordered_map&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;map;<br>        <span class="hljs-keyword">while</span>(ii&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> temp = ii%<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(temp == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ii = ii/<span class="hljs-number">10</span>;<br>            map[temp]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=map.<span class="hljs-built_in">begin</span>();i!=map.<span class="hljs-built_in">end</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;first != i-&gt;second)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>还有能直接打表。。。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; num&#123;<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">122</span>,<span class="hljs-number">212</span>,<span class="hljs-number">221</span>,<span class="hljs-number">333</span>,<span class="hljs-number">1333</span>,<span class="hljs-number">3133</span>,<span class="hljs-number">3313</span>,<span class="hljs-number">3331</span>,<span class="hljs-number">4444</span>,<span class="hljs-number">14444</span>,<span class="hljs-number">22333</span>,<span class="hljs-number">23233</span>,<span class="hljs-number">23323</span>,<span class="hljs-number">23332</span>,<span class="hljs-number">32233</span>,<span class="hljs-number">32323</span>,<span class="hljs-number">32332</span>,<span class="hljs-number">33223</span>,<span class="hljs-number">33232</span>,<span class="hljs-number">33322</span>,<span class="hljs-number">41444</span>,<span class="hljs-number">44144</span>,<span class="hljs-number">44414</span>,<span class="hljs-number">44441</span>,<br>                <span class="hljs-number">55555</span>,<span class="hljs-number">122333</span>,<span class="hljs-number">123233</span>,<span class="hljs-number">123323</span>,<span class="hljs-number">123332</span>,<span class="hljs-number">132233</span>,<span class="hljs-number">132323</span>,<span class="hljs-number">132332</span>,<span class="hljs-number">133223</span>,<span class="hljs-number">133232</span>,<span class="hljs-number">133322</span>,<span class="hljs-number">155555</span>,<span class="hljs-number">212333</span>,<span class="hljs-number">213233</span>,<span class="hljs-number">213323</span>,<span class="hljs-number">213332</span>,<span class="hljs-number">221333</span>,<span class="hljs-number">223133</span>,<span class="hljs-number">223313</span>,<span class="hljs-number">223331</span>,<span class="hljs-number">224444</span>,<span class="hljs-number">231233</span>,<span class="hljs-number">231323</span>,<span class="hljs-number">231332</span>,<br>                <span class="hljs-number">232133</span>,<span class="hljs-number">232313</span>,<span class="hljs-number">232331</span>,<span class="hljs-number">233123</span>,<span class="hljs-number">233132</span>,<span class="hljs-number">233213</span>,<span class="hljs-number">233231</span>,<span class="hljs-number">233312</span>,<span class="hljs-number">233321</span>,<span class="hljs-number">242444</span>,<span class="hljs-number">244244</span>,<span class="hljs-number">244424</span>,<span class="hljs-number">244442</span>,<span class="hljs-number">312233</span>,<span class="hljs-number">312323</span>,<span class="hljs-number">312332</span>,<span class="hljs-number">313223</span>,<span class="hljs-number">313232</span>,<span class="hljs-number">313322</span>,<span class="hljs-number">321233</span>,<span class="hljs-number">321323</span>,<br>                <span class="hljs-number">321332</span>,<span class="hljs-number">322133</span>,<span class="hljs-number">322313</span>,<span class="hljs-number">322331</span>,<span class="hljs-number">323123</span>,<span class="hljs-number">323132</span>,<span class="hljs-number">323213</span>,<span class="hljs-number">323231</span>,<span class="hljs-number">323312</span>,<span class="hljs-number">323321</span>,<span class="hljs-number">331223</span>,<span class="hljs-number">331232</span>,<span class="hljs-number">331322</span>,<span class="hljs-number">332123</span>,<span class="hljs-number">332132</span>,<span class="hljs-number">332213</span>,<span class="hljs-number">332231</span>,<span class="hljs-number">332312</span>,<span class="hljs-number">332321</span>,<span class="hljs-number">333122</span>,<span class="hljs-number">333212</span>,<span class="hljs-number">333221</span>,<span class="hljs-number">422444</span>,<br>                <span class="hljs-number">424244</span>,<span class="hljs-number">424424</span>,<span class="hljs-number">424442</span>,<span class="hljs-number">442244</span>,<span class="hljs-number">442424</span>,<span class="hljs-number">442442</span>,<span class="hljs-number">444224</span>,<span class="hljs-number">444242</span>,<span class="hljs-number">444422</span>,<span class="hljs-number">515555</span>,<span class="hljs-number">551555</span>,<span class="hljs-number">555155</span>,<span class="hljs-number">555515</span>,<span class="hljs-number">555551</span>,<span class="hljs-number">666666</span>,<span class="hljs-number">1224444</span>&#125;;<br>        <span class="hljs-keyword">int</span> p = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n &lt; num[i]) &#123;<br>                <span class="hljs-keyword">return</span> num[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-6"><a href="#第三题-Medium-6" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="统计最高分数的节点数目"><a href="#统计最高分数的节点数目" class="headerlink" title="统计最高分数的节点数目"></a><a href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">统计最高分数的节点数目</a></h4><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。<br>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。<br>请你返回有最高得分节点的数目 <br>我是直接建树再bfs就行了。树的值就是他左节点+右节点+1的节点个数，删除当前节点所得的值就是temp = left<em>right</em>(n - left - right - 1)(在外边的left和right最小为1，里边最小为0);看代码比较好理解。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>        node*left;<br>        node*right;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> vall):<span class="hljs-built_in">val</span>(vall),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> max_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    vector&lt;node*&gt; tree;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countHighestScoreNodes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; p)</span> </span>&#123;<br>        n = p.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; p.<span class="hljs-built_in">size</span>();i++) &#123;<br>            node* temp =<span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>);<br>            tree.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; p.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(tree[p[i]]-&gt;left==<span class="hljs-literal">nullptr</span>)&#123;<br>                tree[p[i]]-&gt;left = tree[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tree[p[i]]-&gt;right = tree[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">bfs</span>(tree[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">helper</span>(tree[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(node*&amp;root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        root-&gt;val += <span class="hljs-built_in">bfs</span>(root-&gt;left)+<span class="hljs-built_in">bfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(node*root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>,right = <span class="hljs-number">1</span>,nn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)left = root-&gt;left-&gt;val,nn +=left;<br>        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)right = root-&gt;right-&gt;val,nn +=right;<br>        <span class="hljs-keyword">if</span>(n - nn&gt;<span class="hljs-number">0</span>)nn = n - nn;<br>        <span class="hljs-keyword">else</span> nn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = left*right*nn;<br>        <span class="hljs-keyword">if</span>(temp == max_)res++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp&gt;max_)max_ = temp,res = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">helper</span>(root-&gt;left);<br>        <span class="hljs-built_in">helper</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-6"><a href="#第四题-Hard-6" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="并行课程"><a href="#并行课程" class="headerlink" title="并行课程"></a><a href="https://leetcode-cn.com/problems/parallel-courses-iii/">并行课程</a></h4><p>给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。<br>请你根据以下规则算出完成所有课程所需要的 最少 月份数：<br>如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。<br>你可以 同时 上 任意门课程 。<br>请你返回完成所有课程所需要的 最少 月份数。<br>注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。<br>没写出后面写的。。挺简单的我吐了，多源bfs也能过，更新最大cost[i]就行了。数据大的话用拓扑排序，不然可能超时。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relations, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; time)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; map;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cost</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; relations.<span class="hljs-built_in">size</span>();i++) &#123;<br>            map[relations[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(relations[i][<span class="hljs-number">1</span>]);<br>            flag[relations[i][<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(flag[i] == <span class="hljs-number">0</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            cost[i] = time[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> top = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;i:map[top]) &#123;<br>                <span class="hljs-keyword">int</span> c = cost[top] + time[i - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(c &gt; cost[i]) &#123;<br>                    cost[i] = c;<br>                    q.<span class="hljs-built_in">push</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i :cost) &#123;<br>            res = <span class="hljs-built_in">max</span>(res,i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="263场周赛-2021-10-17"><a href="#263场周赛-2021-10-17" class="headerlink" title="263场周赛 2021-10-17"></a>263场周赛 2021-10-17</h2><h3 id="第一题-easy-7"><a href="#第一题-easy-7" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="检查句子中的数字是否递增"><a href="#检查句子中的数字是否递增" class="headerlink" title="检查句子中的数字是否递增"></a><a href="https://leetcode-cn.com/problems/check-if-numbers-are-ascending-in-a-sentence/">检查句子中的数字是否递增</a></h4><p>句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。<br>示例，”a puppy has 2 eyes 4 legs” 是一个由 7 个 token 组成的句子：”2” 和 “4” 是数字，其他像 “puppy” 这样的 tokens 属于单词。<br>给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。<br>如果满足题目要求，返回 true ，否则，返回 false 。</p><p>输入：s = “1 box has 3 blue 4 red 6 green and 12 yellow marbles”<br>输出：true<br>解释：句子中的数字是：1, 3, 4, 6, 12 。<br>这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。</p><p>输入：s = “sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s”<br>输出：false<br>解释：s 中的数字是：7, 51, 50, 60 。这些数字不是严格递增的。</p><p>蠢比写法。。。。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">areNumbersAscending</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; str = <span class="hljs-built_in">getString</span>(s);<br>        <span class="hljs-keyword">int</span> n = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();i++) &#123;<br>            num = num*<span class="hljs-number">10</span>+str[<span class="hljs-number">0</span>][i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; str[i].<span class="hljs-built_in">size</span>();j++) &#123;<br>                temp =temp*<span class="hljs-number">10</span>+str[i][j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num &gt;= temp)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            num = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getString</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        string result;<br>        <span class="hljs-function">stringstream <span class="hljs-title">input</span><span class="hljs-params">(word)</span></span>;<br>        <span class="hljs-keyword">while</span> (input &gt;&gt; result) &#123;<br>            <span class="hljs-keyword">if</span>(result[<span class="hljs-number">0</span>] &gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;result[<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                res.<span class="hljs-built_in">push_back</span>(result);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-7"><a href="#第二题-Medium-7" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="简易银行系统"><a href="#简易银行系统" class="headerlink" title="简易银行系统"></a><a href="https://leetcode-cn.com/problems/simple-bank-system/">简易银行系统</a></h4><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 n 个账户，编号从 1 到 n 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 balance 中，其中第 (i + 1) 个账户的初始余额是 balance[i] 。<br>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：<br>指定的账户数量在 1 和 n 之间，且<br>取款或者转账需要的钱的总数 小于或者等于 账户余额。<br>实现 Bank 类：<br>Bank(long[] balance) 使用下标从 0 开始的整数数组 balance 初始化该对象。<br>boolean transfer(int account1, int account2, long money) 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。<br>boolean deposit(int account, long money) 向编号为 account 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 false 。<br>boolean withdraw(int account, long money) 从编号为 account 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。<br>送分题，但是因为long long 和非法输入wa了两次我去。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Bank</span>(vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&amp; b) &#123;<br>        n = b.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; b.<span class="hljs-built_in">size</span>();i++) &#123;<br>            map[i+<span class="hljs-number">1</span>] = b[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">transfer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a1, <span class="hljs-keyword">int</span> a2, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a1&lt;<span class="hljs-number">1</span>||a1&gt;n||a2&lt;<span class="hljs-number">1</span>||a2&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(map[a1] &lt; m)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        map[a1] -= m;<br>        map[a2] += m;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">1</span>||a&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        map[a] +=m;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">1</span>||a&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(map[a] &lt; m)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        map[a]-=m;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Bank object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Bank* obj = new Bank(balance);</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;transfer(account1,account2,money);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;deposit(account,money);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;withdraw(account,money);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-7"><a href="#第三题-Medium-7" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="统计按位或能得到的最大值的子集数目"><a href="#统计按位或能得到的最大值的子集数目" class="headerlink" title="统计按位或能得到的最大值的子集数目"></a><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">统计按位或能得到的最大值的子集数目</a></h4><p>给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。<br>如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。<br>对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR … OR a[a.length - 1]（下标从 0 开始）。<br>输入：nums = [3,2,1,5]<br>输出：6<br>解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</p><ul><li>[3,5]</li><li>[3,1,5]</li><li>[3,2,5]</li><li>[3,2,1,5]</li><li>[2,5]</li><li>[2,1,5]<br>提示：<br>1 &lt;= nums.length &lt;= 16<br>1 &lt;= nums[i] &lt;= 10^5<br>直接bfs，但是有个细节，跳过的从i开始不是从当前level+1开始bfs<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tar = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countMaxOrSubsets</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            tar = tar|nums[i];<br>        &#125;<br>        temp = nums;<br>        <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur,<span class="hljs-keyword">int</span> level)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == tar)res++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = level;i &lt; temp.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">int</span> kk = cur|temp[i];<br>            <span class="hljs-built_in">bfs</span>(kk,i + <span class="hljs-number">1</span>);<br><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-7"><a href="#第四题-Hard-7" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="到达目的地的第二短时间"><a href="#到达目的地的第二短时间" class="headerlink" title="到达目的地的第二短时间"></a><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/">到达目的地的第二短时间</a></h4>城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。<br>每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。<br>第二小的值 是 严格大于 最小值的所有值中最小的值。<br>例如，[2, 3, 4] 中第二小的值是 3 ，而 [2, 2, 4] 中第二小的值是 4 。<br>给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。<br>注意：<br>你可以 任意次 穿过任意顶点，包括 1 和 n 。<br>你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。</li></ul><p>两次bfs,第一次找出最短路径经过k个节点，第二次检查是否有能在k + 1到达，如能k + 1个节点就是第二短时间，否则必是 K + 2节点的时间，时间关系没A出来，最后放弃了，<br>贴一下没过的代码。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">secondMinimum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; e, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = e.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            map[e[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[i][<span class="hljs-number">1</span>]);<br>            map[e[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        visit[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(size--) &#123;<br>                <span class="hljs-keyword">auto</span> i = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;x:map[i]) &#123;<br>                    <span class="hljs-keyword">if</span>(visit[x]==<span class="hljs-number">0</span>) &#123;<br>                        q.<span class="hljs-built_in">push</span>(x);<br>                        visit[x] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            k++;<br>        &#125;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q1;<br>        q1.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> kk = k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> flag1 = <span class="hljs-number">0</span>,flag2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()&amp;&amp;kk&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> size = q1.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(size--) &#123;<br>                <span class="hljs-keyword">auto</span> i = q1.<span class="hljs-built_in">front</span>();<br>                q1.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i == n)&#123;<br>                    <span class="hljs-keyword">if</span>(kk == <span class="hljs-number">2</span>)flag2++;<br>                    <span class="hljs-keyword">else</span> flag1++;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;x:map[i]) &#123;<br>                    q1.<span class="hljs-built_in">push</span>(x);<br>                &#125;<br>            &#125;<br>            kk--;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> wait  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(c%t == <span class="hljs-number">0</span>)&#123;<br>            wait = c;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        wait= c - (t-c%t);<br>        <span class="hljs-keyword">int</span> times = c/t;<br>        <span class="hljs-keyword">if</span>(c%t!=<span class="hljs-number">0</span>)times++;<br>        <span class="hljs-keyword">if</span>(flag2 &gt; <span class="hljs-number">0</span>)&#123;<br>            res = (k)*t+k/times*wait;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res = (k + <span class="hljs-number">1</span>)*t+k/times*wait;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="63场双周赛-2021-10-16"><a href="#63场双周赛-2021-10-16" class="headerlink" title="63场双周赛 2021-10-16"></a>63场双周赛 2021-10-16</h2><h3 id="第一题-easy-8"><a href="#第一题-easy-8" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="使每位学生都有座位的最小移动次数"><a href="#使每位学生都有座位的最小移动次数" class="headerlink" title="使每位学生都有座位的最小移动次数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-moves-to-seat-everyone/">使每位学生都有座位的最小移动次数</a></h4><p>一个房间里有 n 个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 seats[i] 是第 i 个座位的位置。同时给你一个长度为 n 的数组 students ，其中 students[j] 是第 j 位学生的位置。</p><p>你可以执行以下操作任意次：</p><p>增加或者减少第 i 位学生的位置，每次变化量为 1 （也就是将第 i 位学生从位置 x 移动到 x + 1 或者 x - 1）<br>请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。</p><p>请注意，初始时有可能有多个座位或者多位学生在 同一 位置。</p><p>排序贪心</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMovesToSeat</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; seats, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; students)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = seats.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(seats.<span class="hljs-built_in">begin</span>(),seats.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(students.<span class="hljs-built_in">begin</span>(),students.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            sum +=<span class="hljs-built_in">abs</span>(seats[i] - students[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-8"><a href="#第二题-Medium-8" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="如果相邻两个颜色相同则删除当前颜色"><a href="#如果相邻两个颜色相同则删除当前颜色" class="headerlink" title="如果相邻两个颜色相同则删除当前颜色"></a><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/">如果相邻两个颜色相同则删除当前颜色</a></h4><p>总共有 n 个颜色片段排成一列，每个颜色片段要么是 ‘A’ 要么是 ‘B’ 。给你一个长度为 n 的字符串 colors ，其中 colors[i] 表示第 i 个颜色片段的颜色。</p><p>Alice 和 Bob 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。Alice 先手 。</p><p>如果一个颜色片段为 ‘A’ 且 相邻两个颜色 都是颜色 ‘A’ ，那么 Alice 可以删除该颜色片段。Alice 不可以 删除任何颜色 ‘B’ 片段。<br>如果一个颜色片段为 ‘B’ 且 相邻两个颜色 都是颜色 ‘B’ ，那么 Bob 可以删除该颜色片段。Bob 不可以 删除任何颜色 ‘A’ 片段。<br>Alice 和 Bob 不能 从字符串两端删除颜色片段。<br>如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。<br>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。</p><p>Alice 不可以 删除任何颜色 ‘B’ 片段。Bob 不可以 删除任何颜色 ‘A’ 片段。直接计数就行</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">winnerOfGame</span><span class="hljs-params">(string c)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = c.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n - <span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(c[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;c[i] == <span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;c[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                a++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>&amp;&amp;c[i] == <span class="hljs-string">&#x27;B&#x27;</span>&amp;&amp;c[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)&#123;<br>                b++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-8"><a href="#第三题-Medium-8" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="网络空闲时刻"><a href="#网络空闲时刻" class="headerlink" title="网络空闲时刻"></a><a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/">网络空闲时刻</a></h4><p>给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。</p><p>题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。</p><p>在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><p>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。<br>否则，该数据服务器 不会重发 信息。<br>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</p><p>请返回计算机网络变为 空闲 状态的 最早秒数 。<br>算出每个数据服务器发了多少次*P[i]+来回传的耗时 -(来回耗时%p[i]),取最大就行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">networkBecomesIdle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; e, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; p)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; map;<br>        <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>(),m = p.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            map[e[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[i][<span class="hljs-number">1</span>]);<br>            map[e[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visist</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cost</span><span class="hljs-params">(m,INT_MAX)</span></span>;<br>        cost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> ii = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; i:map[ii]) &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>+ cost[ii] &lt; cost[i]) &#123;<br>                    cost[i] =<span class="hljs-number">1</span> + cost[ii];<br>                    q.<span class="hljs-built_in">push</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(cost[i] * <span class="hljs-number">2</span> &gt; p[i])&#123;<br>                <span class="hljs-keyword">int</span> time =<span class="hljs-number">2</span>*cost[i]/p[i];<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*cost[i]%p[i] == <span class="hljs-number">0</span>)<br>                    temp = time*p[i] +<span class="hljs-number">2</span>*cost[i]  - p[i];<br>                <span class="hljs-keyword">else</span> temp = (time + <span class="hljs-number">1</span>) *p[i]+<span class="hljs-number">2</span>*cost[i] +  - p[i];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                temp = cost[i]*<span class="hljs-number">2</span> ;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res,temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-8"><a href="#第四题-Hard-8" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="两个有序数的第k小乘积"><a href="#两个有序数的第k小乘积" class="headerlink" title="两个有序数的第k小乘积"></a><a href="https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/">两个有序数的第k小乘积</a></h4><p>给你两个 从小到大排好序 且下标从 0 开始的整数数组 nums1 和 nums2 以及一个整数 k ，请你返回第 k （从 1 开始编号）小的 nums1[i] * nums2[j] 的乘积，其中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length 。<br> <br>不会。。。数据有负数有正数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">impl Solution &#123;<br>    <span class="hljs-function">pub fn <span class="hljs-title">kth_smallest_product</span><span class="hljs-params">(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;, k: i64)</span> -&gt; i64 </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>the end!</p><h2 id="62场双周赛-2021-10-02"><a href="#62场双周赛-2021-10-02" class="headerlink" title="62场双周赛 2021-10-02"></a>62场双周赛 2021-10-02</h2><h3 id="第一题-easy-9"><a href="#第一题-easy-9" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="将一维数组变成二维数组"><a href="#将一维数组变成二维数组" class="headerlink" title="将一维数组变成二维数组"></a><a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/">将一维数组变成二维数组</a></h4><p>直接模拟</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">construct2DArray</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; o, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n = o.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n%m!=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-keyword">if</span>(n!=k*m)<span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(m,vector&lt;<span class="hljs-keyword">int</span>&gt;(k));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            res[i/k][i - (i/k)*k] = o[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-9"><a href="#第二题-Medium-9" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="连接后等于目标字符串的字符串对"><a href="#连接后等于目标字符串的字符串对" class="headerlink" title="连接后等于目标字符串的字符串对"></a><a href="https://leetcode-cn.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/">连接后等于目标字符串的字符串对</a></h4><p>这题是只要求字符串对，当时以为是若干个串起来的字符等于目标串的个数，后来发现是求两个字符串合起来的，直接暴力就好；</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">class Solution &#123;<br>public:<br>    int numOfPairs(vector&lt;string&gt;&amp; nums, string target) &#123;<br>        int n = nums.size();<br>        int res = 0;<br>        <span class="hljs-keyword">for</span>(int i = 0;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">for</span>(int j = 0;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target&amp;&amp;i!=j)&#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-9"><a href="#第三题-Medium-9" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="考试的最大困扰度"><a href="#考试的最大困扰度" class="headerlink" title="考试的最大困扰度"></a><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">考试的最大困扰度</a></h4><p>这题一看就是滑动窗口，先用pair记录前缀和，然后滑动窗口取min(F,T)的个数就好。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxConsecutiveAnswers</span><span class="hljs-params">(string a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">temp</span>(n+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>                temp[i+<span class="hljs-number">1</span>]=&#123;temp[i].first + <span class="hljs-number">1</span>,temp[i].second&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp[i+<span class="hljs-number">1</span>]=&#123;temp[i].first,temp[i].second + <span class="hljs-number">1</span>&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;i &lt;= n&amp;&amp;j&lt;=n;j++) &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">min</span>(temp[j].first - temp[i].first,temp[j].second-temp[i].second) &gt; k) &#123;<br>                i++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res,j - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-9"><a href="#第四题-Hard-9" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="分割数组的最多方案数"><a href="#分割数组的最多方案数" class="headerlink" title="分割数组的最多方案数"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/">分割数组的最多方案数</a></h4><p>双哈希+前缀和<br>1.这题先求不替换的时候的组数；<br>2.先用一个哈希表1记录全部前缀和。<br>3.遍历数组，将索引i之前的前缀和加入哈希表2，并将哈希表1在索引i之前的前缀和删去，询将s[i]变成K之后哈希表1前缀和是(SUM-(k-s[i]))/2 - (k-s[i]) 的个数与哈希表2中(SUM-(k-s[i]))/2的个数。<br>注意要是在s[n]分割时要减一，或者数组不整除的时候不能分割。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">waysToPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n)</span></span>;<br>        temp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>            temp[i]=temp[i - <span class="hljs-number">1</span>]+nums[i];<br>            sum+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">back</span>() - temp[i] == temp[i])&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i  = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            map[temp[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;map[temp[19]]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n ;i++) &#123;<br>            <span class="hljs-keyword">int</span> aa = k - nums[i];<br>            <span class="hljs-keyword">if</span>((sum+aa)%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                map[temp[i]]--;<br>                map2[temp[i]]++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> tar = (sum + aa)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">back</span>()==tar-aa)&#123;<br>                res = <span class="hljs-built_in">max</span>(res,map[tar-aa]+map2[tar] - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res = <span class="hljs-built_in">max</span>(res,map[tar-aa]+map2[tar]);<br><br>            &#125;<br>            <span class="hljs-comment">// cout&lt;&lt;map[tar-aa]&lt;&lt;&quot; &quot;&lt;&lt;map2[tar]&lt;&lt;endl;</span><br>            map[temp[i]]--;<br>            map2[temp[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>END!</p><h2 id="252场周赛-2021-08-02"><a href="#252场周赛-2021-08-02" class="headerlink" title="252场周赛 2021-08-02"></a>252场周赛 2021-08-02</h2><h3 id="第一题-easy-10"><a href="#第一题-easy-10" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="三除数"><a href="#三除数" class="headerlink" title="三除数"></a><a href="https://leetcode-cn.com/problems/three-divisors/">三除数</a></h4><p>给你一个整数n，如果n恰好有三个正除数，返回true,</p><p>没什么好说的，暴力查找也能过</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(k&lt;=n)&#123;<br>            <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;<br>            n%k==<span class="hljs-number">0</span>?temp=n/k:temp=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">-1</span>)&#123;<br>                set.<span class="hljs-built_in">insert</span>(temp);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.<span class="hljs-built_in">size</span>()==<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>优化一下之后</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(;i*i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i*i==n;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-10"><a href="#第二题-Medium-10" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="你可以工作的最大周数"><a href="#你可以工作的最大周数" class="headerlink" title="你可以工作的最大周数"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/">你可以工作的最大周数</a></h4><p>给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。<br>你可以按下面两个规则参与项目中的工作：<br>    1.每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。<br>    2.在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。<br>    一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。<br>返回在不违反上面规则的情况下你 最多 能工作多少周。<br> .  其实就是不能连续两周做同一个任务，在leetcode上做过一个相似的题<a href="https://leetcode-cn.com/problems/distant-barcodes/">距离相等的条形码</a>，同样是隔位插入的思想，只要剩下两种以上的工作，总能隔位插入（选取剩余最多和第二多的工作进行隔位插入），此时最大周数就是总任务数sum，当最多的任务nums[i]&gt;sum-nums[i]时，最后就会剩下一种任务，无法进行隔位插入，完成最大周数就是2*(sum-nums[i])+1。<br>基于以上的想法，可以写出:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">numberOfWeeks</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; milestones)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(milestones.<span class="hljs-built_in">begin</span>(),milestones.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">long</span> temp=milestones.<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">int</span> my_temp=temp;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;milestones.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            sum=sum+milestones[i];<br>            temp=temp-milestones[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp&gt;<span class="hljs-number">0</span>?<span class="hljs-number">2</span>*(sum-my_temp)+<span class="hljs-number">1</span>:sum;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当初没想那么多，直接排序，其实不用排序就行了</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">numberOfWeeks</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; milestones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> my_max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;milestones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum=sum+milestones[i];<br>            my_max=<span class="hljs-built_in">max</span>(my_max,milestones[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> my_max &gt; sum -my_max ? (sum - my_max) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> : sum;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-10"><a href="#第三题-Medium-10" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="收集足够苹果的最小花园周长"><a href="#收集足够苹果的最小花园周长" class="headerlink" title="收集足够苹果的最小花园周长"></a><a href="https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples/">收集足够苹果的最小花园周长</a></h4><p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。<br>你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。<br>给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。</p><p>|x| 的值定义为：<br>如果 x &gt;= 0 ，那么值为 x<br>如果 x &lt; 0 ，那么值为 -x</p><p>当时以为只要原地点在花园就行了，但其实他的花园总是正方形的。这样题目就简单很多。<br><img src="/medias/252.3.jpg" alt="你的花园~"><br>其实就是找规律，每次变大花园增加的苹果都与顶点有关(最外边一圈），我这里定义point为右上角的坐标x，将花园分成4份，只分析第一步部分。<br><img src="/medias/252.3.1.jpg"><br>得出有以下特点：<br>1.平行与x轴为x个x苹果(纵坐标)，平行于y轴为x-1个x苹果，增加个数为2x^2-x,(x,x)不计入其中。<br>2.剩下递增部分 平行于y轴为从1递增到x，平行于x轴为从1等增到x,注有累加公式2(x+1)x/2=x^2+x<br>所以你的花园的递推公式就是temp+=12point^2。<br>分析出来之后就可以写代码了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minimumPerimeter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> neededApples)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> point=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(temp&lt;neededApples)&#123;<br>            point++;<br>            <span class="hljs-meta"># temp=temp+4*(point*(2*point)+point*point);</span><br>            temp+=<span class="hljs-number">12</span>*point*point;<br>        &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>*point;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第四题-Hard-10"><a href="#第四题-Hard-10" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="统计特殊子序列的数目"><a href="#统计特殊子序列的数目" class="headerlink" title="统计特殊子序列的数目"></a><a href="https://leetcode-cn.com/problems/count-number-of-special-subsequences/">统计特殊子序列的数目</a></h4><p>特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。</p><p>比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。<br>相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。<br>给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。</p><p>一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。<br>思路动态规划：<br>题目只有三种数字0,1,2。我们改变一下思路：分别求0、1、2序列的个数，并且我们规定有效的序列1在序列0之后，有效的序列2在序列1之后，这样序列2个数即为所求。<br>于是有状态转移方程：<br>对于nums[i]==0<br>    则将序列0个数更新为dp[i][0]=2dp[i-1][0]+1;//将上一个0的索引替换成当前的+直接把0加入序列0后面。<br>对于nums[i]==1<br>    则将序列1个数更新为dp[i][1]=2dp[i-1][1]+dp[i-1][0]//将上一个1的索引替换成当期+自己当做独立的序列加在序列0后面<br>对于nums[i]==2<br>    则将序列2个数更新为dp[i][2]=2dp[i-1][2]+dp[i-1][1]//将上一个2的索引替换成当前+自己当做独立的序列加在序列1后面<br>有了思路就可以写代码了，因为每次只更新一个状态，另外两个状态不变，故只需要定义三个变量存储f0=dp[i-1][0],f1=dp[i-1][1],f2=dp[i-1][2];</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod = 1000000007</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSpecialSubsequences</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> f0 = <span class="hljs-number">0</span>, f1 = <span class="hljs-number">0</span>, f2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>                f0 = (f0 * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) % mod;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                f1 = (f1 * <span class="hljs-number">2</span> % mod + f0) % mod;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                f2 = (f2 * <span class="hljs-number">2</span> % mod + f1) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end！</p><h2 id="57场双周赛-2021-07-24"><a href="#57场双周赛-2021-07-24" class="headerlink" title="57场双周赛 2021-07-24"></a>57场双周赛 2021-07-24</h2><h3 id="第一题-easy-11"><a href="#第一题-easy-11" class="headerlink" title="第一题(easy)"></a>第一题(easy)</h3><h4 id="检查是否所有字符出现次数相同"><a href="#检查是否所有字符出现次数相同" class="headerlink" title="检查是否所有字符出现次数相同"></a><a href="https://leetcode-cn.com/problems/check-if-all-characters-have-equal-number-of-occurrences/">检查是否所有字符出现次数相同</a></h4><p>给你一个字符串s，如果s是一个好字符串，请返回true，否则请返回false。如果s中出现过的所有字符的出现次数相同，那么我们称字符串s是好字符串。s只包含小写英文字符。<br>没什么好说的，直接哈希一遍</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">areOccurrencesEqual</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s)&#123;<br>            map[x]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> temp=map.<span class="hljs-built_in">begin</span>()-&gt;second;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x=map.<span class="hljs-built_in">begin</span>();x!=map.<span class="hljs-built_in">end</span>();x++)&#123;<br>            <span class="hljs-keyword">if</span>(temp!=x-&gt;second)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当然你也可以不用哈希，定义一个26大小的vector，比较的时候把非零的跳过就行,这样会比哈希表快一些</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">areOccurrencesEqual</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s)&#123;<br>            res[x-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:res)&#123;<br>            <span class="hljs-keyword">if</span>(x)&#123;<br>                <span class="hljs-keyword">if</span>(!num)num=x;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=num)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            num=x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第二题-Medium-11"><a href="#第二题-Medium-11" class="headerlink" title="第二题(Medium)"></a>第二题(Medium)</h3><h4 id="最小未被占据椅子的编号"><a href="#最小未被占据椅子的编号" class="headerlink" title="最小未被占据椅子的编号"></a><a href="https://leetcode-cn.com/problems/the-number-of-the-smallest-unoccupied-chair/">最小未被占据椅子的编号</a></h4><p>有 n 个朋友在举办一个派对，这些朋友从 0 到 n - 1 编号。派对里有 无数 张椅子，编号为 0 到 infinity 。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。<br>比方说，当一个朋友到达时，如果椅子 0 ，1 和 5 被占据了，那么他会占据 2 号椅子。<br>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。<br>给你一个下标从 0 开始的二维整数数组 times ，其中 times[i] = [arrivali, leavingi] 表示第i个朋友到达和离开的时刻，同时给你一个整数targetFriend。所有到达时间互不相同 。<br>请你返回编号为targetFriend的朋友占据的椅子编号。<br>注意条件就行。题目要求优先占据编号小的椅子。故可以维护一个优先队列，用来存放空着的椅子编号。这题很像leetcode上的<a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">吃苹果的最大数目</a>但是要注意的是，吃苹果的这里是每天增加天数的，但是这里朋友离去并不是每一分钟都会有，也不是每分钟都会有朋友过来。所以需要额外维护一个优先队列，用来存储朋友离去的时间。有了思路之后可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P vector<span class="hljs-meta-string">&lt;int&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">smallestChair</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; times, <span class="hljs-keyword">int</span> targetFriend)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp=times[targetFriend];<br>        <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y)&#123;<span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]&lt;y[<span class="hljs-number">0</span>];&#125;);   <span class="hljs-comment">//先排序，朋友相继过来</span><br>        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; save;     #存储朋友离去的时间<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; my_save;    #储存最空出来的最小位置<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;times.<span class="hljs-built_in">size</span>();i++)&#123;#初始化凳子<br>            my_save.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000</span>;i++)&#123;#初始化时间<br>            <span class="hljs-keyword">while</span>(!save.<span class="hljs-built_in">empty</span>()&amp;&amp;save.<span class="hljs-built_in">top</span>()[<span class="hljs-number">0</span>]==i)&#123;#如果有朋友离去，将凳子入队，朋友出队<br>                my_save.<span class="hljs-built_in">push</span>(save.<span class="hljs-built_in">top</span>()[<span class="hljs-number">2</span>]);<br>                save.<span class="hljs-built_in">pop</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(j&lt;times.<span class="hljs-built_in">size</span>()&amp;&amp;i==times[j][<span class="hljs-number">0</span>])&#123;#如果还有朋友没到，朋友到了分配凳子，并入队<br>                <span class="hljs-keyword">if</span>(times[j]==temp)<span class="hljs-keyword">return</span> my_save.<span class="hljs-built_in">top</span>();#分配序号最小的凳子<br>                save.<span class="hljs-built_in">push</span>(&#123;times[j][<span class="hljs-number">1</span>],times[j][<span class="hljs-number">0</span>],my_save.<span class="hljs-built_in">top</span>()&#125;);#离去的时间、进来的时间、占据的凳子入队<br>                my_save.<span class="hljs-built_in">pop</span>();#凳子分配完成，出队<br>                j++;#朋友减一<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="第三题-Medium-11"><a href="#第三题-Medium-11" class="headerlink" title="第三题(Medium)"></a>第三题(Medium)</h3><h4 id="描述绘画的结果"><a href="#描述绘画的结果" class="headerlink" title="描述绘画的结果"></a><a href="https://leetcode-cn.com/problems/describe-the-painting/">描述绘画的结果</a></h4><h3 id="第四题-Hard-11"><a href="#第四题-Hard-11" class="headerlink" title="第四题(Hard)"></a>第四题(Hard)</h3><h4 id="队列中可以看到的人数"><a href="#队列中可以看到的人数" class="headerlink" title="队列中可以看到的人数"></a><a href="https://leetcode-cn.com/problems/number-of-visible-people-in-a-queue/">队列中可以看到的人数</a></h4><p>有 n 个人排成一个队列，从左到右 编号为 0 到 n - 1 。给你以一个整数数组 heights ，每个整数 互不相同，heights[i] 表示第 i 个人的高度。</p><p>一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 i &lt; j 且 min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], …, heights[j-1]) 。<br>请你返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人在他右侧队列中能 看到 的 人数 。<br><img src="/medias/57.1.jpg"><br>很简单的单调栈，其实是送分题，第一次竞赛做出Hard~<br>思路：其实题目讲的有点不清，就是两个人相邻(指右边相邻)，是肯定能看到的，向左遍历，维护一个递减栈，每次将比nums[i]小的弹出来，弹出来的个数就是向右看到的人的个数<br>因为向左遍历的时候，弹出的都是比自己小的，能看到的条件约束，比栈顶小的，nums[i]是看不到的，应该将在nums[i-1]进栈(上一次)将其弹出，而比栈顶大的，nums[i]才有机会看到。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">canSeePersonsCount</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; right;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">my_r</span><span class="hljs-params">(heights.size(),<span class="hljs-number">1</span>)</span></span>;#这里初始化都能看到一个人，即右边相邻的人<br>        my_r[heights.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;#最后一个人看不到人<br>        right.<span class="hljs-built_in">push</span>(heights.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);#入栈<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=heights.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">int</span> temp=heights[i];<br>            <span class="hljs-keyword">while</span>(!right.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">int</span> top=heights[right.<span class="hljs-built_in">top</span>()];<br>                <span class="hljs-keyword">if</span>(top&lt;=temp)&#123;#比自己小就出栈，说明能看到他<br>                    right.<span class="hljs-built_in">pop</span>();<br>                    my_r[i]++;#记录弹出多少<br>                    <span class="hljs-keyword">if</span>(right.<span class="hljs-built_in">empty</span>())&#123;<br>                        my_r[i]--;#如果将栈弹空说明全都能看见，但是初始化默认能看到一个人，所以要去掉。<br>                        right.<span class="hljs-built_in">push</span>(i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right.<span class="hljs-built_in">push</span>(i);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> my_r;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当时自己写的时候，代码逻辑可读性不是很清晰，贴一个清晰的~，不同的是他的是初始化成0，如果能弹空弹出个数就是能看到的个数，不能弹空弹则需要加一。<br>本质上是一样的，我写的是默认能弹空，如果弹空就会多加一次，可能思路没这么清晰。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">canSeePersonsCount</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n)</span></span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &gt;= s.<span class="hljs-built_in">top</span>()) &#123;<br>                s.<span class="hljs-built_in">pop</span>();<br>                ret[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>                ret[i]++;<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>the end!</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(Web入门)TinyWebServer笔记</title>
    <link href="/2021/11/25/TinyWebServer%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/25/TinyWebServer%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>详细记录常用函数记录项目架构设计原理，以该项目为基础框架试着加入自己的想法并加以实现。</p><span id="more"></span><h1 id="TinyWebServer-github上的一个开源项目"><a href="#TinyWebServer-github上的一个开源项目" class="headerlink" title="TinyWebServer github上的一个开源项目"></a>TinyWebServer github上的一个开源项目</h1><p>地址：<a href="https://github.com/qinguoyi/TinyWebServer%E3%80%82">https://github.com/qinguoyi/TinyWebServer。</a></p><p>Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.</p><ul><li>使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型</li><li>使用状态机解析HTTP请求报文，支持解析GET和POST请求</li><li>访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件</li><li>实现同步/异步日志系统，记录服务器运行状态</li><li>经Webbench压力测试可以实现上万的并发连接数据交换</li></ul><p>框架：</p><p><img src="/img/11.jpg">  </p><h2 id="1-线程同步机制包装类Locker"><a href="#1-线程同步机制包装类Locker" class="headerlink" title="1. 线程同步机制包装类Locker"></a>1. 线程同步机制包装类Locker</h2><p>文件locker是对信号量互斥锁、条件变量的几个函数进行封装。实现多线程同步，确保任一时刻只能有一个线程进入关键代码段。</p><h3 id="1-1-class-sem"><a href="#1-1-class-sem" class="headerlink" title="1.1 class sem"></a>1.1 class sem</h3><ul><li><p>什么是是信号量</p><p>  linux sem信号量是一种特殊的变量，访问具有原子性，用于解决进程或线程间共享资源引发的同步问题。</p><p>  用户态进程对sem信号量可以有以下两种操作：</p><ul><li>等待信号量, 当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。</li><li>发送信号量,将信号量加1，信号量大于0时，唤醒调用sem_pos的线程。</li></ul><p>  linux信号量相关函数声明头文件semaphore.h头文件中，所以使用信号量之前需要包含头文件。</p><blockquote><p>#include &lt;semaphore.h&gt;</p></blockquote></li><li><p>sem_init</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *sem, <span class="hljs-keyword">int</span> pshared, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> value)</span></span>;<br>该函数初始化由sem指向信号对象，并给他一个初始的整数值value。pshared控制信号量的类型，值为<span class="hljs-number">0</span>代表信号量用于多线程同步，值如果大于<span class="hljs-number">0</span>表示可以共享，用于多个相关进程的同步。参数pshared&gt;<span class="hljs-number">0</span>时指定了共享内存区域，所以可以在进程间共享该变量<br></code></pre></div></td></tr></table></figure></li><li><p>sem_wait</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *sem)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_trywait</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span> *sem)</span></span>;<br></code></pre></div></td></tr></table></figure><p>  sem_wait是一个阻塞函数，测试所指定信号量的值，他的操作时原子的，若sem value &gt; 0,则该信号量值减去1并立即返回，若sem value == 0，则阻塞直到sem value &gt; 0，此时立即减去1，然后返回。<br>  sem_trywait函数是非阻塞的函数，他会尝试获取sem value值，如果sem value == 0，不是阻塞住，而是返回一个错误EAGAIN。</p></li><li><p>sem_post</p><p>  把指定的信号量sem的值加1，唤醒正在等待该信号量的任意线程。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>*sem)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>sem_getvalue</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_getvalue</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>* sem,<span class="hljs-keyword">int</span>* sval)</span></span>;<br>获取信号量sem 当前的值，把该值保存在sval，如有一个或者多个线程在调用sem_wait阻塞在该信号量上，该函数返回阻塞在该信号量上进程或线程个数。<br></code></pre></div></td></tr></table></figure></li><li><p>sem_destroy</p><p>  该函数用于对用完的信号量的清理，它的原型如下：</p><blockquote><p>int sem_destroy(sem_t* sem);</p></blockquote></li></ul><h3 id="1-2-class-lock"><a href="#1-2-class-lock" class="headerlink" title="1.2 class lock"></a>1.2 class lock</h3><ul><li><p>互斥量</p><p>  系统中如果存在资源共享，线程中存在竞争，如果没有合理的同步机制的话，会出现数据混论现象，为了实现同步机制，其中一种就是互斥锁mutex(互斥量)。互斥锁，也称互斥量，可以保护关键代码段，以确保独占方式访问，当进入关键代码段，获得互斥锁将其加锁；离开关键代码段，唤醒等待该互斥锁的线程。<br>  在linux环境下，类型pthread_mutex_t其本质是一个结构体，一般以下面方式定义：变量mutex只有两种值1、0；</p>  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-keyword">pthread_mutex_t</span> mutex;<br></code></pre></div></td></tr></table></figure></li><li><p>pthread_mutex_init</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>* <span class="hljs-keyword">restrict</span> mutex,<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_mutexattr_t</span>* <span class="hljs-keyword">restrict</span> attr)</span></span>;<br>函数作用，初始化一个互斥锁，成功返回<span class="hljs-number">0</span>，失败返回错误码。初值可视为<span class="hljs-number">1</span>；mutex：传出参数，调用时应传&amp;mutex给函数；attr:互斥量属性，是一个传入参数，通常传入<span class="hljs-literal">NULL</span>，表示默认属性(即线程间共享)。<br></code></pre></div></td></tr></table></figure><p>  关键字：restrict。仅作用于指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成，不能通过除本指针以外的其他变量或指针来修改。</p></li><li><p>pthread_mutex_lock</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span> *mutex)</span></span><br><span class="hljs-function">获取锁，成功时返回0，如果获取失败，则该线程将阻塞，直到持有该互斥量的其他线程解锁为止,在访问共享资源前加锁，访问结束后立即解锁，锁的“粒度”应该越小越好。</span><br></code></pre></div></td></tr></table></figure></li><li><p>pthread_mutex_unlock</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>*mutex)</span></span>;<br>释放锁，在释放锁的同时，会将所有阻塞的线程全部唤醒，至于哪个线程先被唤醒取决于优先级、调度。默认情况下先阻塞的线程先被唤醒。<br></code></pre></div></td></tr></table></figure></li><li><p>pthread_mutex_trylock</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>*mutex)</span></span>;<br>尝试获取锁，成功返回<span class="hljs-number">0</span>，获取失败不会阻塞当前线程，而是返回一个值来描述互斥锁的状况。<br></code></pre></div></td></tr></table></figure></li><li><p>pthread_mutex_destroy</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span> *mutex)</span></span>;<br>函数作用，销毁一个互斥锁。成功返回<span class="hljs-number">0</span>，失败返回错误码<br><br></code></pre></div></td></tr></table></figure><h3 id="1-3-class-cond"><a href="#1-3-class-cond" class="headerlink" title="1.3 class cond"></a>1.3 class cond</h3></li><li><p>条件变量</p><p>  与互斥锁不同，条件变量是用来等待的，而不是用来上锁的，条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。互斥锁的一个明显缺点就是他只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足。</p></li><li><p>pthread_cond_init</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span>*<span class="hljs-keyword">restrict</span> cond,<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_condattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span></span>;<br><br>函数作用，初始化一个条件变量，参数说明：cond:条件变量，调用时应传&amp;cond给该函数，attr:条件变量，通常传入<span class="hljs-literal">NULL</span>，表示使用默认属性。<br></code></pre></div></td></tr></table></figure></li><li><p>pthread_cond_wait And pthread_cond_timedwait</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond,<span class="hljs-keyword">pthread_mutex_t</span> * restric mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> * <span class="hljs-keyword">restrict</span> cond,<span class="hljs-keyword">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex,<span class="hljs-keyword">const</span> struct timespec* <span class="hljs-keyword">restrict</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure><p>  成功时返回0，错误则返回错误码，这两个分别是阻塞等待和超时等待，等待条件变为真，传递给pthread_cond_wait的互斥量对条件进行保护，调用者把锁住的互斥量传给函数，函数把调用线程放到等待条件的线程列表上，然后对互斥量解锁，这两个操作是原子的。</p></li><li><p>pthread_cond_signal And pthread_cond_broadcast</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> *cond)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span> * cond)</span></span>;<br></code></pre></div></td></tr></table></figure><p>这两个函数用于通知线程条件已经满足，调用这个函数也称向线程或条件发送信号，必须注意一定要在改变状态以后再给线程发送信号。成功返回0，出错返回错误编号。</p></li><li><p>pthread_cond_destroy   </p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destroy(<span class="hljs-params">pthread_cond_t</span><span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;  <br>函数作用，销毁一个条件变量。成功返回<span class="hljs-number">0</span>，失败返回错误码。  <br></code></pre></div></td></tr></table></figure></li></ul><h2 id="2-同步-异步日志系统log"><a href="#2-同步-异步日志系统log" class="headerlink" title="2 .同步/异步日志系统log"></a>2 .同步/异步日志系统log</h2><h3 id="2-1block-queue-h"><a href="#2-1block-queue-h" class="headerlink" title="2.1block_queue.h"></a>2.1block_queue.h</h3><p> 循环数组实现的阻塞队列的一个模板类，从性能上考虑，没有使用STL的queue作为基本数据结构，而是使用循环数组，省去了动态内存分配和回收。线程安全，每个操作前都要先加互斥锁，操作完后，再解锁。</p><p>循环数组实现主要是用了以下两个式子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_back = (m_back + <span class="hljs-number">1</span>) % m_max_size<br>m_front = (m_front + <span class="hljs-number">1</span>)% m_max_size<br></code></pre></div></td></tr></table></figure><p>数据成员</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>locker m_mutex; <span class="hljs-comment">//互斥锁</span><br>cond m_cond;    <span class="hljs-comment">//信号量</span><br>T *m_array;     <span class="hljs-comment">//数组指针</span><br><span class="hljs-keyword">int</span> m_size;     <span class="hljs-comment">//数组当前大小</span><br><span class="hljs-keyword">int</span> m_max_size; <span class="hljs-comment">//数组最大大小</span><br><span class="hljs-keyword">int</span> m_front;    <span class="hljs-comment">//数组非空最先储存元素索引</span><br><span class="hljs-keyword">int</span> m_back;     <span class="hljs-comment">//数组非空最后元素索引</span><br></code></pre></div></td></tr></table></figure><p>接口：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">front</span><span class="hljs-params">(T &amp;value)</span></span>; <span class="hljs-comment">//引用的方式，这里面复制到value,数组空返回false</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">back</span><span class="hljs-params">(T &amp;value)</span></span>; <span class="hljs-comment">//同上</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//当前大小</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_size</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;item)</span></span>;<span class="hljs-comment">//const，判断是否满了，计算下一索引m_back = (m_back + 1) % m_max_size，赋值。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(T &amp;item)</span></span>; <span class="hljs-comment">//pop时如果当前队列没有元素，将会等待条件变量调用cond.wait函数，计算下一索引m_front = (m_front + 1)% m_max_size，赋值返回。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(T &amp;item,<span class="hljs-keyword">int</span> ms_timeout)</span></span>;<span class="hljs-comment">//在等待条件变量的时候加了超时处理。调用cond_timewait函数</span><br></code></pre></div></td></tr></table></figure><h3 id="2-2-log-h"><a href="#2-2-log-h" class="headerlink" title="2.2 log.h"></a>2.2 log.h</h3><p>在log.h声明了一个单例模式的log类，该类可设置同步异步，异步时单独开启一个线程从阻塞队列中取出日志并写入，同步时只是单独写入，要注意改变类内的一些变量(行数相关)时要上锁，每次更换文件或者阻塞队列满了都要上锁保证日志能完全正确写入。</p><ul><li><p>单例模式</p><ul><li>单例模式的实现</li></ul><p>  1.构造函数声明为private或protect防止被外部函数实例化。</p><p>  2.提供一个全局的静态方法(全局访问点)。</p><p>  3.内部保存一个private static的类指针保存唯一的实例，实例的动作由一个public的类方法代劳，该方法也返回单例类唯一的实例。</p><p>  如果只是这样实现是线程不安全的，当两个线程同时访问静态方法的时候，会同时构造一个实例。</p></li><li><p>懒汉式和饿汉式</p><ul><li>懒汉不到万不得已就不会去实例化类，只有在第一次使用类实例的时候才会实例化。</li></ul><p>  懒汉式在单例模式中的静态方法加锁就可以实现。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">singleton</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">singleton</span>()<br>    &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> singleton* p;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> singleton* <span class="hljs-title">initance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">pthread_mutex_t</span> singleton::mutex;<br>singleton* singleton::p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function">singleton* <span class="hljs-title">singleton::initance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>            p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">singleton</span>();<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>饿汉 在单例类定义的时候就进行初始化。</p><p>  饿汉式静态方法初始化是就实例化，而全局方法就不需要实例化了；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singelton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singelton</span>()&#123;<br>        m_count ++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Singelton begin\n&quot;</span>);<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);                            <span class="hljs-comment">// 加sleep为了放大效果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Singelton end\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> Singelton *single;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singelton *<span class="hljs-title">GetSingelton</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_count;<br>&#125;;<br><span class="hljs-comment">// 饿汉模式的关键：初始化即实例化</span><br>Singelton *Singelton::single = <span class="hljs-keyword">new</span> Singelton;<br><span class="hljs-keyword">int</span> Singelton::m_count = <span class="hljs-number">0</span>;<br><span class="hljs-function">Singelton *<span class="hljs-title">Singelton::GetSingelton</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 不再需要进行实例化</span><br>    <span class="hljs-comment">//if(single == nullptr)&#123;</span><br>    <span class="hljs-comment">//    single = new Singelton;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">return</span> single;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>类成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span> dir_name[<span class="hljs-number">128</span>]; <span class="hljs-comment">//路径名</span><br><span class="hljs-keyword">char</span> log_name[<span class="hljs-number">128</span>]; <span class="hljs-comment">//log文件名</span><br><span class="hljs-keyword">int</span> m_split_lines;  <span class="hljs-comment">//日志最大行数</span><br><span class="hljs-keyword">int</span> m_log_buf_size; <span class="hljs-comment">//日志缓冲区大小</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m_count;  <span class="hljs-comment">//日志行数记录</span><br><span class="hljs-keyword">int</span> m_today;        <span class="hljs-comment">//因为按天分类,记录当前时间是那一天</span><br>FILE *m_fp;         <span class="hljs-comment">//打开log的文件指针</span><br><span class="hljs-keyword">char</span> *m_buf;<br>block_queue&lt;string&gt; *m_log_queue; <span class="hljs-comment">//阻塞队列</span><br><span class="hljs-keyword">bool</span> m_is_async;                  <span class="hljs-comment">//是否同步标志位</span><br>locker m_mutex;<br><span class="hljs-keyword">int</span> m_close_log; <span class="hljs-comment">//关闭日志</span><br></code></pre></div></td></tr></table></figure><ul><li>成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Log *<span class="hljs-title">get_instance</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//单例初始化</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">flush_log_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*args)</span></span>;<span class="hljs-comment">//回调函数，封装void*async_write_log()</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file_name,<span class="hljs-keyword">int</span> close_log,<span class="hljs-keyword">int</span> log_buf_size == <span class="hljs-number">8192</span>,<span class="hljs-keyword">int</span> split_lines = <span class="hljs-number">5000000</span>,<span class="hljs-keyword">int</span> max_queue_size  = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//强制刷新写入流缓冲区</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">async_write_log</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//阻塞队列中取出log并写入，带锁。</span><br><br></code></pre></div></td></tr></table></figure><p>在函数void write_log(int level,const char *<br>format,…)中用了省略符形参，省略符形参应该仅仅用于c和c++通用的类型，因为大多数类型的对象在传递省略形参时都无法正确拷贝。<br>使用省略符形参需要用到头文件 cstdarg下面是<cstdarg>头文件的几个宏定义：  </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdarg&gt;</span>  <span class="hljs-comment">// C中是&lt;stdarg.h&gt;</span></span><br><span class="hljs-comment">// va_list是一种数据类型，args用于持有可变参数。</span><br><span class="hljs-comment">// 定义typedef char* va_list;</span><br>va_list args;<br><br><span class="hljs-comment">// 调用va_start并传入两个参数：第一个参数为va_list类型的变量</span><br><span class="hljs-comment">// 第二个参数为&quot;...&quot;前最后一个参数名</span><br><span class="hljs-comment">// 将args初始化为指向第一个参数（可变参数列表）</span><br><span class="hljs-built_in">va_start</span>(args, paramN);<br><br><span class="hljs-comment">// 检索参数，va_arg的第一个参数是va_list变量，第二个参数指定返回值的类型</span><br><span class="hljs-comment">// 每一次调用va_arg会获取当前的参数，并自动更新指向下一个可变参数。</span><br><span class="hljs-built_in">va_arg</span>(args,type);<br><br><span class="hljs-comment">// 释放va_list变量</span><br><span class="hljs-built_in">va_end</span>(args);<br></code></pre></div></td></tr></table></figure><p>例如如下的用法，该用法只适合c语言支持的类型。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdarg&gt;</span></span><br><span class="hljs-comment">//省略符型参仅仅用于c和c++通用的类型，特别应该注意的是，大多数类类型的对象在传递省略符型参都无法正确拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count,...)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is below 0!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//为了实现可变参数列表，首先需要声明一个va_list类型的指针，该指针用来依次指向各个参数</span><br>    va_list arg_ptr;<br><br>    <span class="hljs-comment">//va_start是一个宏，用来初始化va_list，使其指向列表的第一个参数，va_start的第二个参数是sum函数省略符前的参数，用来固定第一个参数的位置</span><br>    va_start(arg_ptr,count);<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值</span><br>    <span class="hljs-comment">//va_arg宏的第二个参数是需要统计的第一个参数的类型，如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; count;i++) &#123;<br>        res+=va_arg(arg_ptr,<span class="hljs-keyword">int</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将va_list类型的指针复位成空值</span><br>    <span class="hljs-comment">//就是清空可变参数列表</span><br>    va_end(arg_ptr);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>sum(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//return 15</span><br><br></code></pre></div></td></tr></table></figure><p>在对log内容的操作中，log日志类用的是fopen函数，fopen 和open的区别主要有以下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function">EILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;<br><br></code></pre></div></td></tr></table></figure><ul><li><p>mode指定文件打开的方式：  </p><ul><li>r：只读方式打开一个文本文件（该文件必须存在）  </li><li>r+：可读可写方式打开一个文本文件（该文件必须存在）  </li><li>w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）  </li><li>w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）  </li><li>a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））  </li><li>a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））  </li></ul></li><li><p>a 和 a+ 的区别：a 不能读，a+ 可以读  </p><ul><li>rb：只读方式打开一个二进制文件（使用法则同r）  </li><li>rb+：可读可写方式打开一个二进制文件（使用法则同r+）  </li><li>wb：只写方式打开一个二进制文件（使用法则同w）  </li><li>wb+：可读可写方式生成一个二进制文件（使用法则同w+）  </li><li>ab：追加方式打开一个二进制文件（使用法则同a）  </li><li>ab+：可读可写方式追加一个二进制文件（使用法则同a+）  </li></ul></li></ul><p>返回值，fopen()返回的是一个FILE类型的指针，若打开失败返回NULL。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*pathname, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*pathname, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li>flag用于指定文件打开/创建的方式，这个参数可由以下三个互斥的常量(定义于fcntl.h)，通过逻辑或连接。<ul><li>O_RDONLY  只读  </li><li>O_WRONLY  只写  </li><li>O_RDWR    读写<br>返回值，open返回的是一个文件描述符，打开失败返回-1。</li></ul></li></ul><p>区别  </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">open属于低级IO，fopen属于高级IO;<br>前者返回一个文件描述符，后者返回一个指针；<br>前者无缓冲，后者有缓冲；<br>前者与<span class="hljs-built_in">read</span>,write等配合使用，后者与fread,fwrite使用；<br>后者是在前者的基础上扩充而来的，在大多数情况下，用后者；<br>fopen是c库中的函数，而open是linux中的系统调用。<br></code></pre></div></td></tr></table></figure><p>c库函数strrchr():  </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str,<span class="hljs-keyword">int</span> c)</span></span>;<br>str--C字符串<br>c  --要搜索的字符，以<span class="hljs-keyword">int</span>形式传递，但是最终回转回<span class="hljs-keyword">char</span>形式。<br></code></pre></div></td></tr></table></figure><p>在本项目中主要是用来分割路径‘/’和文件名的位置(找到文件名)；<br>c库函数snprintf()</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;<br><br>    <span class="hljs-comment">//设将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，    </span><br>    s<span class="hljs-comment">//ize 为要写入的字符的最大数目，超过 size 会被截断</span><br>    <span class="hljs-built_in">snprintf</span>(log_full_name,<span class="hljs-number">255</span>,<span class="hljs-string">&quot;%d_%d_%02d_%s&quot;</span>,my_tm.tm_year + <span class="hljs-number">1900</span>,<br>                 my_tm.tm_mon,my_tm.tm_mday,file_name);<br></code></pre></div></td></tr></table></figure><p>c库函数strcpy()和strncpy()</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//将src所指向的字符串复制到dest</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * src)</span></span>;<br><span class="hljs-comment">//把src所指向的字符串复制到dest最多复制n个字符。当src的长度小于n时，dest的剩余部分将用空字节填充</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*src,<span class="hljs-keyword">size_t</span> size)</span></span>;<br></code></pre></div></td></tr></table></figure><h2 id="3-线程池-半同步-半反应堆线程池"><a href="#3-线程池-半同步-半反应堆线程池" class="headerlink" title="3 .线程池 半同步/半反应堆线程池"></a>3 .线程池 半同步/半反应堆线程池</h2><p>补充知识：  </p><h3 id="半同步-半异步模型-HSHA"><a href="#半同步-半异步模型-HSHA" class="headerlink" title="半同步/半异步模型 HSHA"></a>半同步/半异步模型 HSHA</h3><ul><li>什么是线程池<br>线程池是服务器预先创建的一组线程，这些线程运行着相同的代码，当新任务到来时，主线程通过某种方式选择线程池中的某一个线程来为之服务，服务完之后又放回线程池(其实就是阻塞和唤醒)。  </li><li>为什么需要线程池<br>相比于动态创建线程来说，线程池可以提高速度，因为线程的创建和销毁是要时间的。如果频繁的线程创建和销毁线程是非常消耗内核资源的。  </li><li>什么是半同步/半异步<br>[半同步/半异步]模式，(half-sync/halt-async,以下就简称HSHA)，主要分三层：<figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">异步IO<span class="hljs-comment">(主线程)</span>;<br>队列层<span class="hljs-comment">(任务队列)</span>；<br>同步处理层<span class="hljs-comment">(线程池)</span>；  <br></code></pre></div></td></tr></table></figure>异步IO与同步处理</li></ul><ul><li>所谓同步：在客户端连接，请求数据，以及向队列中写入数据的时候是异步的。在写入完成可能会执行预设的回调函数，进行预处理和其他通知操作，也便是Proactor模式。  </li><li>关于异步IO，严重依赖内核的支持，比如window的IOCP就是公认的不错的异步IO实现，而Linux的AIO系列内部还是用多线程来模拟，实则伪异步，epool不是异步IO，因为要遍历发生变化的FD然后循环将数据读完。  </li><li>所谓同步：在线程池中，工作线程从任务队列中每次取出任务，其具体的业务逻辑是同步的，虽然在消费队列的时候是多线程，但是并不会多个线程处理一次请求。  </li></ul><p>半同步/半异步模型 HSHA是工作线程负责异步地从客户端fd获取客户端的请求数据，而工作线程则是并发的对该数据进行处理，工作线程不关心客户端fd，不关心通信，而IO线程不关心处理过程。    </p><h3 id="半同步-半反应堆模型-HSHR"><a href="#半同步-半反应堆模型-HSHR" class="headerlink" title="半同步/半反应堆模型 HSHR"></a>半同步/半反应堆模型 HSHR</h3><ul><li>HSHA模式十分依赖异步IO，然而实现真正异步通常比较困难，IO多路复用技术的发展带给人们新思路，用IO多路复用代替异步IO，对HAHS进行改造。这就是半同步半反应堆模型(Half-Sync/Halt-Reactor,HSHR);  </li></ul><p>半同步/半反应堆模型 HSHR ，主线程只监听socket,当监测到服务器sock可读，就会进行accept,获得fd放入队列。也就是说与HSHA不同，HSHR的队列放的不是请求数据，而是fd，工作线程从队列中取的不是数据，而是客户端fd。和HSHA不同，HSHR将IO的过程侵入到了工作线程中。工作线程的逻辑循环内从队列取道fd后，对fd进行read/recv获取请求数据，然后进行处理，最后直接write/send客户端fd，将数据返回给客户端。可以看来，这种IO的方式是一种Reactor模式，这就是该模型中半反应堆一词的由来。</p><p>工作队列  </p><blockquote><p>工作线程消费队列数据的方式  </p></blockquote><ul><li>和一般的队列模型相同，分为推和拉的两种模型，通常HSHA为推模型，需要一个条件变量来实现。即队列尚无数据，则工作线程阻塞休眠，等待数据产生，而当IO线程将数据写入任务队列的时候，则会唤醒休眠的工作线程来处理；拉模型即不再需要条件变量，工作线程内作死循环，不停轮训队列数据。两种模型各有利弊，如果是IO密集型的，比如并发度特别高，以至于总能取到数据，那么就不需要推模型。</li></ul><p>本项目用的是半同步半反应堆模式，http连接放进队列中。然后由工作线程来取任务。<br>实现细节：</p><p>数据成员：  </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_thread_number;        <span class="hljs-comment">//线程池中的线程数</span><br>    <span class="hljs-keyword">int</span> m_max_requests;         <span class="hljs-comment">//请求队列中允许的最大请求数</span><br>    <span class="hljs-keyword">pthread_t</span> *m_threads;       <span class="hljs-comment">//描述线程池的数组，其大小为m_thread_number</span><br>    std::list&lt;T *&gt; m_workqueue; <span class="hljs-comment">//请求队列</span><br>    locker m_queuelocker;       <span class="hljs-comment">//保护请求队列的互斥锁</span><br>    sem m_queuestat;            <span class="hljs-comment">//是否有任务需要处理</span><br>    connection_pool *m_connPool;  <span class="hljs-comment">//数据库</span><br>    <span class="hljs-keyword">int</span> m_actor_model;          <span class="hljs-comment">//模型切换</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>成员函数：  </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span><br>    <span class="hljs-built_in">threadpool</span>(<span class="hljs-keyword">int</span> actor_model, connection_pool *connPool, <span class="hljs-keyword">int</span> thread_number = <span class="hljs-number">8</span>, <span class="hljs-keyword">int</span> max_request = <span class="hljs-number">10000</span>);<br>    ~<span class="hljs-built_in">threadpool</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">append</span><span class="hljs-params">(T *request, <span class="hljs-keyword">int</span> state)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">append_p</span><span class="hljs-params">(T *request)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在本项目中的用的是模板类<del>其实没必要</del>。如果要将声明和实现分开的话需要在头文件中实例化，否则编译不过去。  </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//要在cpp文件加上，这样的一句，将模板类实例化以用来多文件编译</span><br><span class="hljs-keyword">template</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">threadpool</span>&lt;</span>mDate&gt;<br><br></code></pre></div></td></tr></table></figure><p>在构造函数中，构造线程数组时，将线程分离，使用:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//分离线程，自己回收无需父线程回收</span><br><span class="hljs-built_in">pthread_detach</span>(id);<br></code></pre></div></td></tr></table></figure><h2 id="4-校验-amp-数据库连接池"><a href="#4-校验-amp-数据库连接池" class="headerlink" title="4 .校验 &amp; 数据库连接池"></a>4 .校验 &amp; 数据库连接池</h2><p>补充知识：</p><p>分配或初始化mysql_real_connect()相适应的MYSQL对象，如果指针是NULL指针，该函数将分配，初始化并返回新对象。否则<br>将初始化对像，并返回对象的地址，如果mysql_init()分配了新对象，当调用mysql_close()来关闭连接时，将释放对象。初始化句柄，出现无足够内存时，返回NULL。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_init</span><span class="hljs-params">(MYSQL*mysql)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li>mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须;成功完成。参数的指定方式如下：</li></ul><ul><li>第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。请参见25.2.3.48节，“mysql_options()”。</li><li>“host”的值必须是主机名或IP地址。如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP/IP连接到服务器。</li><li>“user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串””，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名。请参见26.1.9.2节，“在Windows上配置MyODBC DSN”。</li><li>“passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</li><li>注释：调用mysql_real_connect()之前，不要尝试加密密码，密码加密将由客户端API自动处理。<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_real_connect</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *passwd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *db, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *unix_socket, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> client_flag)</span></span><br></code></pre></div></td></tr></table></figure>数据库连接池</li><li>单例模式，保证唯一</li><li>list实现连接池</li><li>连接池为静态大小</li><li>互斥锁实现线程安全</li></ul><p>校验</p><ul><li>HTTP请求采用POST方式</li><li>登录用户名和密码校验</li><li>用户注册及多线程注册安全</li></ul><p>因为这项目的数据库是写死的，所以所有连接的数据库的名字，数据库端口什么都一样，所以就创建一个数据库连接池，让不会因为销毁连接创建连接而消耗额外的资源。</p><p>数据成员</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_MaxConn;  <span class="hljs-comment">//最大连接数</span><br> <span class="hljs-keyword">int</span> m_CurConn;  <span class="hljs-comment">//当前已使用的连接数</span><br> <span class="hljs-keyword">int</span> m_FreeConn; <span class="hljs-comment">//当前空闲的连接数</span><br> locker lock;<br> list&lt;MYSQL *&gt; connList; <span class="hljs-comment">//连接池</span><br> sem reserve;<br><br><span class="hljs-keyword">public</span>:<br> string m_url; <span class="hljs-comment">//主机地址</span><br> string m_Port; <span class="hljs-comment">//数据库端口号</span><br> string m_User; <span class="hljs-comment">//登陆数据库用户名</span><br> string m_PassWord; <span class="hljs-comment">//登陆数据库密码</span><br> string m_DatabaseName; <span class="hljs-comment">//使用数据库名</span><br> <span class="hljs-keyword">int</span> m_close_log;<span class="hljs-comment">//日志开关</span><br></code></pre></div></td></tr></table></figure><p>成员函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">MYSQL* <span class="hljs-title">GetConnection</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//获取数据库连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReleaseConnection</span><span class="hljs-params">(MYSQL *conn)</span></span>; <span class="hljs-comment">//释放连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetFreeConn</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyPool</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">//销毁所有连接</span><br><br>    <span class="hljs-comment">//单例模式</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> connection_pool * <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(string url, string User, string PassWord, string DataBaseName, <span class="hljs-keyword">int</span> Port, <span class="hljs-keyword">int</span> MaxConn, <span class="hljs-keyword">int</span> close_log)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">connection_pool</span>();<br>    ~<span class="hljs-built_in">connection_pool</span>();<br><br></code></pre></div></td></tr></table></figure><p>初始化mysql,信号量初始化成m_FreeConn(m_MaxConn)；<br>当有请求的时候，在数据库连接池中返回一个可用连接，更新使用和空闲连接数，注意在取连接和更新空闲连接数的时候要使用锁。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connection_pool::ReleaseConnection</span><span class="hljs-params">(MYSQL *con)</span> </span>&#123;<br> MYSQL *con = <span class="hljs-literal">NULL</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == connList.<span class="hljs-built_in">size</span>())<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br> reserve.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">//如果信号量不可用 阻塞</span><br> lock.<span class="hljs-built_in">lock</span>();<br> con = connList.<span class="hljs-built_in">front</span>();<br> connList.<span class="hljs-built_in">pop_front</span>();<br> --m_FreeConn;<br> ++m_CurConn;<br> lock.<span class="hljs-built_in">unlock</span>();<br> <span class="hljs-keyword">return</span> con;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>释放连接的时候，压入连接池和改变可用空闲个数的时候也需要上锁，上锁之后不要忘了更新信号量(+1)。</p><p>在销毁数据库连接池的整个过程都要持有锁。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connection_pool::DestroyPool</span><span class="hljs-params">()</span> </span>&#123;<br><br> lock.<span class="hljs-built_in">lock</span>();<br> <span class="hljs-keyword">if</span> (connList.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br> &#123;<br>  list&lt;MYSQL *&gt;::iterator it;<br>  <span class="hljs-keyword">for</span> (it = connList.<span class="hljs-built_in">begin</span>(); it != connList.<span class="hljs-built_in">end</span>(); ++it)<br>  &#123;<br>   MYSQL *con = *it;<br>   <span class="hljs-built_in">mysql_close</span>(con);<br>  &#125;  <br>  m_CurConn = <span class="hljs-number">0</span>;<br>  m_FreeConn = <span class="hljs-number">0</span>;<br>  connList.<span class="hljs-built_in">clear</span>();<br> &#125;<br><br> lock.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="5-http连接处理类"><a href="#5-http连接处理类" class="headerlink" title="5. http连接处理类"></a>5. http连接处理类</h2><p>根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机</p><blockquote><ul><li>客户端发出http连接请求</li><li>从状态机读取数据,更新自身状态和接收数据,传给主状态机</li><li>主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取</li></ul></blockquote><p>补充知识：<br>recv函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recv</span><span class="hljs-params">(SOCKET s,<span class="hljs-keyword">char</span> *buf,<span class="hljs-keyword">int</span> len,<span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-comment">//s     标识已连接套接字的描述符</span><br><span class="hljs-comment">//buf   指向缓冲区的指针，以接受传入的数据</span><br><span class="hljs-comment">//len   buf参数指向缓冲区的长度一般是参数二-1，留出&quot;\0&quot;</span><br><span class="hljs-comment">//flags 一组影响此功能行为的标志</span><br><br>返回值：  <br><span class="hljs-number">1.</span> 成功执行，返回接受到的字节数  <br><span class="hljs-number">2.</span> 另一端已关闭，则返回<span class="hljs-number">0</span>  <br><span class="hljs-number">3.</span> 失败返回<span class="hljs-number">-1</span>，errno被设为以下的某一个值  <br>* EAGAIN:套接字已标记为非阻塞，而接收操作被阻塞或者接受超时，  <br>* EBADF：sock不是有效的描述符，  <br>* ECONNREFUSE：远程主机阻绝网络连接  <br>* EFAULT：内存空间访问出错，  <br>* EINTR：操作被信号中断，  <br>* EINVAL：参数无效，  <br>* ENOMEM：内存不足，  <br>* ENOTCONN：面向连接的套接字尚未被连接上，  <br>* ENOTSOCK：sock索引的不是套接字，当返回的值是<span class="hljs-number">0</span>，为正常关闭连接。  <br>特别的：  <br><br></code></pre></div></td></tr></table></figure><p>用到的C库函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//C 库函数 char *strpbrk(const char *str1, const char *str2) 检索字符串 str1 中第一个匹配字符串 </span><br><span class="hljs-comment">//str2,中字符的字符不包含空结束字符也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，</span><br><span class="hljs-comment">//则停止检验，并返回该字符位置。</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strpbrk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  *str2)</span></span>;  <br><br><br><span class="hljs-comment">//检索字符串参数是否相等，忽略大小写,两字符串相同返回0，s1大于s2返回大于0值，反之返回小于0值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcasecmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s2)</span></span>;<br><br><span class="hljs-comment">//检索str1中第一个不在字符串str2中出现的字符下标</span><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strspn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * str1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str2)</span></span>;<br><br><span class="hljs-comment">//返回iu字符串str中第一次出现字符c的位置，如果未找到返回null,c会转换成字符</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> c)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//把src所指向的字符串追加到dest所指向的字符串的结尾</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src)</span></span>;<br><br></code></pre></div></td></tr></table></figure><p>Learning</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux高性能服务器(游双著)学习笔记</title>
    <link href="/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/25/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8(%E6%B8%B8%E5%8F%8C%E8%91%97)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看书，思考，做笔记。</p><span id="more"></span><h2 id="在看了在看了-再骂人傻了。"><a href="#在看了在看了-再骂人傻了。" class="headerlink" title="~~在看了在看了~~~,再骂人傻了。"></a>~~在看了在看了~~~,再骂人傻了。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(Web进阶)moduo笔记</title>
    <link href="/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/25/moduo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代操作系统学习笔记</title>
    <link href="/2021/10/19/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/19/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>现代操作系统笔记。操作系统真好玩<del>假的</del>。</p><span id="more"></span><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h3><h4 id="程序模型设计变得简单"><a href="#程序模型设计变得简单" class="headerlink" title="程序模型设计变得简单"></a>程序模型设计变得简单</h4><p>在许多应用中同时发生多种活动，通过将这些应用程序分解可以准并行运行的多个顺序线程，程序设计会变得更简单。  </p><h4 id="线程比进程更轻量级"><a href="#线程比进程更轻量级" class="headerlink" title="线程比进程更轻量级"></a>线程比进程更轻量级</h4><p>线程由于进程更轻量级，所以他们比进程更容易（更快）创建，也更容易撤销，创建一个线程较创建一个进程要10～100倍。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是存在着大量的计算和大量的I/O处理，拥有多个线程允许这 些活动彼此重叠进行，从而会加快应用程序执行的速度。</p><ul><li>cpu密集型(cpu-bound)<br>也叫计算密集型，指的是系统的硬盘，内存性能相对cpu要好很多，此时，系统运作大部分的状况是cpu Loading100%的。cup要读/写I/O就可以在很段时间来完成</li><li>i/o密集型(I/O-bound)<br>io密集型之的是cpu相对硬盘，内存要好很多，cup等待io的时间长，cup Loading并不高。</li></ul><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><h4 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h4><p>两个或者多个进程读写某些共享数据，而最后的结果取决于运行的精确时序，称为竞争条件(race condition)。同样的问题和解决方案也适用于线程。</p><h4 id="临界区域"><a href="#临界区域" class="headerlink" title="临界区域"></a>临界区域</h4><p>我们把对共享内存进行访问的程序片段称为临界区(critical region)。</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">为了避免竞争条件，需要满足以下<span class="hljs-number">4</span>个条件：  <br><span class="hljs-number">1</span>)任何两个进程不能同时处于其临界区。  <br><span class="hljs-number">2</span>)不应对<span class="hljs-meta">cpu</span>的速度和数量做任何假设。  <br><span class="hljs-number">3</span>)临界区外运行的进程不得阻塞其他进程。  <br><span class="hljs-number">4</span>)不得使进程无限期待等待进入临界区。  <br></code></pre></div></td></tr></table></figure><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>所谓的原子操作，是指一组相关联的操作要么都不间断的执行，要么都不执行。  </p><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>互斥量仅仅适用于管理公共资源或者一小段代码，互斥量是一个可以处于两态之一的变量：解锁和加锁当一个线程(或进程)需要访问临界区时，他调用mutex_lock<br>,如果互斥量当前是解锁的(即临界区是可用)，此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到临界区中的<br>线程完成并调用mutex_unlock。如果多个线程被阻塞在该互斥量上，随机选择一个线程并允许他获得锁。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h4><ul><li>先来先服务<br>在所有调度算法中，最简单的就是非抢占式的先来先服务算法，进程按照他们请求cpu的顺序来使用cpu。在这个算法中，用一个单链表记录所有就绪的进程</li><li>最短作业优先<br>当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先，假设有四个作业耗时a,b,c,d同时请求cpu，那么平均周转时间为(4a+3b+2c+d)/4<br>,最长耗时d作业只影响自己，4个作业平均等待时间最小。</li><li>最短剩余时间优先<br>最短作业优先的抢占式版本。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程来运行。<h4 id="交互式系统的调度"><a href="#交互式系统的调度" class="headerlink" title="交互式系统的调度"></a>交互式系统的调度</h4></li><li>轮转调度<br>一种最古老，最简单，最公平且使用最广的算法，每个进程被分配一个时间片，允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则剥夺cpu<br>并分配一个进程。如果该进程在时间片结束前阻塞或结束，则cpu立即进行切换。队列实现。但是时间片设置过短，由于进程切换的额外操作使得cpu利用率降低<br>时间片过长会对后面的进程等待时间较长，尤其是是短的交互请求会显得不合理。</li><li>优先级调度<br>轮换调度做一个隐含的假设，即所有进程同等重要。而优先级调度中每一个进程被赋予一个优先级，允许优先级最高的可运行程序先运行，为了防止高优先级进程<br>无休止运行下去，调度程序可能会在每个时钟滴答(即每个时钟中断)降低进程的优先级。如果不降低进程优先级的话低优先级可能会出现饥饿的情况。</li><li>最短进程优先<br>这里的问题是如何从当前可运行进程中找到最短时间的一个进程。</li><li>保证调度<br>计算出进程真正获得的cpu时间和应获得的cpu时间之比，当一个进程运行结束，算法会转向转化率最低的进程，直到该进程的比率超过它的最接近的竞争者为止。</li><li>彩票调度<br>进程持有彩票，抽奖一样。。</li><li>公平分享调度<br>不关注进程本身，而是关注其拥有者用户，每个用户占用cpu的时间一样。而每个用户内的进程采用其他的调度算法。</li></ul><h3 id="优先级反转的问题"><a href="#优先级反转的问题" class="headerlink" title="优先级反转的问题"></a>优先级反转的问题</h3><ul><li>所谓优先级反转，即当一个高优先级任务通过信号量机制访问共享资源时，该信号已被一低级优先级任务占有，而这个优先级任务在访问共享资源时可能被其他中<br>等优先级抢先(该任务不访问共享资源，可以抢占低优先级任务)，因此造成高优先级任务被许多具有较低优先级任务阻塞。<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li><li>优先级天花板(Priority Celling)，优先级天花板是当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称<br>为该资源的优先级天花板，这种方法不管是否阻塞了高优先级任务的运行，只要任务访问共享资源都会提升任务的优先级。(简单)</li><li>优先级继承(Priority,Inheritance)，优先级继承是当任务A申请共享资源S时，如果这正被任务C使用，如果发现任务C的优先级小于自身优先级，则将C优先级<br>提升到自身优先级，任务C释放资源S后，在恢复任务C的原优先级。(复杂)<h4 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h4></li><li>使用锁的代码要尽量短；</li><li>注意使用小锁替代大锁，减少冲突机会；</li><li>如果锁保护的代码段很短，直接使用原子锁忙等也是一个不错的方法。</li></ul><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><ul><li>在进行fork系统调用后。父进程和子进程要共享程序文本和数据，在分页系统中，通常是让这些进程分别拥有他们自己的页表，指向同一个页面集合，这样执行fork<br>调用时就不需要进行页面复制。然而映射到两个进程的数据页面都是只读的。只要这两个进程都仅仅是读数据，而不作更改，这种情况就能一直保持下去，但是只要有一个<br>进程更新数据，就会触发只读保护，并触发只读保护，并引发操作系统陷阱，然后生成一个该页的副本，这样每个进程都有自己专属的副本，随后对这两个页的操作都不会<br>引发陷阱，这种方法称为写时复制，它通过减少复制而提高性能。 </li><li>共享内存：通过让一个进程把一片内存区域的名称通知另一个进程，而使得第二个进程可以把这片区域映射到它的虚拟内存中去，通过两个进程(或更多)共享同一部分页<br>面，高宽带的共享就成为可能。</li></ul><h4 id="分页有关的工作"><a href="#分页有关的工作" class="headerlink" title="分页有关的工作"></a>分页有关的工作</h4><ul><li>创建新进程：</li><li>执行一个进程：</li><li>缺页中断：</li><li>进程退出：<h4 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h4></li><li>陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的cpu寄存器中。</li><li>启动一个汇编代码例程保存通用寄存器和其他易失信息，以免操作系统被破坏。</li><li>尝试发现需要哪个虚拟页，通常是一个硬件寄存器包含这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看缺页中断在做<br>什么。</li><li>一旦知道发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致，不一致的话就向进程发出一个信号杀死进程，如果地址有效且没错误，<br>系统检测空闲页框，如果没有，执行页面置换算法寻找一个页面来淘汰。</li><li>如果选择的页面是脏的，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行知道磁盘传输结束，无论如何该页被标记忙，以免被其他进<br>程占用。</li><li>一旦页面干净。操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入，该页面装入时，产生缺页的进程仍然被挂起。此时可以选择其他进程运行。</li><li>当磁盘中断时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记成正常状态。</li><li>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。</li><li>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。</li><li>该例程恢复寄存器和其他状态信息。返回到用户空间继续执行，好像缺页中断从来没有发生一样。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重定位输入方法</title>
    <link href="/2021/09/19/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BE%93%E5%85%A5/"/>
    <url>/2021/09/19/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>shell重定位输入输出,谁都不想不仅要看代码还要看输入有没有打错<del>(小心翼翼)</del>。</p><span id="more"></span><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><p>做题的时候是关键代码模式还好，要是是AMC模式，想自己在终端中输入是图或者多维输入的时候真的是。。。像这样。。。<br><img src="/medias/0916.jpg"><br>将输入重定位之后发现真相香！<br>bash脚本如下，简简单单一行，（输出其实没必要）</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; 输出结果为 &quot;</span><br>g++ <span class="hljs-variable">$1</span> -std=c++14 -o exe  &amp;&amp;./exe &lt; input.txt rm exe <span class="hljs-comment">#&gt;output.txt</span><br><br></code></pre></div></td></tr></table></figure><p>文件目录如下：<br><img src="/medias/09161.jpg"><br>跑一下<br>intput.txt 内容</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>随便拉一个来跑吧。。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> ULL = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-keyword">using</span> PLL = pair&lt;LL, LL&gt;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod =<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-comment">//优先队列符号重载</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; s1, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; s2)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span>(s1[<span class="hljs-number">0</span>] == s2[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">if</span>(s1[<span class="hljs-number">1</span>]==s2[<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> s1[<span class="hljs-number">2</span>]&lt;s2[<span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> s1[<span class="hljs-number">1</span>]&lt;s2[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1[<span class="hljs-number">0</span>]&gt;s2[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; s1, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; s2)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(s1.se==s2.se)&#123;<br>            <span class="hljs-keyword">return</span> s1.fi&lt;s2.fi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1.se&lt;s2.se;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//并查集</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; f;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UF</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x == f[x] ? x: f[x] = <span class="hljs-built_in">F</span>(f[x]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">U</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x ,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        f[<span class="hljs-built_in">F</span>(x)] = <span class="hljs-built_in">F</span>(y);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//空格切割string流</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getString</span><span class="hljs-params">(string <span class="hljs-keyword">word</span>)</span> </span>&#123;<br>    vector&lt;string&gt; res;<br>    string result;<br>    <span class="hljs-function">stringstream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">word</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (input &gt;&gt; result) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickread</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    cin&gt;&gt;n;<br>    cout&lt;&lt;n&lt;&lt;endl;<br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;boss;<br>        <span class="hljs-keyword">int</span> Yes = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        cout&lt;&lt;k&lt;&lt;endl;<br>        <span class="hljs-keyword">while</span>(k--) &#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;temp;<br>            cin&gt;&gt;temp.fi&gt;&gt;temp.se;<br>            cout&lt;&lt;temp.fi&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;temp.se&lt;&lt;endl;<br>            boss.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(boss.<span class="hljs-built_in">begin</span>(),boss.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">auto</span> &amp;x,<span class="hljs-keyword">auto</span> &amp;y)&#123;<br>           <span class="hljs-keyword">return</span> x.se&lt;y.se;<br>        &#125;);<br>        <span class="hljs-keyword">int</span> job = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt; boss.<span class="hljs-built_in">size</span>();i++) &#123;<br>            job+=boss[i].fi;<br>            <span class="hljs-keyword">if</span>(job &gt;= boss[i].se)&#123;<br>               Yes = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        Yes==<span class="hljs-number">0</span>? cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl:cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>终端执行</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">sh</span> .\<span class="hljs-keyword">run</span>.<span class="hljs-keyword">sh</span>  .\template.cpp<br></code></pre></div></td></tr></table></figure><p>可以看到输出<br><img src="/medias/09162.jpg"><br>可以了！<br>对了。。。要是连sh命令都跑不了，就下个cygwin</p>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xenomai+ethercat编译</title>
    <link href="/2021/09/14/xenomai+ethercat/"/>
    <url>/2021/09/14/xenomai+ethercat/</url>
    
    <content type="html"><![CDATA[<p>只记录关键步骤与遇到的问题提醒自己，更多细节自行上csdn查找（虽然很多都没用且重复：），但是大致流程是没错的）；</p><span id="more"></span><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>我是在我自己电脑安装的unbutu上编译的，<br>linux内核版本是4.19.152，xenomai为3.1，ipipe补丁在xenomai官网下就可。ethercat版本为1.5.2版本，</p><h2 id="编译linux内核"><a href="#编译linux内核" class="headerlink" title="编译linux内核"></a>编译linux内核</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p>除列出来的以外，整个过程中会提示你缺少什么工具，把他装上就可以了。<br>sudo apt-get install gcc<br>sudo apt-get install libncurses-dev<br>sudo apt-get install flex<br>sudo apt-get install bison<br>sudo apt-get install openssl-dev<br>sudo apt-get install dkms<br>sudo apt-get install libelf-dev<br>sudo apt-get install libudev-dev<br>sudo apt-get install libpci-dev<br>sudo apt-get install libiberty-dev<br>sudo apt-get install build-dep</p><h3 id="给内核打ipipe补丁"><a href="#给内核打ipipe补丁" class="headerlink" title="给内核打ipipe补丁"></a>给内核打ipipe补丁</h3><p>进入解压的linux源码目录，执行<br>sudo path -p1 &lt; ipipe补丁路径+补丁名称</p><h3 id="给内核打cobalt补丁"><a href="#给内核打cobalt补丁" class="headerlink" title="给内核打cobalt补丁"></a>给内核打cobalt补丁</h3><p>这个补丁需要自己生成，进入解压的xenomai源码目录，进入scripts目录，使用脚本prepare-kernel.sh对linux源码打cobalt补丁<br>sudo ./prepare-kernel.sh –linux=linux源码路径 –arch=x86_64 –outpatch=补丁生成目录+名称<br>补丁生成目录最好在linux源码的父目录：)，<br>回到linux源码目录下，执行<br>sudo path -p1&lt; cobalt补丁路径及补丁名称</p><h3 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h3><p>先从自己linux内核中复制一个配置文件过来（.config文件）在不熟悉内核各种选项情况下能帮过滤一些不知道怎么选的选项，其实也就是能帮你减少编译时间<br>当然你也可以全部选上，睡个午觉喝个下午茶再来看看什么时候才能编译完成。<br>在linux内核源码目录下执行<br>cp /boot/config-$(uname -r) .config<br>执行make menuconfig</p><p>先给自己的内核起个名字<br>在localversion选项填入</p><p>配置设置如下，按照顺序，有些修改前提是相关的。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">General setup —&gt;<br>1.Preemption Model (Preemptible Kernel (Low-Latency Desktop)) —&gt;<br>(X) Low-Latency Desktop<br>2.Local version - append to kernel release: -xenomai-3.1<br>3.Timers subsystem–&gt;<br>High Resolution Timer Support (Enable)<br><br>Processor <span class="hljs-built_in">type</span> and features —&gt;<br>1.Processor family (Core 2/newer Xeon) —&gt;<br>(X)Generic-x86-64 //(<span class="hljs-keyword">if</span> “cat /proc/cpuinfo | grep family” returns 6, <span class="hljs-built_in">set</span> as Generic otherwise)<br>2.[*] Multi-core scheduler support<br>3.[ ] CPU core priorities scheduler support<br>4.Enable maximum number of SMP processors and NUMA nodes (Disable)<br><br>Power management and ACPI options —&gt;<br>1.CPU Frequency scaling —&gt;<br>[ ] CPU Frequency scaling<br>2.[*] ACPI (Advanced Configuration and Power Interface) Support —&gt;<br>&lt; &gt; Processor<br>3. CPU Idle —&gt;<br>[ ] CPU idle PM support<br>Memory power savings --&gt;<br>Intel chipset idle memory power saving driver (Disable)<br>Run-time PM core functionality (Disable)<br><br>Memory Management options —&gt;<br>1.[ ] Contiguous Memory Allocator<br>2.[ ] Transparent Hugepage Support<br>3.[ ] Allow <span class="hljs-keyword">for</span> memory compaction<br>4.[ ] Page migration<br><br>Device Drivers<br>1.Microsoft Hyper-V guest support —&gt;<br>&lt; &gt; Microsoft Hyper-V client drivers<br>2.Staging drivers–&gt;<br>Unisys SPAR driver support(Disable)<br><br>Xenomai/cobalt<br>1.Sizes and static limits–&gt;<br>Number of registry slots (512 --&gt; 4096)<br>Size of system heap (Kb) (512 --&gt; 4096)<br>Size of private heap (Kb) (64 --&gt; 256)<br>Size of shared heap (Kb) (64 --&gt; 256)<br>Maximum number of POSIX timers per process (128 --&gt; 512)<br>2.Drivers --&gt;<br>RTnet --&gt;<br>RTnet, TCP/IP socket interface (Enable) --&gt;<br>Drivers–&gt;<br>New intel® PRO/1000 PCIe (Enable)<br>Realtek 8169 (Enable)<br>Loopback (Enable)<br>Add-Ons --&gt;<br>Real-Time Capturing Support (Enable)<br><br>    Real-time sub-system<br>    –&gt; Xenomai (Enable)<br>    –&gt; Nucleus (Enable)<br>    –&gt; Pervasive real-time support <span class="hljs-keyword">in</span> user-space (Enable)<br>    –&gt; Number of registry slots<br>    –&gt; 4096<br>    –&gt; Size of the system heap<br>    –&gt; 2048 Kb<br>    –&gt; Size of the private stack pool<br>    –&gt; 1024 Kb<br>    –&gt; Size of private semaphores heap<br>    –&gt; 48 Kb<br>    –&gt; Size of global semaphores heap<br>    –&gt; 48 Kb<br><br>Search <span class="hljs-keyword">for</span> INTEL_IDLE (<span class="hljs-built_in">disable</span>)<br>Search <span class="hljs-keyword">for</span> INPUT_PCSPKR (<span class="hljs-built_in">disable</span> PC speaker support)<br>Search <span class="hljs-keyword">for</span> XENO and <span class="hljs-built_in">enable</span> RTnet<br>Yes - Enable RTnet, TCP/IP socket interface<br>Yes - Search <span class="hljs-keyword">for</span> XENO and <span class="hljs-built_in">enable</span> User-space device driver framework<br></code></pre></div></td></tr></table></figure><p>修改完主页中应该是没有警告消息了，<br>以此执行<br>sudo make -j4(-j4表示4线程编译，缺省表示单线程)<br>sudo make modules_install<br>sudo make install<br>中间会出现错误：<br>error “__ipipe_dispatch_irq”的一个recipe target “modules”failed的问题<br>在kernel/ipipe/core.c 1603行加上    EXPORT_SYMBOL(__ipipe_dispatch_irq);即可。</p><h2 id="编译xenomai"><a href="#编译xenomai" class="headerlink" title="编译xenomai"></a>编译xenomai</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>进入xenomai源码目录 执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--with-pic</span> <span class="hljs-params">--with-core=cobalt</span> <span class="hljs-params">--enable-smp</span> <span class="hljs-params">--disable-tls</span> <span class="hljs-params">--enable-dlopen-libs</span> <span class="hljs-params">--disable-clock-monotonic-raw</span><br></code></pre></div></td></tr></table></figure><p>执行</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">sudo <span class="hljs-built_in">make</span> <br>sudo <span class="hljs-built_in">make</span> install<br></code></pre></div></td></tr></table></figure><p>完成安装；</p><h2 id="编译ethercat"><a href="#编译ethercat" class="headerlink" title="编译ethercat"></a>编译ethercat</h2><p>重启换成编译好的双内核版本ubuntu<br><img src="/medias/914.2.jpg"></p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p><a href="https://www.etherlab.org/en/ethercat/index.php">https://www.etherlab.org/en/ethercat/index.php</a><br>请不要下载官网源码：）我记得没错的话是直接有configure配置文件的，而没有bootstrap脚本来生成configure文件，用自带的configure编译出现各种函数错误，解决一个又来一个。<br>建议拉github的这个仓库git clone <a href="https://gitlab.com/etherlab.org/ethercat.git">https://gitlab.com/etherlab.org/ethercat.git</a></p><p>根据配置如下<br>./configure –with-linux-dir=linux源码目录 （不写就算当前运行的内核，建议不写） –enable-generic=yes –enable-8139too=yes –enable-rtdm=yes  –with-xenomai-dir=/usr/xenomai<br>如果有其他需求，请参照官网配置表格。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span><br><span class="hljs-built_in">make</span> modules<br><span class="hljs-built_in">make</span> install<br>sudo <span class="hljs-built_in">make</span> modules_install<br></code></pre></div></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>官方文档说编译后文件是在/opt/目录下，但是在ubuntu上是在/usr/local/ect目录下<br>进入/usr/local目录下<br>执行</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">cp <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/ethercat  /</span>etc<span class="hljs-regexp">/sysconfig/</span><br></code></pre></div></td></tr></table></figure><p>注意这里你的ubuntu可能在/etc下没有sysconfig，自己新建就好。<br>链接</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo ln -s etc<span class="hljs-regexp">/inin.d/</span>ethercat <span class="hljs-regexp">/etc/i</span>nit.d/<br></code></pre></div></td></tr></table></figure><p>修改/etc/sysconfig下的ethercat文件在master0_device=“”填入自己的mac地址，在DEVICE_MODULES=””填入generic。<br>保存<br>执行#sudo /etc/init.d/ethercat start 可以看到ethercat安装成功，执行ethercat salve 可以检测从站。<br><img src="/medias/914.1.png"><br><img src="/medias/914.0.png"></p><h2 id="qt界面开发"><a href="#qt界面开发" class="headerlink" title="qt界面开发"></a>qt界面开发</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>库链接<br><img src="/medias/914.png"><br>在qt开放时不能在qt上运行，一运行就显示permission denied,但是在shell中运行又显示找不到库<br>解决方法:<br>方法一：</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">sudo gedit <span class="hljs-regexp">/etc/</span>ld.so.conf<br>#加入<span class="hljs-regexp">/usr/</span>local/lib<br>#更新<span class="hljs-regexp">/etc/</span>ld.so.cache文件<br>ldconfig<br></code></pre></div></td></tr></table></figure><p>方法二：</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">sudo gedit <span class="hljs-regexp">/etc/</span>ld.so.conf.d/usr-lib.conf<br>#加入<span class="hljs-regexp">/usr /</span>local/lib<br>#更新<span class="hljs-regexp">/ect/</span>ld.so.cache文件<br>ldconfig<br></code></pre></div></td></tr></table></figure><p>再次运行成功！<br><img src="/medias/914.3.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>实验室</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang读取文件的方法</title>
    <link href="/2021/08/25/go%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/08/25/go%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>go语言初学，记录Golang 三种典型的拷贝文件方式</p><span id="more"></span><h2 id="1-io-Copy-方法"><a href="#1-io-Copy-方法" class="headerlink" title="1 io.Copy() 方法"></a>1 io.Copy() 方法</h2><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">import (<br>_<span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br>func myCopy(src,dst string)<span class="hljs-keyword">error</span> &#123;<br>r, <span class="hljs-keyword">err</span> :=os.<span class="hljs-keyword">Open</span>(src)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> !=nil &#123;<br><span class="hljs-keyword">log</span>.Println(<span class="hljs-keyword">err</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br><span class="hljs-keyword">file</span>, <span class="hljs-keyword">err</span> :=os.Create(dst)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> !=nil &#123;<br><span class="hljs-keyword">log</span>.Println(<span class="hljs-keyword">err</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br>defer <span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br>defer r.<span class="hljs-keyword">Close</span>()<br>io.<span class="hljs-keyword">Copy</span>(<span class="hljs-keyword">file</span>,r)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> :=r.<span class="hljs-keyword">Close</span>();<span class="hljs-keyword">err</span>!=nil &#123;<br><span class="hljs-keyword">log</span>.Panicln(<span class="hljs-keyword">err</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br><span class="hljs-keyword">return</span> nil<br>&#125;<br>func main() &#123;<br>src, dst :=os.<span class="hljs-keyword">Args</span>[1],os.<span class="hljs-keyword">Args</span>[2]<br><span class="hljs-keyword">err</span> :=myCopy(src,dst)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">log</span>.Fatalln(<span class="hljs-keyword">err</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单无脑，当然也可以在前面加上os.Stat()方法判断源文件是否存在，使用方法isRegular()确保文件可以被打开</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">sourceFileStat, err := os<span class="hljs-selector-class">.Stat</span>(<span class="hljs-attribute">src</span>)<br>    <span class="hljs-keyword">if</span> err != nil &#123;<br>        return err<br>    &#125;<br><span class="hljs-keyword">if</span> !sourceFileStat<span class="hljs-selector-class">.Mode</span><span class="hljs-selector-class">.IsRegular</span>() &#123;<br>    return fmt<span class="hljs-selector-class">.Errorf</span>(<span class="hljs-string">&quot;%s is not a regular file&quot;</span>, <span class="hljs-attribute">src</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是在我们复制文件的时候还想做更多，这种方法就明显不太可行了，有时需要灵活读取文件或写文件</p><h2 id="2-os-Read-和os-Write"><a href="#2-os-Read-和os-Write" class="headerlink" title="2 os.Read()和os.Write()"></a>2 os.Read()和os.Write()</h2><p>实现部分都一致，但是多了一个参数，即缓冲大小，os.Read()方法每次读取文件的一小部分至缓冲区，os.Write()方法写缓冲区至文件，在读过程中有错误或者读到文件结尾(io.EOF)拷贝过程停止。</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">package main<br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> BUFFERSIZE int64<br><br>func <span class="hljs-keyword">copy</span>(src, dst string, BUFFERSIZE int64) <span class="hljs-keyword">error</span> &#123;<br>sourceFileStat, <span class="hljs-keyword">err</span> := os.Stat(src)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !sourceFileStat.Mode().IsRegular() &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s is not a regular file.&quot;</span>, src)<br>&#125;<br><br>source, <span class="hljs-keyword">err</span> := os.<span class="hljs-keyword">Open</span>(src)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br>defer source.<span class="hljs-keyword">Close</span>()<br><br>_, <span class="hljs-keyword">err</span> = os.Stat(dst)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> == nil &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;File %s already exists.&quot;</span>, dst)<br>&#125;<br><br>destination, <span class="hljs-keyword">err</span> := os.Create(dst)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br>defer destination.<span class="hljs-keyword">Close</span>()<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>panic(<span class="hljs-keyword">err</span>)<br>&#125;<br><br>buf := make([]byte, BUFFERSIZE)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">n</span>, <span class="hljs-keyword">err</span> := source.<span class="hljs-keyword">Read</span>(buf)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &amp;&amp; <span class="hljs-keyword">err</span> != io.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">n</span> == 0 &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-keyword">if</span> _, <span class="hljs-keyword">err</span> := destination.Write(buf[:<span class="hljs-keyword">n</span>]); <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span><br>&#125;<br><br>func main() &#123;<br><span class="hljs-keyword">if</span> len(os.<span class="hljs-keyword">Args</span>) != 4 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;usage: %s source destination BUFFERSIZE\n&quot;</span>, filepath.Base(os.<span class="hljs-keyword">Args</span>[0]))<br><span class="hljs-keyword">return</span><br>&#125;<br><br>source := os.<span class="hljs-keyword">Args</span>[1]<br>destination := os.<span class="hljs-keyword">Args</span>[2]<br>BUFFERSIZE, <span class="hljs-keyword">err</span> := strconv.ParseInt(os.<span class="hljs-keyword">Args</span>[3], 10, 64)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Invalid buffer size: %q\n&quot;</span>, <span class="hljs-keyword">err</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Copying %s to %s\n&quot;</span>, source, destination)<br><span class="hljs-keyword">err</span> = <span class="hljs-keyword">copy</span>(source, destination, BUFFERSIZE)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>fmt.Printf(<span class="hljs-string">&quot;File copying failed: %q\n&quot;</span>, <span class="hljs-keyword">err</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正k/负k进制转换</title>
    <link href="/2021/08/12/%E6%AD%A3%E8%B4%9F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/08/12/%E6%AD%A3%E8%B4%9F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>平时都是作正K进制之间的转换，看到有负K进制表示方法，记录一下。以免自己忘记。</p><span id="more"></span><p>负进制，就是base为负数的进制<br>如负二进制下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">3=111<br>解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3<br>2=110<br>解释：(-2) ^ 2 + (-2) ^ 1 = 2<br></code></pre></div></td></tr></table></figure><p>当k&gt;0时是正常k进制，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">string str;<br><span class="hljs-keyword">while</span> (N != 0) &#123;<br>    int r = N % K;<br>    str=to_sting(r)+str;<br>    N /= K;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们以上面这个模版来推理K&lt;0的情况。</p><p>（1）首先，K&lt;0, 说明N在while过程中会正变负、负变正。K&gt;0时我们N/=K没问题，由于都是正数，我们右移就解决。但K&lt;0时，N/=K会导致漏了：【当前while下K指数为奇数时增加的值.】 比如K=-5, 指数为3，那么+(-5)^3是负数，就需要给N补上。举例说明：想象一下，以2为底得到的二进制, 比-2得到的负二进制数，显得小，比如3: 2进制是011, -2进制是111. 这里的(-2)^2,正是由于(-2)^1而产生的。所以，N/=K前需要加上：N -= r;</p><p>（2）res add的值应该是正数，而当前的r = N%K, 由于N有可能为负，所以会导致r为负。比如：-51%(-2)=-1. 为了产生正数的 int r，需要int r = abs(N)%abs(K). 从而得到：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">string str;<br><span class="hljs-keyword">while</span> (N != 0) &#123;<br>    int r = abs(N) % abs(K);<br>    str=to_sting(r)+str;<br>    N -= r;<br>    N /= K;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>+k/-k进制转换完整代码如下：<br>c++：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">class Solution &#123;<br>public:<br>    // 无论K是正数还是负数都支持（只支持-10～10进制，因为更高进制需要引入字母）<br>    string baseK(int N, int K) &#123;<br>        <span class="hljs-keyword">if</span> (N == 0) <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (N != 0) &#123;<br>            int r = ((N % K) + abs(K)) % abs(K); // 此处为关键<br>            res=to_string(r)+res;<br>            N -= r;<br>            N /= K;<br>        &#125;<br>        <span class="hljs-built_in">return</span> res;<br>    &#125;<br>    string baseNeg2(int N) &#123;<br>        string res = baseK(N, -2);<br>        <span class="hljs-built_in">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>python:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">class Solution:<br>    <span class="hljs-comment"># 通过数学推导可以得到+K/-K进制的通用转化法</span><br>    def baseK(self, N, K):<br>        alphabet = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span><br>        <span class="hljs-keyword">if</span> N == 0:<br>            <span class="hljs-built_in">return</span> [<span class="hljs-string">&quot;0&quot;</span>]<br>        res = []<br>        <span class="hljs-keyword">while</span> N != 0:<br>            temp = ((N % K) + abs(K)) % abs(K)<br>            res.append(alphabet[temp])<br>            N -= temp<br>            N //= K<br>        <span class="hljs-built_in">return</span> res[::-1]<br><br>    def baseNeg2(self, N: int) -&gt; str:<br>        nums = self.baseK(N, -2)<br>        <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;&quot;</span>.join(nums)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
